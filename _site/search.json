[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "",
    "text": "In this hands-on exercise, I learn how to import and wrangle Geospatial data using appropriate R packages."
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#getting-started",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#getting-started",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Getting Started",
    "text": "Getting Started\nThe code chunk below is installed to load sf and tidyverse packages into R environment.\n\n#pacman::p_load(sf,tidyverse)\nlibrary(sf)\n\nLinking to GEOS 3.9.3, GDAL 3.5.2, PROJ 8.2.1; sf_use_s2() is TRUE\n\nlibrary(tidyverse)\n\n── Attaching packages\n───────────────────────────────────────\ntidyverse 1.3.2 ──\n\n\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.8     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.1\n✔ readr   2.1.2     ✔ forcats 0.5.2\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\nlibrary(dplyr)"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#section-a-importing-geospatial-data",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#section-a-importing-geospatial-data",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Section A: Importing Geospatial Data",
    "text": "Section A: Importing Geospatial Data\nThe shapefile format can spatially describe vector features: (1) polygons, (2) polylines or (3) points.\n\nImporting polygon feature data\nThe st_read() function requires two input arguments ; dsn to define data path and layer to define the shapefile name.\n\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\yixin-neo\\ISSS624\\Hands-on_Ex01\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\n\n\nImporting polyline feature data\n\ncyclingpath <- st_read(dsn=\"data/geospatial\", layer = \"CyclingPathGazette\")\n\nReading layer `CyclingPathGazette' from data source \n  `C:\\yixin-neo\\ISSS624\\Hands-on_Ex01\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 2248 features and 2 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 11854.32 ymin: 28347.98 xmax: 42626.09 ymax: 48948.15\nProjected CRS: SVY21\n\n\n\nclass(cyclingpath)\n\n[1] \"sf\"         \"data.frame\"\n\n\n\n\nImporting GIS data in kml format\n\npreschool <- st_read(\"data/geospatial/pre-schools-location-kml.kml\")\n\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `C:\\yixin-neo\\ISSS624\\Hands-on_Ex01\\data\\geospatial\\pre-schools-location-kml.kml' \n  using driver `KML'\nSimple feature collection with 1925 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.247759 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n\n\nClick here or here for explanation on coordinate systems!\nDifferent projection can help to achieve:\n\nminimize distortion in shape\nminimize distortion in distance\nminimize distortion in area\nminimize distortion in direction.\n\nGoogle maps uses Mercator projection system. It is chosen as it preserves direction and angles. It is useful for navigation (google map) . It is originally created for sea navigation in older days. The cons are that this projection does not preserve area and shape.\n“Projected coordinate system flattens the globe whereas the geodesic one is still a spherical/ellipsoid globe” (Zhu, 2022)"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#section-b-checking-the-content-of-a-simple-feature-data-frame",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#section-b-checking-the-content-of-a-simple-feature-data-frame",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Section B: Checking the content of a Simple Feature Data Frame",
    "text": "Section B: Checking the content of a Simple Feature Data Frame\n\nWorking with st_geometry()\n\nst_geometry(mpsz)\n\nGeometry set for 323 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 5 geometries:\n\n\nMULTIPOLYGON (((31495.56 30140.01, 31980.96 296...\n\n\nMULTIPOLYGON (((29092.28 30021.89, 29119.64 300...\n\n\nMULTIPOLYGON (((29932.33 29879.12, 29947.32 298...\n\n\nMULTIPOLYGON (((27131.28 30059.73, 27088.33 297...\n\n\nMULTIPOLYGON (((26451.03 30396.46, 26440.47 303...\n\n\nBasic information like type of geometry, geographic extent of the features and the coordinate system (syv21) of the data is displayed.\n\n\nWorking with glimpse() of dplyr\nShows the data type of each field.\n\nglimpse(mpsz)\n\nRows: 323\nColumns: 16\n$ OBJECTID   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ SUBZONE_NO <int> 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1, 5, 1, 1, 3, 2, 2, …\n$ SUBZONE_N  <chr> \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL…\n$ SUBZONE_C  <chr> \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\",…\n$ CA_IND     <chr> \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",…\n$ PLN_AREA_N <chr> \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",…\n$ PLN_AREA_C <chr> \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM\", \"SR\", \"QT\", \"QT\",…\n$ REGION_N   <chr> \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT…\n$ REGION_C   <chr> \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\",…\n$ INC_CRC    <chr> \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",…\n$ FMEL_UPD_D <date> 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05…\n$ X_ADDR     <dbl> 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82,…\n$ Y_ADDR     <dbl> 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38,…\n$ SHAPE_Leng <dbl> 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913,…\n$ SHAPE_Area <dbl> 1630379.27, 559816.25, 160807.50, 595428.89, 387429.44, 103…\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (…\n\n\n\n\nWorking with head()\nReveals complete information of a feature object; show first 5 rows.\n\nhead(mpsz, n =5)\n\nSimple feature collection with 5 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 25867.68 ymin: 28369.47 xmax: 32362.39 ymax: 30435.54\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1        1          1   MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2        2          1   PEARL'S HILL    OTSZ01      Y          OUTRAM\n3        3          3      BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4        4          8 HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5        5          3        REDHILL    BMSZ03      N     BUKIT MERAH\n  PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1         MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2         OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3         SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4         BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5         BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n    Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1 29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2 29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3 29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4 29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5 30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30..."
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#section-c-plotting-the-geospatial-data",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#section-c-plotting-the-geospatial-data",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Section C: Plotting the Geospatial Data",
    "text": "Section C: Plotting the Geospatial Data\nThe amazing part about Choropleth map is that it is able to plot both numerical and categorical data!\n\nplot(mpsz)\n\nWarning: plotting the first 9 out of 15 attributes; use max.plot = 15 to plot\nall\n\n\n\n\n\nTo plot only the geometry:\n\nplot(st_geometry(mpsz))\n\n\n\n\nAlternatively, to plot the sf object by using only a specific attribute PLN_AREA_N:\n\nplot(mpsz[\"PLN_AREA_N\"])\n\n\n\n\n*Note: plot() is mean for plotting the Geospatial object for quick look. For high cartographic quality plot, other R package such as tmap should be used."
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#section-d-working-with-projection",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#section-d-working-with-projection",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Section D: Working with Projection",
    "text": "Section D: Working with Projection\nTo perform Geoprocessing using two Geospatial data, both sets of Geospatial data need to be projected using similar coordinate system. In this section, a simple feature data frame will be projected from one coordinate system to another coordinate system. This process is called projection transformation.\n\nAssigning EPSG code to a simple feature data frame\ncrs - coordinate reference system\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\nNote that the EPSG code for svy21 should be 3414, lets get it right.\n\nmpsz3414 <- st_set_crs(mpsz,3414)\n\nWarning: st_crs<- : replacing crs does not reproject data; use st_transform for\nthat\n\n\n\nst_crs(mpsz3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\n\n\nTransforming the projection of preschool from wgs84 to svy21\nWe transform original data in geographic coordinate system to projected coordinate system if the analysis requires the use of distance / area measurements.\n\nst_geometry(preschool)\n\nGeometry set for 1925 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.247759 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n\n\nPOINT Z (103.7009 1.338325 0)\n\n\nPOINT Z (103.8987 1.39044 0)\n\n\nPOINT Z (103.8068 1.438017 0)\n\n\nPOINT Z (103.7874 1.433436 0)\n\n\nPOINT Z (103.8886 1.395647 0)\n\n\npreschool simple feature data frame is in WSG84 coordinate system. To re-project preschool data frame to another coordinate system mathematically, use the st_transform() function of sf package.\n\npreschool3414 <- st_transform(preschool,crs=3414)\n\n\nst_geometry(preschool3414)\n\nGeometry set for 1925 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 11203.01 ymin: 25596.33 xmax: 45404.24 ymax: 49300.88\nz_range:       zmin: 0 zmax: 0\nProjected CRS: SVY21 / Singapore TM\nFirst 5 geometries:\n\n\nPOINT Z (13258.34 35611.04 0)\n\n\nPOINT Z (35272.09 41373.42 0)\n\n\nPOINT Z (25050.54 46634.14 0)\n\n\nPOINT Z (22892.48 46127.66 0)\n\n\nPOINT Z (34155.79 41949.13 0)"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#section-e-importing-and-converting-an-aspatial-data-and-save-it-as-tibble-data-frame-then-simple-feature-data-frame",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#section-e-importing-and-converting-an-aspatial-data-and-save-it-as-tibble-data-frame-then-simple-feature-data-frame",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Section E: Importing and converting an Aspatial Data and save it as tibble data frame, then simple feature data frame",
    "text": "Section E: Importing and converting an Aspatial Data and save it as tibble data frame, then simple feature data frame\n\nlibrary(readr)\nlistings <- read_csv(\"data/aspatial/listings.csv\")\n\nRows: 4161 Columns: 18\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr   (6): name, host_name, neighbourhood_group, neighbourhood, room_type, l...\ndbl  (11): id, host_id, latitude, longitude, price, minimum_nights, number_o...\ndate  (1): last_review\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nExamine whether data file has been imported correctly using list()\n\nlist(listings)\n\n[[1]]\n# A tibble: 4,161 × 18\n       id name     host_id host_…¹ neigh…² neigh…³ latit…⁴ longi…⁵ room_…⁶ price\n    <dbl> <chr>      <dbl> <chr>   <chr>   <chr>     <dbl>   <dbl> <chr>   <dbl>\n 1  50646 Pleasan…  227796 Sujatha Centra… Bukit …    1.33    104. Privat…    80\n 2  71609 Ensuite…  367042 Belinda East R… Tampin…    1.35    104. Privat…   145\n 3  71896 B&B  Ro…  367042 Belinda East R… Tampin…    1.35    104. Privat…    85\n 4  71903 Room 2-…  367042 Belinda East R… Tampin…    1.35    104. Privat…    85\n 5 275344 15 mins… 1439258 Kay     Centra… Bukit …    1.29    104. Privat…    49\n 6 289234 Booking…  367042 Belinda East R… Tampin…    1.34    104. Privat…   184\n 7 294281 5 mins … 1521514 Elizab… Centra… Newton     1.31    104. Privat…    79\n 8 324945 Cozy Bl… 1439258 Kay     Centra… Bukit …    1.29    104. Privat…    49\n 9 330089 Cozy Bl… 1439258 Kay     Centra… Bukit …    1.29    104. Privat…    55\n10 330095 10 mins… 1439258 Kay     Centra… Bukit …    1.29    104. Privat…    55\n# … with 4,151 more rows, 8 more variables: minimum_nights <dbl>,\n#   number_of_reviews <dbl>, last_review <date>, reviews_per_month <dbl>,\n#   calculated_host_listings_count <dbl>, availability_365 <dbl>,\n#   number_of_reviews_ltm <dbl>, license <chr>, and abbreviated variable names\n#   ¹​host_name, ²​neighbourhood_group, ³​neighbourhood, ⁴​latitude, ⁵​longitude,\n#   ⁶​room_type\n\n\n*note the latitude and longitude are in decimal degree format. It suggests the data in in WSG84 Geographic Coordinate System.\n\nCreating a simple feature data frame from an aspatial data frame\nTo convert listings data frame into a simple feature data frame, use the st_as_sf() of the sf packages.\n\nlibrary(dplyr)\nlibrary(sf)\nlibrary(tidyverse)\nlistings_sf <- st_as_sf(listings, coords=c(\"longitude\",\"latitude\"),crs=4326) %>% \n  st_transform(crs=3414)\n\n\ncoords argument requires you to provide the column name of the x-coordinates first then followed by the column name of the y-coordinates.\ncrs argument requires you to provide the coordinates system in epsg format. EPSG: 4326 is wgs84 Geographic Coordinate System and EPSG: 3414 is Singapore SVY21 Projected Coordinate System. You can search for other country’s epsg code by referring to epsg.io.\n%>% is used to nest st_transform() to transform the newly created simple feature data frame into svy21 projected coordinates system.\n\n\nglimpse(listings_sf)\n\nRows: 4,161\nColumns: 17\n$ id                             <dbl> 50646, 71609, 71896, 71903, 275344, 289…\n$ name                           <chr> \"Pleasant Room along Bukit Timah\", \"Ens…\n$ host_id                        <dbl> 227796, 367042, 367042, 367042, 1439258…\n$ host_name                      <chr> \"Sujatha\", \"Belinda\", \"Belinda\", \"Belin…\n$ neighbourhood_group            <chr> \"Central Region\", \"East Region\", \"East …\n$ neighbourhood                  <chr> \"Bukit Timah\", \"Tampines\", \"Tampines\", …\n$ room_type                      <chr> \"Private room\", \"Private room\", \"Privat…\n$ price                          <dbl> 80, 145, 85, 85, 49, 184, 79, 49, 55, 5…\n$ minimum_nights                 <dbl> 92, 92, 92, 92, 60, 92, 92, 60, 60, 60,…\n$ number_of_reviews              <dbl> 18, 20, 24, 47, 14, 12, 133, 17, 12, 3,…\n$ last_review                    <date> 2014-12-26, 2020-01-17, 2019-10-13, 20…\n$ reviews_per_month              <dbl> 0.18, 0.15, 0.18, 0.34, 0.11, 0.10, 1.0…\n$ calculated_host_listings_count <dbl> 1, 6, 6, 6, 44, 6, 7, 44, 44, 44, 6, 7,…\n$ availability_365               <dbl> 365, 340, 265, 365, 296, 285, 365, 181,…\n$ number_of_reviews_ltm          <dbl> 0, 0, 0, 0, 1, 0, 0, 3, 2, 0, 1, 0, 0, …\n$ license                        <chr> NA, NA, NA, NA, \"S0399\", NA, NA, \"S0399…\n$ geometry                       <POINT [m]> POINT (22646.02 35167.9), POINT (…\n\n\nA new column called geometry has been added into the data frame. On the other hand, the longitude and latitude columns have been dropped from the data frame.\n\nplot(listings_sf)\n\nWarning: plotting the first 9 out of 16 attributes; use max.plot = 16 to plot\nall"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#section-f-geoprocessing-with-sf-package",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#section-f-geoprocessing-with-sf-package",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Section F: Geoprocessing with sf package",
    "text": "Section F: Geoprocessing with sf package\n\nBuffering\nThe scenario:\nThe authority is planning to upgrade the exiting cycling path. To do so, they need to acquire 5 metres of reserved land on the both sides of the current cycling path. You are tasked to determine the extend of the land need to be acquired and their total area.\nSolution:\n\nst_buffer()\ncalculate buffer area using st_area() & create new column in sf data frame\nsum AREA column\n\n\nbuffer_cycling <- st_buffer(cyclingpath, dist= 5, nQuadSegs=30)\n\n\nplot(st_geometry(cyclingpath))\n\n\n\n\n\nplot(st_buffer(cyclingpath, dist= 5, nQuadSegs=30))\n\n\n\n\n\n# add a new and calculate new column AREA\nbuffer_cycling$AREA <- st_area(buffer_cycling)\n\n\n# Sum the column AREA\nsum(buffer_cycling$AREA)\n\n1556978 [m^2]\n\n\n\nclass(buffer_cycling)\n\n[1] \"sf\"         \"data.frame\"\n\n\n\nUnderstanding st_buffer() <- page 29\n\nl1 = st_as_sfc(\"LINESTRING(0 0,1 5,4 5,5 2,8 2,9 4,4 6.5)\")\nop = par(mfrow=c(2,3))\nplot(st_buffer(l1, dist = 1, endCapStyle=\"ROUND\"), reset = FALSE, main = \"endCapStyle: ROUND\")\nplot(l1,col='blue',add=TRUE)\nplot(st_buffer(l1, dist = 1, endCapStyle=\"FLAT\"), reset = FALSE, main = \"endCapStyle: FLAT\")\nplot(l1,col='blue',add=TRUE)\nplot(st_buffer(l1, dist = 1, endCapStyle=\"SQUARE\"), reset = FALSE, main = \"endCapStyle: SQUARE\")\nplot(l1,col='blue',add=TRUE)\nplot(st_buffer(l1, dist = 1, nQuadSegs=1), reset = FALSE, main = \"nQuadSegs: 1\")\nplot(l1,col='blue',add=TRUE)\nplot(st_buffer(l1, dist = 1, nQuadSegs=2), reset = FALSE, main = \"nQuadSegs: 2\")\nplot(l1,col='blue',add=TRUE)\nplot(st_buffer(l1, dist = 1, nQuadSegs= 5), reset = FALSE, main = \"nQuadSegs: 5\")\nplot(l1,col='blue',add=TRUE)\n\n\n\n\n\n\nHow to create simple feature (sf) object?\nhttps://mgimond.github.io/Spatial/anatomy-of-simple-feature-objects.html\n\n\n\nPoint-in-polygon count\nThe scenario:\nA pre-school service group want to find out the numbers of pre-schools in each Planning Subzone.\nSolution:\n\nst_intersects() The ST_Intersects() function returns t (TRUE) if the intersection of two geometries does not result in an empty set; otherwise, returns f (FALSE).\n*For intersection on pairs of simple feature geometries (two polygons), use the function st_intersection instead of st_intersects\nlengths() of base R\nGet or set the length of vectors (including lists) and factors, and of any other R object for which a method has been defined.\ntop_n() of dplyr package\n\nCode below shows the points lying in the polygons\n\n#mpsz3414 is polygon (323 entries) but preschool3414 is points (1925 entries)\ntest1 <- st_intersects(mpsz3414, preschool3414)\ntest1\n\nSparse geometry binary predicate list of length 323, where the\npredicate was `intersects'\nfirst 10 elements:\n 1: (empty)\n 2: 703, 1361, 1409, 1663, 1722\n 3: (empty)\n 4: 290, 687, 1071, 1780\n 5: 465, 1901\n 6: 65, 84, 88, 111, 120, 474, 518, 912, 1853, 1899\n 7: 705, 1250, 1407, 1544\n 8: 106, 489\n 9: 325, 793, 1577, 1604, 1803, 1843\n 10: 1656\n\n\nCode below sums the number of points in each polygon\n\nlengths(st_intersects(mpsz3414, preschool3414))\n\n  [1]  0  5  0  4  2 10  4  2  6  1  6  2  0  1  6  0  0  0  0  2  0  1  0  4  3\n [26]  1  7  2  9  7  0  0  4  0  3 10  1  3  0  5  0  3  1  0  3  0  3  1  6  0\n [51]  1  2  1  2  3  0  1  1  2  0  3  0  2  5  1  0 11  3 10  1  2  6  1  4  0\n [76]  0  2 10  0  0  1  0  4  1  2  0  0  3  0  5  3  3  0  0  5  0  0  2  0  3\n[101]  7  0 13  0  3  2  2 23 15 18  0  0  5  5  0  7 20 15  6  1  1  0  0  0  5\n[126]  5  3  0  0  7  4  4  8  5  5  3 11  8  6  0  3  6  2  0  1 21  0  5 14 10\n[151]  7 23 10  4  0  6  4  0  2  7  5  0 30  3 15  0 27 12  3 14  8 10  4  5  9\n[176] 10 25  0  0 11 11 30  8  0  7 17  4  4 58  8  0  3 28  7  2  2  9  3 31 14\n[201]  0 11  0 11  4 10 18 14  0  6 22 16  8 17 13 18  6 18 12  6  0 11  4 10 10\n[226]  7  5  8  1  7 17  3  8  0  0 16 10  9 14  7  7 14  4  1  3 19  2 10  5  9\n[251]  3  0 15  9  4  0  0  7 13 26  0 13 19 14  0 12 21  0  2  0  0 30 17  0 19\n[276]  6  6  5  5  0  0 12 17 18  1  0 16  1  0 47 23  1  7  0  0  9  0  0  0 10\n[301]  0  0  1  0 17 16  8 10  2 13  0  0  0  1  0  0  2  0  0  3  0  0  0\n\n\nCombining all together and creating a new column in mpsz3414\n\n#mpsz3414 is polygon but preschool3414 is points\nmpsz3414$`Presch Count` <- lengths(st_intersects(mpsz3414, preschool3414))\n\n\nsummary(mpsz3414$`Presch Count`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00    0.00    3.00    5.96    9.00   58.00 \n\n\nFind subzone with most number of preschools in Singapore\n\ntop_n(mpsz3414, 1,`Presch Count`)\n\nSimple feature collection with 1 feature and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 39655.33 ymin: 35966 xmax: 42940.57 ymax: 38622.37\nProjected CRS: SVY21 / Singapore TM\n  OBJECTID SUBZONE_NO     SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n1      189          2 TAMPINES EAST    TMSZ02      N   TAMPINES         TM\n     REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR SHAPE_Leng\n1 EAST REGION       ER 21658EAAF84F4D8D 2014-12-05 41122.55 37392.39   10180.62\n  SHAPE_Area                       geometry Presch Count\n1    4339824 MULTIPOLYGON (((42196.76 38...           58\n\n\nNext task: Calculate the density of pre-school by planning subzone.\nSolution:\n\nuse st_area() of sf package to derive the area of each planning subzone\nNext, mutate() of dplyr package is used to compute the density\n\n\nmpsz3414$AREA <- mpsz3414 %>% st_area()\n\n\nmpsz3414 <- mpsz3414 %>% mutate(`PreSch Density` = `Presch Count`/AREA *100000)\n\n\ntop_n(mpsz3414, 5,`PreSch Density`)\n\nSimple feature collection with 5 features and 18 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 25594.22 ymin: 28623.75 xmax: 32860.5 ymax: 48182.13\nProjected CRS: SVY21 / Singapore TM\n  OBJECTID SUBZONE_NO         SUBZONE_N SUBZONE_C CA_IND    PLN_AREA_N\n1       27          8             CECIL    DTSZ08      Y DOWNTOWN CORE\n2       37          4           PHILLIP    DTSZ04      Y DOWNTOWN CORE\n3      253          3   SERANGOON NORTH    SGSZ03      N     SERANGOON\n4      278          3     MANDAI ESTATE    MDSZ03      N        MANDAI\n5      291          3 SEMBAWANG CENTRAL    SBSZ03      N     SEMBAWANG\n  PLN_AREA_C          REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1         DT    CENTRAL REGION       CR 65AA82AF6F4D925D 2014-12-05 29730.20\n2         DT    CENTRAL REGION       CR 615D4EDDEF809F8E 2014-12-05 29706.72\n3         SG NORTH-EAST REGION      NER C685042EC58E5C55 2014-12-05 32458.80\n4         MD      NORTH REGION       NR F6266F7368DBB9AB 2014-12-05 27082.70\n5         SB      NORTH REGION       NR 772A64AB9A93FC3A 2014-12-05 26268.73\n    Y_ADDR SHAPE_Leng SHAPE_Area                       geometry Presch Count\n1 29011.33  2116.0947  196619.86 MULTIPOLYGON (((29808.18 28...            7\n2 29744.91   871.5549   39437.94 MULTIPOLYGON (((29814.11 29...            1\n3 39597.64  3610.7324  684704.30 MULTIPOLYGON (((32860.5 397...           15\n4 45367.46  1633.7084  143137.94 MULTIPOLYGON (((27119.56 45...            5\n5 47558.08  3955.1176  962437.40 MULTIPOLYGON (((26311.14 46...           23\n             AREA   PreSch Density\n1 196619.86 [m^2] 3.560169 [1/m^2]\n2  39437.94 [m^2] 2.535630 [1/m^2]\n3 684704.30 [m^2] 2.190727 [1/m^2]\n4 143137.94 [m^2] 3.493134 [1/m^2]\n5 962437.40 [m^2] 2.389766 [1/m^2]\n\n\n\nplot(mpsz3414[\"PreSch Density\"])"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#section-g-exploratory-data-analysis-eda",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#section-g-exploratory-data-analysis-eda",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Section G: Exploratory Data Analysis (EDA)",
    "text": "Section G: Exploratory Data Analysis (EDA)\nUsing ggplot2 functions to create functional and yet truthful statistical graphs for EDA purposes.\n\nhist(mpsz3414$`PreSch Density` ,main = \"Histogram of PreSch Density in Planning subzones\", xlab = \"Density\")\n\n\n\n\n\nggplot(data=mpsz3414,\n       aes(x=as.numeric(`PreSch Density`))) + \n  geom_histogram(bins=20,\n                 color='black',\n                 fill =\"light blue\") +\n  labs(title= 'Are Pre-schools evenly distributed in Singapore?',\n       subtitle = 'There are many planning subzones with a single pre-school, on the other hand, \\nthere are two planning subzones with at least 20 pre-schools',\n       x='Pre-School Density (per km sq)',\n       y= 'Frequency')\n\n\n\n\n\nggplot(data=mpsz3414,\n       aes(x=as.numeric(`PreSch Density`), y= as.numeric(`Presch Count`))) + \n  geom_point(color='blue') +\n  labs(title= 'Scatterplot of Pre-school Count against Density',\n       x='Pre-school Density (per km sq)',\n       y= 'Pre-School Count')"
  },
  {
    "objectID": "Hands-on_Ex02/Hands-on_Ex02.html",
    "href": "Hands-on_Ex02/Hands-on_Ex02.html",
    "title": "Hands-on_Ex02",
    "section": "",
    "text": "In this hands-on exercise, I learn how to plot functional and truthful choropleth maps by using r packages called tmap package.\nBeside tmap package, four other R packages will be used. They are:\n\nreadr for importing delimited text file,\ntidyr for tidying data,\ndplyr for wrangling data and\nsf for handling geospatial data.\n\n\n#pacman::p_load(sf,tmap, tidyverse)\nlibrary(sf)\n\nLinking to GEOS 3.9.3, GDAL 3.5.2, PROJ 8.2.1; sf_use_s2() is TRUE\n\nlibrary(tidyverse)\n\n── Attaching packages\n───────────────────────────────────────\ntidyverse 1.3.2 ──\n\n\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.8     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.1\n✔ readr   2.1.2     ✔ forcats 0.5.2\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\nlibrary(tmap)"
  },
  {
    "objectID": "Hands-on_Ex02/Hands-on_Ex02.html#overview",
    "href": "Hands-on_Ex02/Hands-on_Ex02.html#overview",
    "title": "Hands-on_Ex02",
    "section": "Overview",
    "text": "Overview\nIn this hands-on exercise, I learn how to plot functional and truthful choropleth maps by using r packages called tmap package."
  },
  {
    "objectID": "Hands-on_Ex1.html",
    "href": "Hands-on_Ex1.html",
    "title": "Hands-on Exercise 1",
    "section": "",
    "text": "This is the overview paragraph."
  },
  {
    "objectID": "Hands-on_Ex1.html#getting-started",
    "href": "Hands-on_Ex1.html#getting-started",
    "title": "Hands-on Exercise 1",
    "section": "Getting started",
    "text": "Getting started\nThis is the getting started page."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ISSS624",
    "section": "",
    "text": "In this webpage, I am going to share with you my learning journey of Geospatial analytics."
  },
  {
    "objectID": "Hands-on_Ex02/Hands-on_Ex02.html#import-geospatial-data-into-r",
    "href": "Hands-on_Ex02/Hands-on_Ex02.html#import-geospatial-data-into-r",
    "title": "Hands-on_Ex02",
    "section": "2.3.2 Import Geospatial Data into R",
    "text": "2.3.2 Import Geospatial Data into R\n\nmpsz <- st_read(dsn=\"data/geospatial\", layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\yixin-neo\\ISSS624\\Hands-on_Ex02\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\n\nmpsz\n\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 10 features:\n   OBJECTID SUBZONE_NO       SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1         1          1    MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2         2          1    PEARL'S HILL    OTSZ01      Y          OUTRAM\n3         3          3       BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4         4          8  HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5         5          3         REDHILL    BMSZ03      N     BUKIT MERAH\n6         6          7  ALEXANDRA HILL    BMSZ07      N     BUKIT MERAH\n7         7          9   BUKIT HO SWEE    BMSZ09      N     BUKIT MERAH\n8         8          2     CLARKE QUAY    SRSZ02      Y SINGAPORE RIVER\n9         9         13 PASIR PANJANG 1    QTSZ13      N      QUEENSTOWN\n10       10          7       QUEENSWAY    QTSZ07      N      QUEENSTOWN\n   PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1          MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2          OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3          SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4          BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5          BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n6          BM CENTRAL REGION       CR 9D286521EF5E3B59 2014-12-05 25358.82\n7          BM CENTRAL REGION       CR 7839A8577144EFE2 2014-12-05 27680.06\n8          SR CENTRAL REGION       CR 48661DC0FBA09F7A 2014-12-05 29253.21\n9          QT CENTRAL REGION       CR 1F721290C421BFAB 2014-12-05 22077.34\n10         QT CENTRAL REGION       CR 3580D2AFFBEE914C 2014-12-05 24168.31\n     Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1  29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2  29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3  29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4  29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5  30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n6  29991.38   4428.913  1030378.8 MULTIPOLYGON (((25899.7 297...\n7  30230.86   3275.312   551732.0 MULTIPOLYGON (((27746.95 30...\n8  30222.86   2208.619   290184.7 MULTIPOLYGON (((29351.26 29...\n9  29893.78   6571.323  1084792.3 MULTIPOLYGON (((20996.49 30...\n10 30104.18   3454.239   631644.3 MULTIPOLYGON (((24472.11 29..."
  },
  {
    "objectID": "Hands-on_Ex02/Hands-on_Ex02.html#import-attribute-data-into-r",
    "href": "Hands-on_Ex02/Hands-on_Ex02.html#import-attribute-data-into-r",
    "title": "Hands-on_Ex02",
    "section": "2.3.3 Import attribute data into R",
    "text": "2.3.3 Import attribute data into R\n\npopdata <- read_csv(\"data/aspatial/respopagesextod2011to2020.csv\")\n\nRows: 984656 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): PA, SZ, AG, Sex, TOD\ndbl (2): Pop, Time\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\npopdata %>% head()\n\n# A tibble: 6 × 7\n  PA         SZ                     AG     Sex   TOD                   Pop  Time\n  <chr>      <chr>                  <chr>  <chr> <chr>               <dbl> <dbl>\n1 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HDB 1- and 2-Room …     0  2011\n2 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HDB 3-Room Flats       10  2011\n3 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HDB 4-Room Flats       30  2011\n4 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HDB 5-Room and Exe…    50  2011\n5 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HUDC Flats (exclud…     0  2011\n6 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males Landed Properties       0  2011"
  },
  {
    "objectID": "Hands-on_Ex02/Hands-on_Ex02.html#data-preparation",
    "href": "Hands-on_Ex02/Hands-on_Ex02.html#data-preparation",
    "title": "Hands-on_Ex02",
    "section": "2.3.4 Data preparation",
    "text": "2.3.4 Data preparation\nPrepare a data table with year 2020 values. The data table should include the variables PA, SZ, YOUNG, ECONOMY ACTIVE, AGED, TOTAL, DEPENDENCY.\n\nYOUNG: age group 0 to 4 until age groyup 20 to 24,\nECONOMY ACTIVE: age group 25-29 until age group 60-64,\nAGED: age group 65 and above,\nTOTAL: all age group, and\nDEPENDENCY: the ratio between young and aged against economy active group\n\n\n\n\n\n2.3.4.1 Data Wrangling\n\npivot_wider() (rows to column headers) of tidyr package, and\nmutate() (create new cal col), filter() (subset rows), group_by() and select() (select cols) of dplyr package\n\n\npopdata2020 <- popdata %>% \n  filter(Time == 2020) %>% \n  group_by(PA,SZ,AG) %>% \n  summarise(POP = sum(Pop)) %>% \n  ungroup() %>% \n  pivot_wider(names_from = AG,values_from = POP) %>% \n  mutate(YOUNG = rowSums(.[3:6])\n         +rowSums(.[12])) %>% \n  mutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+rowSums(.[13:15])) %>%\n  mutate(AGED = rowSums(.[16:21])) %>%\n  mutate(TOTAL = rowSums(.[3:21])) %>% \n  mutate(DEPENDENCY = (YOUNG + AGED)/`ECONOMY ACTIVE`) %>% \n  select(PA,SZ,YOUNG,`ECONOMY ACTIVE`, AGED, TOTAL, DEPENDENCY)\n\n`summarise()` has grouped output by 'PA', 'SZ'. You can override using the\n`.groups` argument.\n\npopdata2020 \n\n# A tibble: 332 × 7\n   PA         SZ                     YOUNG `ECONOMY ACTIVE`  AGED TOTAL DEPEND…¹\n   <chr>      <chr>                  <dbl>            <dbl> <dbl> <dbl>    <dbl>\n 1 Ang Mo Kio Ang Mo Kio Town Centre  1290             2760   760  4810    0.743\n 2 Ang Mo Kio Cheng San               5640            16460  6050 28150    0.710\n 3 Ang Mo Kio Chong Boon              5100            15000  6470 26570    0.771\n 4 Ang Mo Kio Kebun Bahru             4620            13010  5120 22750    0.749\n 5 Ang Mo Kio Sembawang Hills         1880             3630  1310  6820    0.879\n 6 Ang Mo Kio Shangri-La              3330             9050  3610 15990    0.767\n 7 Ang Mo Kio Tagore                  1940             4480  1530  7950    0.775\n 8 Ang Mo Kio Townsville              4190            11950  5100 21240    0.777\n 9 Ang Mo Kio Yio Chu Kang               0                0     0     0  NaN    \n10 Ang Mo Kio Yio Chu Kang East       1110             2410   750  4270    0.772\n# … with 322 more rows, and abbreviated variable name ¹​DEPENDENCY\n\n\nRefer to this link for difference between group_by() - mutate() and group_by() - summarise()\nungroup() usually done after performing calculation in group()\n\npopdata20201 <- popdata %>% \n  filter(Time == 2020) %>% \n  group_by(PA,SZ,AG) %>% \n  summarise(POP = sum(Pop))\n\n`summarise()` has grouped output by 'PA', 'SZ'. You can override using the\n`.groups` argument.\n\npopdata20201\n\n# A tibble: 6,308 × 4\n# Groups:   PA, SZ [332]\n   PA         SZ                     AG         POP\n   <chr>      <chr>                  <chr>    <dbl>\n 1 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4     170\n 2 Ang Mo Kio Ang Mo Kio Town Centre 10_to_14   280\n 3 Ang Mo Kio Ang Mo Kio Town Centre 15_to_19   340\n 4 Ang Mo Kio Ang Mo Kio Town Centre 20_to_24   270\n 5 Ang Mo Kio Ang Mo Kio Town Centre 25_to_29   260\n 6 Ang Mo Kio Ang Mo Kio Town Centre 30_to_34   310\n 7 Ang Mo Kio Ang Mo Kio Town Centre 35_to_39   330\n 8 Ang Mo Kio Ang Mo Kio Town Centre 40_to_44   400\n 9 Ang Mo Kio Ang Mo Kio Town Centre 45_to_49   480\n10 Ang Mo Kio Ang Mo Kio Town Centre 5_to_9     230\n# … with 6,298 more rows\n\n\n\n\n2.3.4.2 Joining the attribute data and geospatial data\nConvert PA and SZ fields in popdata2020 into all uppercase using:\n\ntoupper() <- to upper case\nmutate.at()<- mutate multiple columns\nargument: .var <- list of columns generated by vars()\nargument: .funs <- a function fun, a quosure style lambda\n\n\npopdata2020 <- popdata2020 %>% \n  mutate_at(.var= vars(PA,SZ),\n            .funs = funs(toupper)) %>%\n  filter(`ECONOMY ACTIVE` >0)\n\nWarning: `funs()` was deprecated in dplyr 0.8.0.\nPlease use a list of either functions or lambdas: \n\n  # Simple named list: \n  list(mean = mean, median = median)\n\n  # Auto named with `tibble::lst()`: \n  tibble::lst(mean, median)\n\n  # Using lambdas\n  list(~ mean(., trim = .2), ~ median(., na.rm = TRUE))\nThis warning is displayed once every 8 hours.\nCall `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.\n\n\nNext, left_join() of dplyr is used to join the geographical data and attribute table using planning subzone name e.g. SUBZONE_N and SZ as the common identifier.\n\nmpsz_pop2020 <- left_join(mpsz, popdata2020,\n                          by = c(\"SUBZONE_N\" = \"SZ\"))\n\n\n#write_rds(mpsz_pop2020, \"data/rds/mpszpop2020.rds\")"
  },
  {
    "objectID": "Hands-on_Ex02/Hands-on_Ex02.html#choropleth-mapping-geospatial-data-using-tmap",
    "href": "Hands-on_Ex02/Hands-on_Ex02.html#choropleth-mapping-geospatial-data-using-tmap",
    "title": "Hands-on_Ex02",
    "section": "2.4 Choropleth Mapping Geospatial Data Using tmap",
    "text": "2.4 Choropleth Mapping Geospatial Data Using tmap\nTwo approaches can be used to prepare thematic map using tmap, they are:\n\nPlotting a thematic map quickly by using qtm() (Quick thematic plot)\nPlotting highly customisable thematic map by using tmap elements.\n\n\n2.4.1 Plotting a choropleth map quickly using qtm()\n\ntop_n(mpsz_pop2020, 1,`DEPENDENCY`)\n\nSimple feature collection with 1 feature and 21 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 42513.65 ymin: 38644.89 xmax: 44163.44 ymax: 41072.58\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO   SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n1      229          6 LOYANG WEST    PRSZ06      N  PASIR RIS         PR\n     REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR SHAPE_Leng\n1 EAST REGION       ER 05FD555397CBEE7A 2014-12-05 43294.83 39888.77   6203.002\n  SHAPE_Area        PA YOUNG ECONOMY ACTIVE AGED TOTAL DEPENDENCY\n1    2114789 PASIR RIS     0             10  190   200         19\n                        geometry\n1 MULTIPOLYGON (((43756.39 39...\n\n\n\ntmap_mode(\"plot\")\n\ntmap mode set to plotting\n\nqtm(mpsz_pop2020,\n    fill = \"DEPENDENCY\")\n\n\n\n\nThings to learn from the code chunk above:\n\ntmap_mode() with “plot” option is used to produce a static map. For interactive mode, “view” option should be used.\nfill argument is used to map the attribute (i.e. DEPENDENCY)\n\n\n\nCreating a Choropleth map by using tmap’s elements\ntm_shape() <- define input data and specify the shape object / spatial data object\ntm_fill() <- fills polygons (no border)\n\nstyle: method to process the color scale when col (data variable) is a numeric variable. To process numeric and categorical use “cat”\npalette : palettes names or vectors of colors. default is taken from tm_layout’s aes.paletttes argument. To reverse the colour scheme , add a “-” prefix.\n\ntm_borders() <- draws the borders of polygons (alpha is 0-1, transparency)\ntm_polygons() (= tm_fill() + tm_borders() )<- fills the polygon and draws the polygon borders\n*qtm = shape + polygon or * qtm = shape + fill + border\ntm_layout() <- specify map layout\n\naes.palette <- ‘seq’ (sequential palettes), ‘div’ (diverging palettes) , ‘cat’ (categorical palettes)\n\ntm_compass() <- create map compass\ntm_scale_bar() <- creates scale bar\ntm_grid() <- creates grid lines (alpha is 0-1, transparency of grid lines)\ntm_credits() <- create a text for credits\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Reds\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha =0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n2.4.2.1 Drawing a base map\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons()\n\n\n\n\n\n\n2.4.2.2 Drawing a choropleth map using tm_polygons()\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons('DEPENDENCY')\n\n\n\n\nThings to learn from tm_polygons():\n\nThe default interval binning used to draw the choropleth map is called “pretty”. A detailed discussion of the data classification methods supported by tmap will be provided in sub-section 4.3.\nThe default colour scheme used is YlOrRd of ColorBrewer. You will learn more about the color scheme in sub-section 4.4.\nBy default, Missing value will be shaded in grey.\n\n\n\n2.4.2.3. Drawing a choropleth map using tm_fill() and tm_border()\n\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY')\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY')+\n  tm_borders(alpha = 1 , lwd = 0.5)\n\n\n\n\nBeside alpha argument, there are three other arguments for tm_borders(), they are:\n\ncol = border colour,\nlwd = border line width. The default is 1, and\nlty = border line type. The default is “solid”.\n\n\n\n\n\n2.4.3 Data classification methods of tmap\nThe point of classification is to take a large number of observations and group them into data ranges or classes.\ntmap provides a total ten data classification methods, namely: fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, and jenks.\nTo define a data classification method, the style argument of tm_fill() or tm_polygons() will be used.\n\nPlotting choropleth maps with built-in classification methods\nQuantile classification with 5 classes The Jenks method clusters data into groups that minimize the within-group variance and maximize the between-group variance.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", n = 5, style = 'jenks') +\n  tm_borders(alpha = 0.5)\n\n\n\n\nEqual data classification\n\ntm_shape(mpsz_pop2020)+\n    tm_fill(\"DEPENDENCY\", n = 5, style = 'equal') +\n  tm_borders(alpha = 0.5)\n\n\n\n\nNotice that the distribution of quantile data classification method are more evenly distributed then equal data classification method.\n\nDIY: Using what you had learned, prepare choropleth maps by using different classification methods supported by tmap and compare their differences.\n\n\ntm_shape(mpsz_pop2020)+\n    tm_fill(\"DEPENDENCY\", n = 5, style = 'kmeans') +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n    tm_fill(\"DEPENDENCY\", n = 5, style = 'sd') +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n    tm_fill(\"DEPENDENCY\", n = 5, style = 'fisher') +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\nDIY: Preparing choropleth maps by using similar classification method but with different numbers of classes (i.e. 2, 6, 10, 20). Compare the output maps, what observation can you draw?\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", n = 3, style = 'jenks') +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", n = 10, style = 'jenks') +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n2.4.3.2 Plotting choropleth maps with custome break\nThe breakpoints can be set explicitly by means of the breaks argument to the tm_fill().\n\nbreaks include min and max\nto have n categories, n+1 elements to be specified in breaks option\nvalues must be in increasing order\n\nGood practise: descriptive statistics on variable before setting break points\n\nsummary(mpsz_pop2020$DEPENDENCY)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.0000  0.6519  0.7025  0.7742  0.7645 19.0000      92 \n\n\n\nboxplot(mpsz_pop2020$DEPENDENCY, outline=FALSE)\n\n\n\n\nWith reference to summary stats and boxplot above,\n\nbreak points are 0.6, 0.7, 0.8, 0.9\nmin = 0 and max = 1.0\nbreak vector is thus c(0, 0.6, 0.7, 0.8, 0.9, 1.0)\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", breaks = c(0, 0.6, 0.7, 0.8, 0.9, 1.0)) +\n  tm_borders(alpha = 0.5)\n\nWarning: Values have found that are higher than the highest break\n\n\n\n\n\n\n\n\n2.4.4 Colour scheme\n\n2.4.4.1 Using ColourBrewer palette\nAssign the preferred colour to palette argument of tm_fill()\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"Blues\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nReverse the colour scheme by adding “-”\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n2.4.5 Map Layouts\n\ncustomise title, scale bar, compass, margins, aspect ratios\nother than colour palette and data classification (breaks) which is done in tm_fill()\n\n\n2.4.5.1 Map Legend\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"jenks\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone \\n(Jenks classification)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            legend.outside = FALSE,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n2.4.5.2 Map style\ntmap allows a wide variety of layout settings to be changed. They can be called by using tmap_style()\nPredefined styles: ‘white’, ‘gray’, ‘natural’, ‘bw’, ‘classic’, ‘cobalt’, albatross’, ‘beaver’, ‘col_blind’, ‘watercolor’\nBelow is an example of classic style\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5)+\n  tmap_style('natural')\n\ntmap style set to \"natural\"\n\n\nother available styles are: \"white\", \"gray\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\n\n\n2.4.5.3 Cartographic Furniture\nCan include other map furniture like compass, scale bar, and grid lines\ntmap_style has to be used at the last, think cannot mix with tm\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Reds\",\n          title = \"No. of persons\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio \\nby planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\")) +\n  tmap_style('natural')\n\ntmap style set to \"natural\"\n\n\nother available styles are: \"white\", \"gray\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\nTo reset the default style, refer below\n\ntmap_style(\"white\")\n\ntmap style set to \"white\"\n\n\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\n2.4.6 Drawing Small Multiple Choropleth Maps\nSmall multiple maps, also referred to as facet maps, are composed of many maps arrange side-by-side, and sometimes stacked vertically. Small multiple maps enable the visualisation of how spatial relationships change with respect to another variable, such as time.\nIn tmap, small multiple maps can be plotted in three ways:\n\nby assigning multiple values to at least one of the asthetic arguments,\nby defining a group-by variable in tm_facets(), and\nby creating multiple stand-alone maps with tmap_arrange().\n\n\n\n2.4.6.1 By assigning multiple values to at least one of the aesthetic arguments\n\ndefine ncols in tm_fill() : c(‘YOUNG’, ‘AGED’ , ‘TOTAL’)\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(c('YOUNG', 'AGED','TOTAL'),\n          style='equal',\n          palette='Blues') +\n  tm_layout(legend.position = c('right','bottom')) +\n  tm_borders(alpha = 0.5) +\n  tmap_style('white')\n\ntmap style set to \"white\"\n\n\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\n\nAssigning multiple values to at least one of the aesthetic arguments\n\n\nshape + polygon method (Prof’s)\n\n\ntm_shape(mpsz_pop2020)+ \n  tm_polygons(c(\"DEPENDENCY\",\"AGED\"),\n          style = c(\"equal\", \"quantile\"), \n          palette = list(\"Blues\",\"Greens\")) +\n  tm_layout(legend.position = c(\"right\", \"bottom\")) +\n  tmap_style('white')\n\ntmap style set to \"white\"\n\n\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\n\nshape + fill + borders method (YX’s)\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(c('YOUNG', 'AGED','TOTAL'),\n          style=c('equal', 'quantile', 'equal'),\n          palette= list('Blues', 'Greens', 'Reds')) +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.position = c('right','bottom'))\n\n\n\n#  tmap_style('white')\n\n\n\n2.4.6.2 By defining a group-by variable in tm_facets()\nIn this example, multiple small choropleth maps are created by using tm_facets().\nthres.poly: number that specifies the threshold at which polygons are taken into account. The number itself corresponds to the proportion of the area sizes of the polygons to the total polygon size. By default, all polygons are drawn.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          style= 'quantile',\n          palette = 'Blues',\n          thres.poly = 0) +\n  tm_facets(by = 'REGION_N',\n            free.coords = TRUE,\n            drop.shapes = TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c('center','center'),\n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n\nWarning: The argument drop.shapes has been renamed to drop.units, and is\ntherefore deprecated\n\n\n\n\n\n\n\n2.4.6.3 By creating multiple stand-alone maps with tmap_arrange()\nCreating multiple stand-alone maps with tmap_arrange() asp : aspect ratio\nnrow : number of rows (ncols)\n\nyoungmap <- tm_shape(mpsz_pop2020) + \n  tm_polygons('YOUNG',\n              style= 'quantile',\n              palette = 'Blues')\n\nagedmap <- tm_shape(mpsz_pop2020) + \n  tm_polygons('AGED',\n              style= 'quantile',\n              palette = 'Blues')\n\ntmap_arrange(youngmap,agedmap, asp = 3, nrow=2)\n\n\n\n\n\n\n\n2.4.7 Mappping Spatial Object Meeting a Selection Criterion\n\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N == \"CENTRAL REGION\",]) +\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(main.title = \"Mapping spatial obj with conditions \\n(Central Region)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.45, \n            legend.width = 5.0,\n            legend.outside = TRUE,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\nWarning in pre_process_gt(x, interactive = interactive, orig_crs =\ngm$shape.orig_crs): legend.width controls the width of the legend within a map.\nPlease use legend.outside.size to control the width of the outside legend\n\n\n\n\n\nhttps://rstudio-pubs-static.s3.amazonaws.com/730482_d7889d9c65c8422f843b3d4e0196633c.html"
  },
  {
    "objectID": "Hands-on_Ex02/Hands-on_Ex02.html#reference",
    "href": "Hands-on_Ex02/Hands-on_Ex02.html#reference",
    "title": "Hands-on_Ex02",
    "section": "2.5 Reference",
    "text": "2.5 Reference\n\n2.5.1 All about tmap package\n\ntmap: Thematic Maps in R\ntmap\ntmap: get started!\ntmap: changes in version 2.0\ntmap: creating thematic maps in a flexible way (useR!2015)\nExploring and presenting maps with tmap (useR!2017)\n\n\n\n2.5.2 Geospatial data wrangling\n\nsf: Simple Features for R\nSimple Features for R: StandardizedSupport for Spatial Vector Data\nReading, Writing and Converting Simple Features\n\n\n\n2.5.3 Data wrangling\n\ndplyr\nTidy data\ntidyr: Easily Tidy Data with ‘spread()’ and ‘gather()’ Functions"
  },
  {
    "objectID": "Hands-on_Ex03/Hands-on_ex03.html",
    "href": "Hands-on_Ex03/Hands-on_ex03.html",
    "title": "Hands-on_Ex03",
    "section": "",
    "text": "In this hands-on exercise, I will learn how to compute spatial weights."
  },
  {
    "objectID": "Hands-on_Ex03/Hands-on_ex03.html#the-study-area-and-data",
    "href": "Hands-on_Ex03/Hands-on_ex03.html#the-study-area-and-data",
    "title": "Hands-on_Ex03",
    "section": "3.2 The Study Area and Data",
    "text": "3.2 The Study Area and Data\n\nHunan country boundary layer -geospatial data in ESRI shapefile format\nhunan_2012.csv - contains local development indicators in 2012\n\n\n3.2.1 Getting Started (ctrl-atl-i)\n\nlibrary(sf)\n\nLinking to GEOS 3.9.3, GDAL 3.5.2, PROJ 8.2.1; sf_use_s2() is TRUE\n\nlibrary(spdep)\n\nLoading required package: sp\n\n\nLoading required package: spData\n\n\nTo access larger datasets in this package, install the spDataLarge\npackage with: `install.packages('spDataLarge',\nrepos='https://nowosad.github.io/drat/', type='source')`\n\nlibrary(tmap)\nlibrary(tidyverse)\n\n── Attaching packages\n───────────────────────────────────────\ntidyverse 1.3.2 ──\n\n\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.8     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.1\n✔ readr   2.1.2     ✔ forcats 0.5.2\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()"
  },
  {
    "objectID": "Hands-on_Ex03/Hands-on_ex03.html#getting-the-data-into-r-environment",
    "href": "Hands-on_Ex03/Hands-on_ex03.html#getting-the-data-into-r-environment",
    "title": "Hands-on_Ex03",
    "section": "3.3 Getting the Data Into R Environment",
    "text": "3.3 Getting the Data Into R Environment\n\n3.3.1 Import shapefile into r environment\n\nhunan <- st_read(dsn='data/geospatial' ,\n                 layer = 'Hunan')\n\nReading layer `Hunan' from data source \n  `C:\\yixin-neo\\ISSS624\\Hands-on_Ex03\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\n\n\n3.3.2 Import csv file into r environment\n\nhunan2012 <- read_csv('data/aspatial/Hunan_2012.csv')\n\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\n3.3.3 Performing relational join\nUpdate attribute table of Hunan’s SpatialPolygonDataFrame (dbf) with attribute field of hunan2012 dataframe. (csv)\n\nhunan <- left_join(hunan, hunan2012)\n\nJoining, by = \"County\"\n\n\nhunan ’s coordinate system is WGS 84. Does it mean that we are nut using projected system here?\n\nst_geometry(hunan)\n\nGeometry set for 88 features \nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n\n\nPOLYGON ((112.0625 29.75523, 112.069 29.74544, ...\n\n\nPOLYGON ((112.2288 29.11684, 112.2339 29.11214,...\n\n\nPOLYGON ((111.8927 29.6013, 111.8906 29.59811, ...\n\n\nPOLYGON ((111.3731 29.94649, 111.3737 29.94167,...\n\n\nPOLYGON ((111.6324 29.76288, 111.6312 29.75165,..."
  },
  {
    "objectID": "Hands-on_Ex03/Hands-on_ex03.html#visualising-regional-development-indicator",
    "href": "Hands-on_Ex03/Hands-on_ex03.html#visualising-regional-development-indicator",
    "title": "Hands-on_Ex03",
    "section": "3.4 Visualising Regional Development Indicator",
    "text": "3.4 Visualising Regional Development Indicator\n\nprepare basemap and choropleth map showing distribution of GDPCC 2012 by using qtm() of tmap package\n\n\nbasemap <- tm_shape(hunan) +\n  tm_polygons() +\n  tm_text('NAME_3', size = 0.3)\n\ngdppc <- qtm(hunan, 'GDPPC')\n\ntmap_arrange(basemap, gdppc, asp = 1, ncol=2)"
  },
  {
    "objectID": "Hands-on_Ex03/Hands-on_ex03.html#computing-contiguity-spatial-weights",
    "href": "Hands-on_Ex03/Hands-on_ex03.html#computing-contiguity-spatial-weights",
    "title": "Hands-on_Ex03",
    "section": "3.5 Computing Contiguity Spatial Weights",
    "text": "3.5 Computing Contiguity Spatial Weights\n\nuse poly2nb() of spdep package to compute contiguity weight matrices\nthis weight matrices has class of ‘nb’\nthis function builds a neighbour list based on regions with contiguous boundaries\nthe ‘queen’ argument’s default value is set to FALSE (first order neighbours). Might need to set to TRUE when needed\n\n\n3.5.1 Computing (QUEEN) contiguity based neighbours\n\nwm_q <- poly2nb(hunan, queen=TRUE)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\n\n88 area units in Hunan\nmost connected unit (88) has 11 neighbours\ntwo area units (30 & 65) with only one neighbour\n\nTo see the neighbours of the first polygon, use code chunk below:\n\nwm_q[[1]]\n\n[1]  2  3  4 57 85\n\n\n\nclass(wm_q[[1]])\n\n[1] \"integer\"\n\n\nYX tried to show the neighbours of first 2 polygons\n\nwm_q[1:2]\n\n[[1]]\n[1]  2  3  4 57 85\n\n[[2]]\n[1]  1 57 58 78 85\n\n\nTo retrieve the country name of the Polygon ID = 1, use code chunk below:\n\nhunan$County[1]\n\n[1] \"Anxiang\"\n\n\nTo reveal the country names of the five neighbouring polygons,\n\nhunan$NAME_3[c(2,3,4,57,85)]\n\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n\n\nTo retrieve the GDPPC of the five neighbour countries,\n\nnb1 <- wm_q[[1]]\nnb1 <- hunan$GDPPC[nb1]\nnb1\n\n[1] 20981 34592 24473 21311 22879\n\n\nYX’s practise (use c(2,3,4,57,85)) instead of wm_q[[1]]\n\nnb1 <- wm_q[[1]] #neighbours of polygon ID=1\nnb1 <- hunan$GDPPC[c(2,3,4,57,85)] #retrieve GDPPC of neighbours of polygon ID= 1\nnb1\n\n[1] 20981 34592 24473 21311 22879\n\n\nTo display the complete weight matrix, use str()\n\nrow 1: neighbours of polygon ID =1\nrow 2: neighbours of polygon ID =2 etc..\n\n\nstr(wm_q)\n\nList of 88\n $ : int [1:5] 2 3 4 57 85\n $ : int [1:5] 1 57 58 78 85\n $ : int [1:4] 1 4 5 85\n $ : int [1:4] 1 3 5 6\n $ : int [1:4] 3 4 6 85\n $ : int [1:5] 4 5 69 75 85\n $ : int [1:4] 67 71 74 84\n $ : int [1:7] 9 46 47 56 78 80 86\n $ : int [1:6] 8 66 68 78 84 86\n $ : int [1:8] 16 17 19 20 22 70 72 73\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:3] 11 15 17\n $ : int [1:4] 13 14 17 83\n $ : int [1:5] 10 17 22 72 83\n $ : int [1:7] 10 11 14 15 16 72 83\n $ : int [1:5] 20 22 23 77 83\n $ : int [1:6] 10 20 21 73 74 86\n $ : int [1:7] 10 18 19 21 22 23 82\n $ : int [1:5] 19 20 35 82 86\n $ : int [1:5] 10 16 18 20 83\n $ : int [1:7] 18 20 38 41 77 79 82\n $ : int [1:5] 25 28 31 32 54\n $ : int [1:5] 24 28 31 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:3] 26 29 42\n $ : int [1:5] 24 25 33 49 54\n $ : int [1:3] 27 37 42\n $ : int 33\n $ : int [1:8] 24 25 32 36 39 40 56 81\n $ : int [1:8] 24 31 50 54 55 56 75 85\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 47 80 82 86\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:4] 29 42 43 44\n $ : int [1:4] 23 44 77 79\n $ : int [1:5] 31 40 42 43 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:7] 26 27 29 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:4] 37 38 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:3] 8 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:5] 32 48 52 54 55\n $ : int [1:3] 48 49 52\n $ : int [1:5] 48 49 50 51 54\n $ : int [1:3] 48 55 75\n $ : int [1:6] 24 28 32 49 50 52\n $ : int [1:5] 32 48 50 53 75\n $ : int [1:7] 8 31 32 36 78 80 85\n $ : int [1:6] 1 2 58 64 76 85\n $ : int [1:5] 2 57 68 76 78\n $ : int [1:4] 60 61 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:7] 12 59 60 62 63 77 87\n $ : int [1:3] 61 77 87\n $ : int [1:4] 12 61 77 83\n $ : int [1:2] 57 76\n $ : int 76\n $ : int [1:5] 9 67 68 76 84\n $ : int [1:4] 7 66 76 84\n $ : int [1:5] 9 58 66 76 78\n $ : int [1:3] 6 75 85\n $ : int [1:3] 10 72 73\n $ : int [1:3] 7 73 74\n $ : int [1:5] 10 11 16 17 70\n $ : int [1:5] 10 19 70 71 74\n $ : int [1:6] 7 19 71 73 84 86\n $ : int [1:6] 6 32 53 55 69 85\n $ : int [1:7] 57 58 64 65 66 67 68\n $ : int [1:7] 18 23 38 61 62 63 83\n $ : int [1:7] 2 8 9 56 58 68 85\n $ : int [1:7] 23 38 40 41 43 44 45\n $ : int [1:8] 8 34 35 36 41 45 47 56\n $ : int [1:6] 25 26 31 33 39 42\n $ : int [1:5] 20 21 23 35 41\n $ : int [1:9] 12 13 15 16 17 18 22 63 77\n $ : int [1:6] 7 9 66 67 74 86\n $ : int [1:11] 1 2 3 5 6 32 56 57 69 75 ...\n $ : int [1:9] 8 9 19 21 35 46 47 74 84\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language poly2nb(pl = hunan, queen = TRUE)\n - attr(*, \"type\")= chr \"queen\"\n - attr(*, \"sym\")= logi TRUE\n\n\n\n\n3.5.2 Creating (ROOK) contiguity based neighbours\nTo compute the Rook contiguity weight matrix,\n\nwm_r <- poly2nb(hunan, queen=FALSE)\nsummary(wm_r)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links\n\n\n\n88 area units in Hunan\nmost connected unit (85) has 11 neighbours\ntwo area units (30 & 65) with only one neighbour\n\n\n\n3.5.3 Visualising contiguity weights (find centroid coords first)\n\na connectivity graph takes a point and displays a line to each neighbouring point\nneed a point in polygon via polygon centroids <- calculate using the sf package first\n\nTo obtain coordinates in a separate data frame\n\ninput vector is the geometry column of us.bound, an sf object <- a polygon\napply mapping function (st_centroid) on input vector <- find the CG of this polygon\nuse map_dbl variation of map from the purrr package\n\nAfter finding centroid, to access longitude values\n\ndouble bracket notation [[ ]] and 1\n\n\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n\nTo access the latitude value\n\ndouble bracket notation [[ ]] and 2\n\n\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n\nWith both longitude and latitude, use cbind() to combine both in the same object,\n\ncoords <- cbind(longitude, latitude)\n\nCheck the first few observations,\n\nhead(coords)\n\n     longitude latitude\n[1,]  112.1531 29.44362\n[2,]  112.0372 28.86489\n[3,]  111.8917 29.47107\n[4,]  111.7031 29.74499\n[5,]  111.6138 29.49258\n[6,]  111.0341 29.79863\n\n\n\n3.5.3.1 Plotting Queen contiguity based neighbours map\nUse the plot() function\n\nThe shape of the markers: The plot markers are by default small, empty circles. These are also known as plot characters - denoted by pch. You can change these by adding a new pch value in the plot function. Pch values 0 to 25 are valid and give several different symbols on the graph. Pch 0 is for a square, 1 is for a circle, 3 is for a triangle, 4 is for a cross and so on.\nSize of the plot markers: This aspect of a graph can be controlled using the cex parameter. The cex parameter can be set to 0.5 if you want the markers to be 50% smaller and 1.5 if you want them to be 50% larger.\nColor of the plot markers: The symbols can be assigned one or many colors. These colors can be selected from a list provided by R under the colors() function.\n\nwm_ q is weight matrix using queen method (88 rows of list of neighbours)\ncoords is an array of x,y coordinates for each of the 88 counties\n\nplot(hunan$geometry, border = 'lightgrey')\nplot(wm_q, coords, pch = 19, cex = 0.6, add= TRUE, col='red')\n\n\n\n\n\n\n3.5.3.2 Plotting Rook contiguity based neighbours map\n\nplot(hunan$geometry, border = 'lightgrey')\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col =\"blue\")\n\n\n\n\n\n\n3.5.3.3 Plotting both Queen and Rook contiguity based neighbours maps\nUse the par(mfrow) function\n\npar(mfrow = c(1,2))  # by 1 by 2 plotting matrix\nplot(hunan$geometry, border=\"lightgrey\", main=\"Queen Contiguity\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\")\nplot(hunan$geometry, border=\"lightgrey\", main=\"Rook Contiguity\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\")"
  },
  {
    "objectID": "Hands-on_Ex03/Hands-on_ex03.html#computing-distance-based-neighbours",
    "href": "Hands-on_Ex03/Hands-on_ex03.html#computing-distance-based-neighbours",
    "title": "Hands-on_Ex03",
    "section": "3.6 Computing distance based neighbours",
    "text": "3.6 Computing distance based neighbours\n\nIn this section, I will derive distance-based weight matrices by using dnearneigh() of spdep package.\ndnearneigh(x, d1, d2, row.names = NULL, longlat = NULL, bounds=c(\"GE\", \"LE\"),\n use_kd_tree=TRUE, symtest=FALSE, use_s2=packageVersion(\"s2\") > \"1.0.7\", k=200,\n dwithin=TRUE)\nidentifies neighbours using distance band with lower d1= and upper d2= bounds controlled by the bounds= argument\nIf unprojected coordinates are used and either specified in the coordinates object x or with x as a two column matrix and longlat=TRUE, great circle distances in km will be calculated assuming the WGS84 reference ellipsoid.\n\n\n3.6.1 First, determine the cut-off distance (upper distance threshold to be considered a neighbour)\nFirst, determine the upper limit for distance band by using the steps below:\n\nReturn a matrix with the indices of points belonging to the set of the k nearest neighbours of each other by using knearneigh() of spdep. Output: NN of poly1 = poly3, NN of poly2 = poly 78 etc…. The output iz a knn object with class ‘knn’.\n$nn\n[,1]\n[1,] 3\n[2,] 78\n[3,] 1\nAfter applying knearneigh() , convert the knn object into a neighbours list of class nb with a list of integer vectors containing neighbour region number ids by using knn2nb().\n\nNeighbour list object:\nNumber of regions: 88\nNumber of nonzero links: 88\nPercentage nonzero weights: 1.136364\nAverage number of links: 1\nNon-symmetric neighbours list\n\nReturn the length of neighbour relationship edges by using nbdists() of spdep. <- returns the distance to one’s nearest neighbour? 88 polygons means 88 nearest neighbours. The function returns in the units of the coordinates if the coordinates are projected (in km if unprojected)\n\n[[1]]\n[1] 25.53398\n[[2]]\n[1] 43.03114\n[[3]]\n[1] 25.53398\n\nRemove the list structure of the returned object by using unlist(). The output is in numeric format.\n\nOutput: 25.53398 43.03114 25.53398 29.28480 29.28480 45.98097 58.52704 28.95985 34.45062 37.99885 44.49442 33.48816 35.98123\n\n#coords <- coordinates(hunan)\nk1 <- knn2nb(knearneigh(coords)) # nb class with 1 NN\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE)) #dist to 1 NN, class numeric\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\nThe summary report shows that the largest first nearest neighbour distance is 61.79. So using this as the upper threshold will help to ensure that all units (polygons) will have at least one neighbour.\n\nclass (k1)\n\n[1] \"nb\"\n\n\n\nclass(k1dists)\n\n[1] \"numeric\"\n\n\n\n\n3.6.2 Computing fixed distance weight matrix\n(Earlier, we had used poly2nb(hunan, queen=TRUE/FALSE) to find neighbours using Queen or Rook method)\nNow, to find neighbours using distance, we use the dnearneigh() ,\n\nlonglad argument: TRUE if point coordinates are geographical longitude-latitude decimal degrees\n\nDoes the average number of links mean that each polygon has average number of 3.6 nearest neighbours with upper bound of 62?\n\nwm_d62 <- dnearneigh(coords,0, 62, longlat=TRUE)  #class 'nb' by upper bound distance\nwm_d62\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n\n\n\nstr(wm_d62)\n\nList of 88\n $ : int [1:5] 3 4 5 57 64\n $ : int [1:4] 57 58 78 85\n $ : int [1:4] 1 4 5 57\n $ : int [1:3] 1 3 5\n $ : int [1:4] 1 3 4 85\n $ : int 69\n $ : int [1:2] 67 84\n $ : int [1:4] 9 46 47 78\n $ : int [1:4] 8 46 68 84\n $ : int [1:4] 16 22 70 72\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:2] 11 17\n $ : int 13\n $ : int [1:4] 10 17 22 83\n $ : int [1:3] 11 14 16\n $ : int [1:3] 20 22 63\n $ : int [1:5] 20 21 73 74 82\n $ : int [1:5] 18 19 21 22 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:4] 10 16 18 20\n $ : int [1:3] 41 77 82\n $ : int [1:4] 25 28 31 54\n $ : int [1:4] 24 28 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:2] 26 29\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:2] 27 37\n $ : int 33\n $ : int [1:2] 24 36\n $ : int 50\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:5] 31 34 45 56 80\n $ : int [1:2] 29 42\n $ : int [1:3] 44 77 79\n $ : int [1:4] 40 42 43 81\n $ : int [1:3] 39 45 79\n $ : int [1:5] 23 35 45 79 82\n $ : int [1:5] 26 37 39 43 81\n $ : int [1:3] 39 42 44\n $ : int [1:2] 38 43\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:5] 8 9 35 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:4] 48 49 50 52\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:2] 48 55\n $ : int [1:5] 24 28 49 50 52\n $ : int [1:4] 48 50 53 75\n $ : int 36\n $ : int [1:5] 1 2 3 58 64\n $ : int [1:5] 2 57 64 66 68\n $ : int [1:3] 60 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:5] 12 60 62 63 87\n $ : int [1:4] 61 63 77 87\n $ : int [1:5] 12 18 61 62 83\n $ : int [1:4] 1 57 58 76\n $ : int 76\n $ : int [1:5] 58 67 68 76 84\n $ : int [1:2] 7 66\n $ : int [1:4] 9 58 66 84\n $ : int [1:2] 6 75\n $ : int [1:3] 10 72 73\n $ : int [1:2] 73 74\n $ : int [1:3] 10 11 70\n $ : int [1:4] 19 70 71 74\n $ : int [1:5] 19 21 71 73 86\n $ : int [1:2] 55 69\n $ : int [1:3] 64 65 66\n $ : int [1:3] 23 38 62\n $ : int [1:2] 2 8\n $ : int [1:4] 38 40 41 45\n $ : int [1:5] 34 35 36 45 47\n $ : int [1:5] 25 26 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:4] 12 13 16 63\n $ : int [1:4] 7 9 66 68\n $ : int [1:2] 2 5\n $ : int [1:4] 21 46 47 74\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language dnearneigh(x = coords, d1 = 0, d2 = 62, longlat = TRUE)\n - attr(*, \"dnn\")= num [1:2] 0 62\n - attr(*, \"bounds\")= chr [1:2] \"GE\" \"LE\"\n - attr(*, \"nbtype\")= chr \"distance\"\n - attr(*, \"sym\")= logi TRUE\n\n\nAnother way to display the structure of the weight matrix is to combine table() and card() of spdep.\n\ntable(hunan$County, card(wm_d62))\n\n               \n                1 2 3 4 5 6\n  Anhua         1 0 0 0 0 0\n  Anren         0 0 0 1 0 0\n  Anxiang       0 0 0 0 1 0\n  Baojing       0 0 0 0 1 0\n  Chaling       0 0 1 0 0 0\n  Changning     0 0 1 0 0 0\n  Changsha      0 0 0 1 0 0\n  Chengbu       0 1 0 0 0 0\n  Chenxi        0 0 0 1 0 0\n  Cili          0 1 0 0 0 0\n  Dao           0 0 0 1 0 0\n  Dongan        0 0 1 0 0 0\n  Dongkou       0 0 0 1 0 0\n  Fenghuang     0 0 0 1 0 0\n  Guidong       0 0 1 0 0 0\n  Guiyang       0 0 0 1 0 0\n  Guzhang       0 0 0 0 0 1\n  Hanshou       0 0 0 1 0 0\n  Hengdong      0 0 0 0 1 0\n  Hengnan       0 0 0 0 1 0\n  Hengshan      0 0 0 0 0 1\n  Hengyang      0 0 0 0 0 1\n  Hongjiang     0 0 0 0 1 0\n  Huarong       0 0 0 1 0 0\n  Huayuan       0 0 0 1 0 0\n  Huitong       0 0 0 1 0 0\n  Jiahe         0 0 0 0 1 0\n  Jianghua      0 0 1 0 0 0\n  Jiangyong     0 1 0 0 0 0\n  Jingzhou      0 1 0 0 0 0\n  Jinshi        0 0 0 1 0 0\n  Jishou        0 0 0 0 0 1\n  Lanshan       0 0 0 1 0 0\n  Leiyang       0 0 0 1 0 0\n  Lengshuijiang 0 0 1 0 0 0\n  Li            0 0 1 0 0 0\n  Lianyuan      0 0 0 0 1 0\n  Liling        0 1 0 0 0 0\n  Linli         0 0 0 1 0 0\n  Linwu         0 0 0 1 0 0\n  Linxiang      1 0 0 0 0 0\n  Liuyang       0 1 0 0 0 0\n  Longhui       0 0 1 0 0 0\n  Longshan      0 1 0 0 0 0\n  Luxi          0 0 0 0 1 0\n  Mayang        0 0 0 0 0 1\n  Miluo         0 0 0 0 1 0\n  Nan           0 0 0 0 1 0\n  Ningxiang     0 0 0 1 0 0\n  Ningyuan      0 0 0 0 1 0\n  Pingjiang     0 1 0 0 0 0\n  Qidong        0 0 1 0 0 0\n  Qiyang        0 0 1 0 0 0\n  Rucheng       0 1 0 0 0 0\n  Sangzhi       0 1 0 0 0 0\n  Shaodong      0 0 0 0 1 0\n  Shaoshan      0 0 0 0 1 0\n  Shaoyang      0 0 0 1 0 0\n  Shimen        1 0 0 0 0 0\n  Shuangfeng    0 0 0 0 0 1\n  Shuangpai     0 0 0 1 0 0\n  Suining       0 0 0 0 1 0\n  Taojiang      0 1 0 0 0 0\n  Taoyuan       0 1 0 0 0 0\n  Tongdao       0 1 0 0 0 0\n  Wangcheng     0 0 0 1 0 0\n  Wugang        0 0 1 0 0 0\n  Xiangtan      0 0 0 1 0 0\n  Xiangxiang    0 0 0 0 1 0\n  Xiangyin      0 0 0 1 0 0\n  Xinhua        0 0 0 0 1 0\n  Xinhuang      1 0 0 0 0 0\n  Xinning       0 1 0 0 0 0\n  Xinshao       0 0 0 0 0 1\n  Xintian       0 0 0 0 1 0\n  Xupu          0 1 0 0 0 0\n  Yanling       0 0 1 0 0 0\n  Yizhang       1 0 0 0 0 0\n  Yongshun      0 0 0 1 0 0\n  Yongxing      0 0 0 1 0 0\n  You           0 0 0 1 0 0\n  Yuanjiang     0 0 0 0 1 0\n  Yuanling      1 0 0 0 0 0\n  Yueyang       0 0 1 0 0 0\n  Zhijiang      0 0 0 0 1 0\n  Zhongfang     0 0 0 1 0 0\n  Zhuzhou       0 0 0 0 1 0\n  Zixing        0 0 1 0 0 0\n\n\n\nn_comp <- n.comp.nb(wm_d62)\nn_comp$nc\n\n[1] 1\n\n\n\ntable(n_comp$comp.id)\n\n\n 1 \n88 \n\n\n\n3.6.2.1 Plotting fixed distance weight matrix\n\nwm_d62 is the fixed distance weight matrix,\ncoords refers to long, lat coordinates for CG of each polygon\nk1 is the integer ID of the polygon which is the nearest neighbour to me\n\n\nplot(hunan$geometry, border = 'lightgrey')\nplot (wm_d62, coords,add=TRUE)\nplot(k1, coords, add=TRUE, col ='red', length=0.08)\n\n\n\n\nThe red lines shows the links of 1st nearest neighbours and the black lines show the lines of neighbours within the cut-off distance of 62km.\nTo plot red and black side by side,\n\npar(mfrow=c(1,2))\nplot(hunan$geometry, border='light grey', main=\"1st NN\")\nplot(k1, coords, add=TRUE, col=\"red\", length='0.08')\nplot(hunan$geometry, border='light grey', main='Distance Link')\nplot(wm_d62, coords, add=TRUE, pch=19, cex=0.6)\n\n\n\n\n\n\n\n3.6.3 Computing adaptive distance weight matrix\nOne of the characteristics of fixed distance weight matrix is that more densely settled areas (usually the urban areas) tend to have more neighbours and the less densely settled areas (usually the rural counties) tend to have lesser neighbours. Having many neighbours smoothes the neighbour relationship across more neighbours.\nIt is possible to control the numbers of neighbours directly using k-nearest neighbours, either accepting asymmetric neighbours or imposing symmetry as shown in the code chunk below.\n\nknn6 <- knn2nb(knearneigh(coords, k = 6)) # class nb by fixed NN\nknn6\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 528 \nPercentage nonzero weights: 6.818182 \nAverage number of links: 6 \nNon-symmetric neighbours list\n\n\n*as seen above, each polygon has strictly six neighbours\n\nstr(knn6)\n\nList of 88\n $ : int [1:6] 2 3 4 5 57 64\n $ : int [1:6] 1 3 57 58 78 85\n $ : int [1:6] 1 2 4 5 57 85\n $ : int [1:6] 1 3 5 6 69 85\n $ : int [1:6] 1 3 4 6 69 85\n $ : int [1:6] 3 4 5 69 75 85\n $ : int [1:6] 9 66 67 71 74 84\n $ : int [1:6] 9 46 47 78 80 86\n $ : int [1:6] 8 46 66 68 84 86\n $ : int [1:6] 16 19 22 70 72 73\n $ : int [1:6] 10 14 16 17 70 72\n $ : int [1:6] 13 15 60 61 63 83\n $ : int [1:6] 12 15 60 61 63 83\n $ : int [1:6] 11 15 16 17 72 83\n $ : int [1:6] 12 13 14 17 60 83\n $ : int [1:6] 10 11 17 22 72 83\n $ : int [1:6] 10 11 14 16 72 83\n $ : int [1:6] 20 22 23 63 77 83\n $ : int [1:6] 10 20 21 73 74 82\n $ : int [1:6] 18 19 21 22 23 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:6] 10 16 18 19 20 83\n $ : int [1:6] 18 20 41 77 79 82\n $ : int [1:6] 25 28 31 52 54 81\n $ : int [1:6] 24 28 31 33 54 81\n $ : int [1:6] 25 27 29 33 42 81\n $ : int [1:6] 26 29 30 37 42 81\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:6] 26 27 37 42 43 81\n $ : int [1:6] 26 27 28 33 49 81\n $ : int [1:6] 24 25 36 39 40 54\n $ : int [1:6] 24 31 50 54 55 56\n $ : int [1:6] 25 26 28 30 49 81\n $ : int [1:6] 36 40 41 45 56 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:6] 26 27 29 42 43 44\n $ : int [1:6] 23 43 44 62 77 79\n $ : int [1:6] 25 40 42 43 44 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:6] 26 27 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:6] 37 38 39 42 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:6] 8 9 35 47 78 86\n $ : int [1:6] 8 21 35 46 80 86\n $ : int [1:6] 49 50 51 52 53 55\n $ : int [1:6] 28 33 48 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:6] 28 48 49 50 52 54\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:6] 48 50 51 52 55 75\n $ : int [1:6] 24 28 49 50 51 52\n $ : int [1:6] 32 48 50 52 53 75\n $ : int [1:6] 32 34 36 78 80 85\n $ : int [1:6] 1 2 3 58 64 68\n $ : int [1:6] 2 57 64 66 68 78\n $ : int [1:6] 12 13 60 61 87 88\n $ : int [1:6] 12 13 59 61 63 87\n $ : int [1:6] 12 13 60 62 63 87\n $ : int [1:6] 12 38 61 63 77 87\n $ : int [1:6] 12 18 60 61 62 83\n $ : int [1:6] 1 3 57 58 68 76\n $ : int [1:6] 58 64 66 67 68 76\n $ : int [1:6] 9 58 67 68 76 84\n $ : int [1:6] 7 65 66 68 76 84\n $ : int [1:6] 9 57 58 66 78 84\n $ : int [1:6] 4 5 6 32 75 85\n $ : int [1:6] 10 16 19 22 72 73\n $ : int [1:6] 7 19 73 74 84 86\n $ : int [1:6] 10 11 14 16 17 70\n $ : int [1:6] 10 19 21 70 71 74\n $ : int [1:6] 19 21 71 73 84 86\n $ : int [1:6] 6 32 50 53 55 69\n $ : int [1:6] 58 64 65 66 67 68\n $ : int [1:6] 18 23 38 61 62 63\n $ : int [1:6] 2 8 9 46 58 68\n $ : int [1:6] 38 40 41 43 44 45\n $ : int [1:6] 34 35 36 41 45 47\n $ : int [1:6] 25 26 28 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:6] 12 13 15 16 22 63\n $ : int [1:6] 7 9 66 68 71 74\n $ : int [1:6] 2 3 4 5 56 69\n $ : int [1:6] 8 9 21 46 47 74\n $ : int [1:6] 59 60 61 62 63 88\n $ : int [1:6] 59 60 61 62 63 87\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language knearneigh(x = coords, k = 6)\n - attr(*, \"sym\")= logi FALSE\n - attr(*, \"type\")= chr \"knn\"\n - attr(*, \"knn-k\")= num 6\n - attr(*, \"class\")= chr \"nb\"\n\n\n\n3.6.3.1 Plotting distance based neighbours\n\nplot(hunan$geometry, border=\"light grey\")\nplot(knn6, coords, pch= 19, cex=0.6, add=TRUE, col='red')"
  },
  {
    "objectID": "Hands-on_Ex03/Hands-on_ex03.html#weights-based-on-idw",
    "href": "Hands-on_Ex03/Hands-on_ex03.html#weights-based-on-idw",
    "title": "Hands-on_Ex03",
    "section": "3.7 Weights based on IDW",
    "text": "3.7 Weights based on IDW\nCompute the spatial weight matrix using the Inversed Distance Method\n\nrecall from lecture that closer polygon has greater weightage if we take inverse\n\nFirst compute distance between areas using y using nbdists() of spdep.\n\nGiven a list of spatial neighbour links (a neighbours list of object type nb), the function returns the Euclidean distances along the links in a list of the same form as the neighbours list. If longlat = TRUE, Great Circle distances are used.\n\nThen obtain the inversed-dist spatial weight matrix (ids) using lapply() to apply the function 1/(x), where x is the distance.\n\ndist <- nbdists(wm_q, coords, longlat = TRUE)  # class nbdists\n# [[1]] 65.12941 25.53398 54.91802 35.61352 87.32760\n#[[2]] 65.12941 56.67944 51.92312 43.03114 58.16151\nids <-lapply (dist, function(x) 1/(x)) # class list, inverse dist \nhead(ids)\n\n[[1]]\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n\n[[2]]\n[1] 0.01535405 0.01764308 0.01925924 0.02323898 0.01719350\n\n[[3]]\n[1] 0.03916350 0.02822040 0.03695795 0.01395765\n\n[[4]]\n[1] 0.01820896 0.02822040 0.03414741 0.01539065\n\n[[5]]\n[1] 0.03695795 0.03414741 0.01524598 0.01618354\n\n[[6]]\n[1] 0.015390649 0.015245977 0.021748129 0.011883901 0.009810297\n\n\n\n3.7.1 Row-standardised weights matrix\nUse the nb2listw()\nnb2listw(neighbours, glist=NULL, style=\"W\", zero.policy=NULL)\nArguments\n\n\n\n\n\n\n\nneighbours\nan object of class nb\n\n\n\n\nglist\nlist of general weights corresponding to neighbours\n\n\nstyle\nstyle can take values \"W\", \"B\", \"C\", \"U\", \"minmax\" and \"S\"\n\n\nzero.policy\ndefault NULL, use global option value; if FALSE stop with error for any empty neighbour sets, if TRUE permit the weights list to be formed with zero-length weights vectors\n\n\n\nDetails\nStarting from a binary neighbours list, in which regions are either listed as neighbours or are absent (thus not in the set of neighbours for some definition), the function adds a weights list with values given by the coding scheme style chosen.\nWeights to each neighboring polygon\n\neach neighboring polygon will be assigned equal weight (style=\"W\") <- row standardised\nThis is accomplished by assigning the fraction 1/(#ofneighbors) to each neighboring county then summing the weighted income values\ndrawback of this method is that polygon along the edge will base their lagged values on fewer polygons, thus over estimating the true nature of spatial autocorrelation in the data. Next time can consider other more robust options are available, notably style=\"B\" <- basic binary coding\n\n\nrswm_q <- nb2listw(wm_q, style = 'W', zero.policy = TRUE)\nrswm_q # class\"listw\" \"nb\"  \n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\nThe zero.policy=TRUE option allows for lists of non-neighbors. This should be used with caution since the user may not be aware of missing neighbors in their dataset however, a zero.policy of FALSE would return an error.\nTo see the weight of the first polygon’s four neighbours type:\n\nrswm_q$weights[1]\n\n[[1]]\n[1] 0.2 0.2 0.2 0.2 0.2\n\n\nExplanation of above: Each neighbor is assigned a 0.2 of the total weight. This means that when R computes the average neighboring income values, each neighbor's income will be multiplied by 0.2 before being tallied.\nYX’s practise (There are two variables in rswm_q, namely $neighbours and $ weight)\n\nstr(rswm_q)\n\nList of 3\n $ style     : chr \"W\"\n $ neighbours:List of 88\n  ..$ : int [1:5] 2 3 4 57 85\n  ..$ : int [1:5] 1 57 58 78 85\n  ..$ : int [1:4] 1 4 5 85\n  ..$ : int [1:4] 1 3 5 6\n  ..$ : int [1:4] 3 4 6 85\n  ..$ : int [1:5] 4 5 69 75 85\n  ..$ : int [1:4] 67 71 74 84\n  ..$ : int [1:7] 9 46 47 56 78 80 86\n  ..$ : int [1:6] 8 66 68 78 84 86\n  ..$ : int [1:8] 16 17 19 20 22 70 72 73\n  ..$ : int [1:3] 14 17 72\n  ..$ : int [1:5] 13 60 61 63 83\n  ..$ : int [1:4] 12 15 60 83\n  ..$ : int [1:3] 11 15 17\n  ..$ : int [1:4] 13 14 17 83\n  ..$ : int [1:5] 10 17 22 72 83\n  ..$ : int [1:7] 10 11 14 15 16 72 83\n  ..$ : int [1:5] 20 22 23 77 83\n  ..$ : int [1:6] 10 20 21 73 74 86\n  ..$ : int [1:7] 10 18 19 21 22 23 82\n  ..$ : int [1:5] 19 20 35 82 86\n  ..$ : int [1:5] 10 16 18 20 83\n  ..$ : int [1:7] 18 20 38 41 77 79 82\n  ..$ : int [1:5] 25 28 31 32 54\n  ..$ : int [1:5] 24 28 31 33 81\n  ..$ : int [1:4] 27 33 42 81\n  ..$ : int [1:3] 26 29 42\n  ..$ : int [1:5] 24 25 33 49 54\n  ..$ : int [1:3] 27 37 42\n  ..$ : int 33\n  ..$ : int [1:8] 24 25 32 36 39 40 56 81\n  ..$ : int [1:8] 24 31 50 54 55 56 75 85\n  ..$ : int [1:5] 25 26 28 30 81\n  ..$ : int [1:3] 36 45 80\n  ..$ : int [1:6] 21 41 47 80 82 86\n  ..$ : int [1:6] 31 34 40 45 56 80\n  ..$ : int [1:4] 29 42 43 44\n  ..$ : int [1:4] 23 44 77 79\n  ..$ : int [1:5] 31 40 42 43 81\n  ..$ : int [1:6] 31 36 39 43 45 79\n  ..$ : int [1:6] 23 35 45 79 80 82\n  ..$ : int [1:7] 26 27 29 37 39 43 81\n  ..$ : int [1:6] 37 39 40 42 44 79\n  ..$ : int [1:4] 37 38 43 79\n  ..$ : int [1:6] 34 36 40 41 79 80\n  ..$ : int [1:3] 8 47 86\n  ..$ : int [1:5] 8 35 46 80 86\n  ..$ : int [1:5] 50 51 52 53 55\n  ..$ : int [1:4] 28 51 52 54\n  ..$ : int [1:5] 32 48 52 54 55\n  ..$ : int [1:3] 48 49 52\n  ..$ : int [1:5] 48 49 50 51 54\n  ..$ : int [1:3] 48 55 75\n  ..$ : int [1:6] 24 28 32 49 50 52\n  ..$ : int [1:5] 32 48 50 53 75\n  ..$ : int [1:7] 8 31 32 36 78 80 85\n  ..$ : int [1:6] 1 2 58 64 76 85\n  ..$ : int [1:5] 2 57 68 76 78\n  ..$ : int [1:4] 60 61 87 88\n  ..$ : int [1:4] 12 13 59 61\n  ..$ : int [1:7] 12 59 60 62 63 77 87\n  ..$ : int [1:3] 61 77 87\n  ..$ : int [1:4] 12 61 77 83\n  ..$ : int [1:2] 57 76\n  ..$ : int 76\n  ..$ : int [1:5] 9 67 68 76 84\n  ..$ : int [1:4] 7 66 76 84\n  ..$ : int [1:5] 9 58 66 76 78\n  ..$ : int [1:3] 6 75 85\n  ..$ : int [1:3] 10 72 73\n  ..$ : int [1:3] 7 73 74\n  ..$ : int [1:5] 10 11 16 17 70\n  ..$ : int [1:5] 10 19 70 71 74\n  ..$ : int [1:6] 7 19 71 73 84 86\n  ..$ : int [1:6] 6 32 53 55 69 85\n  ..$ : int [1:7] 57 58 64 65 66 67 68\n  ..$ : int [1:7] 18 23 38 61 62 63 83\n  ..$ : int [1:7] 2 8 9 56 58 68 85\n  ..$ : int [1:7] 23 38 40 41 43 44 45\n  ..$ : int [1:8] 8 34 35 36 41 45 47 56\n  ..$ : int [1:6] 25 26 31 33 39 42\n  ..$ : int [1:5] 20 21 23 35 41\n  ..$ : int [1:9] 12 13 15 16 17 18 22 63 77\n  ..$ : int [1:6] 7 9 66 67 74 86\n  ..$ : int [1:11] 1 2 3 5 6 32 56 57 69 75 ...\n  ..$ : int [1:9] 8 9 19 21 35 46 47 74 84\n  ..$ : int [1:4] 59 61 62 88\n  ..$ : int [1:2] 59 87\n  ..- attr(*, \"class\")= chr \"nb\"\n  ..- attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n  ..- attr(*, \"call\")= language poly2nb(pl = hunan, queen = TRUE)\n  ..- attr(*, \"type\")= chr \"queen\"\n  ..- attr(*, \"sym\")= logi TRUE\n $ weights   :List of 88\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:8] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num 1\n  ..$ : num [1:8] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n  ..$ : num [1:8] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:2] 0.5 0.5\n  ..$ : num 1\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:8] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:9] 0.111 0.111 0.111 0.111 0.111 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:11] 0.0909 0.0909 0.0909 0.0909 0.0909 ...\n  ..$ : num [1:9] 0.111 0.111 0.111 0.111 0.111 ...\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:2] 0.5 0.5\n  ..- attr(*, \"mode\")= chr \"binary\"\n  ..- attr(*, \"W\")= logi TRUE\n  ..- attr(*, \"comp\")=List of 1\n  .. ..$ d: num [1:88] 5 5 4 4 4 5 4 7 6 8 ...\n - attr(*, \"class\")= chr [1:2] \"listw\" \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language nb2listw(neighbours = wm_q, style = \"W\", zero.policy = TRUE)\n\n\nUsing the same method, we can also derive a row standardised distance weight matrix (closer neighbours have higher weightings) by using the code chunk below.\n*notice that the spatial weight matrix using inverse weight method is used here and with style = ‘B’\n\nrswm_ids <- nb2listw(wm_q, glist=ids, style='B', zero.policy=TRUE)\nrswm_ids # class \"listw\" weights list \"nb\"  \n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn       S0        S1     S2\nB 88 7744 8.786867 0.3776535 3.8137\n\n\n\nrswm_ids$weights[1]\n\n[[1]]\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n\n\n\nsummary(unlist(rswm_ids$weights))\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n0.008218 0.015088 0.018739 0.019614 0.022823 0.040338"
  },
  {
    "objectID": "Hands-on_Ex03/Hands-on_ex03.html#application-of-spatial-weight-matrix",
    "href": "Hands-on_Ex03/Hands-on_ex03.html#application-of-spatial-weight-matrix",
    "title": "Hands-on_Ex03",
    "section": "3.8 Application of Spatial Weight Matrix",
    "text": "3.8 Application of Spatial Weight Matrix\nIn this section, you will learn how to create four different spatial lagged variables, they are:\n\nspatial lag with row-standardized weights,\nspatial lag as a sum of neighbouring values,\nspatial window average, and spatial window sum.\n\n\n3.8.1 Spatial lag with row-standardized weights\n\ncompute the average neighbour GDPCC values for each polygon\ncommonly called spatially lagged values\nIn the code below, use spatial weight matrix (equal weightage of 0.2 for poly1 etc.. ) by 0.2 * 20981 + 0.2 * 34592 + 0.2 * 24473 + 0.2 * 21311 + 0.2 * 22879 = 24847.20 for poly1 “Anxiang”\n22724.80 is the average GDPPC for poly2 based on equal weightage (0.2) of all its five neighbours . 24143.25 for poly3 based on equal weightage (0.25) based on four neighbours.\n\n\nGDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)\nGDPPC.lag # numeric class\n\n [1] 24847.20 22724.80 24143.25 27737.50 27270.25 21248.80 43747.00 33582.71\n [9] 45651.17 32027.62 32671.00 20810.00 25711.50 30672.33 33457.75 31689.20\n[17] 20269.00 23901.60 25126.17 21903.43 22718.60 25918.80 20307.00 20023.80\n[25] 16576.80 18667.00 14394.67 19848.80 15516.33 20518.00 17572.00 15200.12\n[33] 18413.80 14419.33 24094.50 22019.83 12923.50 14756.00 13869.80 12296.67\n[41] 15775.17 14382.86 11566.33 13199.50 23412.00 39541.00 36186.60 16559.60\n[49] 20772.50 19471.20 19827.33 15466.80 12925.67 18577.17 14943.00 24913.00\n[57] 25093.00 24428.80 17003.00 21143.75 20435.00 17131.33 24569.75 23835.50\n[65] 26360.00 47383.40 55157.75 37058.00 21546.67 23348.67 42323.67 28938.60\n[73] 25880.80 47345.67 18711.33 29087.29 20748.29 35933.71 15439.71 29787.50\n[81] 18145.00 21617.00 29203.89 41363.67 22259.09 44939.56 16902.00 16930.00\n\n\nRecalled in the previous section, we retrieved the GDPPC of these five countries (neighbours of poly1 using queen method) by using the code chunk below.\n\nnb1 <- wm_q[[1]]\nnb1 <- hunan$GDPPC[nb1]\nnb1\n\n[1] 20981 34592 24473 21311 22879\n\n\nWe can append the spatially lag GDPPC values onto hunan sf data frame by using the code chunk below.\n\nlag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC)) # two lists: county and ave GDPC appended\nlag.res <- as.data.frame(lag.list) # class dataframe of Anxiang - 24847.20 , Hanshou 22724.80 etc\ncolnames(lag.res) <- c('NAME_3', 'lag GDPPC') # rename the col of lag.res\nhunan <- left_join(hunan,lag.res)\n\nJoining, by = \"NAME_3\"\n\n\nThe average neighboring income values for each county is now stored as a new column ‘lag GDPPC’ in hunan sf\n\nhead(hunan)\n\nSimple feature collection with 6 features and 36 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 110.4922 ymin: 28.61762 xmax: 112.3013 ymax: 30.12812\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3 Shape_Leng Shape_Area  County    City\n1 Changde 21098 Anxiang      County   1.869074 0.10056190 Anxiang Changde\n2 Changde 21100 Hanshou      County   2.360691 0.19978745 Hanshou Changde\n3 Changde 21101  Jinshi County City   1.425620 0.05302413  Jinshi Changde\n4 Changde 21102      Li      County   3.474325 0.18908121      Li Changde\n5 Changde 21103   Linli      County   2.289506 0.11450357   Linli Changde\n6 Changde 21104  Shimen      County   4.171918 0.37194707  Shimen Changde\n  avg_wage deposite     FAI Gov_Rev Gov_Exp     GDP GDPPC     GIO   Loan  NIPCR\n1    31935   5517.2  3541.0  243.64  1779.5 12482.0 23667  5108.9 2806.9 7693.7\n2    32265   7979.0  8665.0  386.13  2062.4 15788.0 20981 13491.0 4550.0 8269.9\n3    28692   4581.7  4777.0  373.31  1148.4  8706.9 34592 10935.0 2242.0 8169.9\n4    32541  13487.0 16066.0  709.61  2459.5 20322.0 24473 18402.0 6748.0 8377.0\n5    32667    564.1  7781.2  336.86  1538.7 10355.0 25554  8214.0  358.0 8143.1\n6    33261   8334.4 10531.0  548.33  2178.8 16293.0 27137 17795.0 6026.5 6156.0\n   Bed    Emp  EmpR EmpRT Pri_Stu Sec_Stu Household Household_R NOIP Pop_R\n1 1931 336.39 270.5 205.9  19.584  17.819     148.1       135.4   53 346.0\n2 2560 456.78 388.8 246.7  42.097  33.029     240.2       208.7   95 553.2\n3  848 122.78  82.1  61.7   8.723   7.592      81.9        43.7   77  92.4\n4 2038 513.44 426.8 227.1  38.975  33.938     268.5       256.0   96 539.7\n5 1440 307.36 272.2 100.8  23.286  18.943     129.1       157.2   99 246.6\n6 2502 392.05 329.6 193.8  29.245  26.104     190.6       184.7  122 399.2\n    RSCG Pop_T    Agri Service Disp_Inc      RORP    ROREmp lag GDPPC\n1 3957.9 528.3 4524.41   14100    16610 0.6549309 0.8041262  24847.20\n2 4460.5 804.6 6545.35   17727    18925 0.6875466 0.8511756  22724.80\n3 3683.0 251.8 2562.46    7525    19498 0.3669579 0.6686757  24143.25\n4 7110.2 832.5 7562.34   53160    18985 0.6482883 0.8312558  27737.50\n5 3604.9 409.3 3583.91    7031    18604 0.6024921 0.8856065  27270.25\n6 6490.7 600.5 5266.51    6981    19275 0.6647794 0.8407091  21248.80\n                        geometry\n1 POLYGON ((112.0625 29.75523...\n2 POLYGON ((112.2288 29.11684...\n3 POLYGON ((111.8927 29.6013,...\n4 POLYGON ((111.3731 29.94649...\n5 POLYGON ((111.6324 29.76288...\n6 POLYGON ((110.8825 30.11675...\n\n\nNext, we will plot both the GDPPC and spatial lag GDPPC for comparison using the code chunk below.\n\ngdppc <- qtm (hunan, 'GDPPC')\nlag_gdppc <- qtm(hunan, 'lag GDPPC')\ntmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)\n\n\n\n\n\n\n3.8.2 Spatial lag as a sum of neighboring values\n\n\n3.8.3 Spatial window average\n\n\n3.8.4 Spatial window sum"
  },
  {
    "objectID": "Hands-on_Ex03/Hands-on_ex03.html#references",
    "href": "Hands-on_Ex03/Hands-on_ex03.html#references",
    "title": "Hands-on_Ex03",
    "section": "3.9 References",
    "text": "3.9 References\n\nCreating Neighbours using sf objects"
  }
]