[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "",
    "text": "In this hands-on exercise, I learn how to import and wrangle Geospatial data using appropriate R packages."
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#getting-started",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#getting-started",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Getting Started",
    "text": "Getting Started\nThe code chunk below is installed to load sf and tidyverse packages into R environment.\n\n#pacman::p_load(sf,tidyverse)\nlibrary(sf)\n\nLinking to GEOS 3.9.3, GDAL 3.5.2, PROJ 8.2.1; sf_use_s2() is TRUE\n\nlibrary(tidyverse)\n\n── Attaching packages\n───────────────────────────────────────\ntidyverse 1.3.2 ──\n\n\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.8     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.1\n✔ readr   2.1.2     ✔ forcats 0.5.2\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\nlibrary(dplyr)"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#section-a-importing-geospatial-data",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#section-a-importing-geospatial-data",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Section A: Importing Geospatial Data",
    "text": "Section A: Importing Geospatial Data\nThe shapefile format can spatially describe vector features: (1) polygons, (2) polylines or (3) points.\n\nImporting polygon feature data\nThe st_read() function requires two input arguments ; dsn to define data path and layer to define the shapefile name.\n\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\yixin-neo\\ISSS624\\Hands-on_Ex01\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\n\n\nImporting polyline feature data\n\ncyclingpath <- st_read(dsn=\"data/geospatial\", layer = \"CyclingPathGazette\")\n\nReading layer `CyclingPathGazette' from data source \n  `C:\\yixin-neo\\ISSS624\\Hands-on_Ex01\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 2248 features and 2 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 11854.32 ymin: 28347.98 xmax: 42626.09 ymax: 48948.15\nProjected CRS: SVY21\n\n\n\nclass(cyclingpath)\n\n[1] \"sf\"         \"data.frame\"\n\n\n\n\nImporting GIS data in kml format\n\npreschool <- st_read(\"data/geospatial/pre-schools-location-kml.kml\")\n\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `C:\\yixin-neo\\ISSS624\\Hands-on_Ex01\\data\\geospatial\\pre-schools-location-kml.kml' \n  using driver `KML'\nSimple feature collection with 1925 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.247759 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n\n\nClick here or here for explanation on coordinate systems!\nDifferent projection can help to achieve:\n\nminimize distortion in shape\nminimize distortion in distance\nminimize distortion in area\nminimize distortion in direction.\n\nGoogle maps uses Mercator projection system. It is chosen as it preserves direction and angles. It is useful for navigation (google map) . It is originally created for sea navigation in older days. The cons are that this projection does not preserve area and shape.\n“Projected coordinate system flattens the globe whereas the geodesic one is still a spherical/ellipsoid globe” (Zhu, 2022)"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#section-b-checking-the-content-of-a-simple-feature-data-frame",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#section-b-checking-the-content-of-a-simple-feature-data-frame",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Section B: Checking the content of a Simple Feature Data Frame",
    "text": "Section B: Checking the content of a Simple Feature Data Frame\n\nWorking with st_geometry()\n\nst_geometry(mpsz)\n\nGeometry set for 323 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 5 geometries:\n\n\nMULTIPOLYGON (((31495.56 30140.01, 31980.96 296...\n\n\nMULTIPOLYGON (((29092.28 30021.89, 29119.64 300...\n\n\nMULTIPOLYGON (((29932.33 29879.12, 29947.32 298...\n\n\nMULTIPOLYGON (((27131.28 30059.73, 27088.33 297...\n\n\nMULTIPOLYGON (((26451.03 30396.46, 26440.47 303...\n\n\nBasic information like type of geometry, geographic extent of the features and the coordinate system (syv21) of the data is displayed.\n\n\nWorking with glimpse() of dplyr\nShows the data type of each field.\n\nglimpse(mpsz)\n\nRows: 323\nColumns: 16\n$ OBJECTID   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ SUBZONE_NO <int> 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1, 5, 1, 1, 3, 2, 2, …\n$ SUBZONE_N  <chr> \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL…\n$ SUBZONE_C  <chr> \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\",…\n$ CA_IND     <chr> \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",…\n$ PLN_AREA_N <chr> \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",…\n$ PLN_AREA_C <chr> \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM\", \"SR\", \"QT\", \"QT\",…\n$ REGION_N   <chr> \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT…\n$ REGION_C   <chr> \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\",…\n$ INC_CRC    <chr> \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",…\n$ FMEL_UPD_D <date> 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05…\n$ X_ADDR     <dbl> 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82,…\n$ Y_ADDR     <dbl> 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38,…\n$ SHAPE_Leng <dbl> 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913,…\n$ SHAPE_Area <dbl> 1630379.27, 559816.25, 160807.50, 595428.89, 387429.44, 103…\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (…\n\n\n\n\nWorking with head()\nReveals complete information of a feature object; show first 5 rows.\n\nhead(mpsz, n =5)\n\nSimple feature collection with 5 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 25867.68 ymin: 28369.47 xmax: 32362.39 ymax: 30435.54\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1        1          1   MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2        2          1   PEARL'S HILL    OTSZ01      Y          OUTRAM\n3        3          3      BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4        4          8 HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5        5          3        REDHILL    BMSZ03      N     BUKIT MERAH\n  PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1         MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2         OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3         SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4         BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5         BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n    Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1 29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2 29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3 29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4 29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5 30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30..."
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#section-c-plotting-the-geospatial-data",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#section-c-plotting-the-geospatial-data",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Section C: Plotting the Geospatial Data",
    "text": "Section C: Plotting the Geospatial Data\nThe amazing part about Choropleth map is that it is able to plot both numerical and categorical data!\n\nplot(mpsz)\n\nWarning: plotting the first 9 out of 15 attributes; use max.plot = 15 to plot\nall\n\n\n\n\n\nTo plot only the geometry:\n\nplot(st_geometry(mpsz))\n\n\n\n\nAlternatively, to plot the sf object by using only a specific attribute PLN_AREA_N:\n\nplot(mpsz[\"PLN_AREA_N\"])\n\n\n\n\n*Note: plot() is mean for plotting the Geospatial object for quick look. For high cartographic quality plot, other R package such as tmap should be used."
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#section-d-working-with-projection",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#section-d-working-with-projection",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Section D: Working with Projection",
    "text": "Section D: Working with Projection\nTo perform Geoprocessing using two Geospatial data, both sets of Geospatial data need to be projected using similar coordinate system. In this section, a simple feature data frame will be projected from one coordinate system to another coordinate system. This process is called projection transformation.\n\nAssigning EPSG code to a simple feature data frame\ncrs - coordinate reference system\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\nNote that the EPSG code for svy21 should be 3414, lets get it right.\n\nmpsz3414 <- st_set_crs(mpsz,3414)\n\nWarning: st_crs<- : replacing crs does not reproject data; use st_transform for\nthat\n\n\n\nst_crs(mpsz3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\n\n\nTransforming the projection of preschool from wgs84 to svy21\nWe transform original data in geographic coordinate system to projected coordinate system if the analysis requires the use of distance / area measurements.\n\nst_geometry(preschool)\n\nGeometry set for 1925 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.247759 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n\n\nPOINT Z (103.7009 1.338325 0)\n\n\nPOINT Z (103.8987 1.39044 0)\n\n\nPOINT Z (103.8068 1.438017 0)\n\n\nPOINT Z (103.7874 1.433436 0)\n\n\nPOINT Z (103.8886 1.395647 0)\n\n\npreschool simple feature data frame is in WSG84 coordinate system. To re-project preschool data frame to another coordinate system mathematically, use the st_transform() function of sf package.\n\npreschool3414 <- st_transform(preschool,crs=3414)\n\n\nst_geometry(preschool3414)\n\nGeometry set for 1925 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 11203.01 ymin: 25596.33 xmax: 45404.24 ymax: 49300.88\nz_range:       zmin: 0 zmax: 0\nProjected CRS: SVY21 / Singapore TM\nFirst 5 geometries:\n\n\nPOINT Z (13258.34 35611.04 0)\n\n\nPOINT Z (35272.09 41373.42 0)\n\n\nPOINT Z (25050.54 46634.14 0)\n\n\nPOINT Z (22892.48 46127.66 0)\n\n\nPOINT Z (34155.79 41949.13 0)"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#section-e-importing-and-converting-an-aspatial-data-and-save-it-as-tibble-data-frame-then-simple-feature-data-frame",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#section-e-importing-and-converting-an-aspatial-data-and-save-it-as-tibble-data-frame-then-simple-feature-data-frame",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Section E: Importing and converting an Aspatial Data and save it as tibble data frame, then simple feature data frame",
    "text": "Section E: Importing and converting an Aspatial Data and save it as tibble data frame, then simple feature data frame\n\nlibrary(readr)\nlistings <- read_csv(\"data/aspatial/listings.csv\")\n\nRows: 4161 Columns: 18\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr   (6): name, host_name, neighbourhood_group, neighbourhood, room_type, l...\ndbl  (11): id, host_id, latitude, longitude, price, minimum_nights, number_o...\ndate  (1): last_review\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nExamine whether data file has been imported correctly using list()\n\nlist(listings)\n\n[[1]]\n# A tibble: 4,161 × 18\n       id name     host_id host_…¹ neigh…² neigh…³ latit…⁴ longi…⁵ room_…⁶ price\n    <dbl> <chr>      <dbl> <chr>   <chr>   <chr>     <dbl>   <dbl> <chr>   <dbl>\n 1  50646 Pleasan…  227796 Sujatha Centra… Bukit …    1.33    104. Privat…    80\n 2  71609 Ensuite…  367042 Belinda East R… Tampin…    1.35    104. Privat…   145\n 3  71896 B&B  Ro…  367042 Belinda East R… Tampin…    1.35    104. Privat…    85\n 4  71903 Room 2-…  367042 Belinda East R… Tampin…    1.35    104. Privat…    85\n 5 275344 15 mins… 1439258 Kay     Centra… Bukit …    1.29    104. Privat…    49\n 6 289234 Booking…  367042 Belinda East R… Tampin…    1.34    104. Privat…   184\n 7 294281 5 mins … 1521514 Elizab… Centra… Newton     1.31    104. Privat…    79\n 8 324945 Cozy Bl… 1439258 Kay     Centra… Bukit …    1.29    104. Privat…    49\n 9 330089 Cozy Bl… 1439258 Kay     Centra… Bukit …    1.29    104. Privat…    55\n10 330095 10 mins… 1439258 Kay     Centra… Bukit …    1.29    104. Privat…    55\n# … with 4,151 more rows, 8 more variables: minimum_nights <dbl>,\n#   number_of_reviews <dbl>, last_review <date>, reviews_per_month <dbl>,\n#   calculated_host_listings_count <dbl>, availability_365 <dbl>,\n#   number_of_reviews_ltm <dbl>, license <chr>, and abbreviated variable names\n#   ¹​host_name, ²​neighbourhood_group, ³​neighbourhood, ⁴​latitude, ⁵​longitude,\n#   ⁶​room_type\n\n\n*note the latitude and longitude are in decimal degree format. It suggests the data in in WSG84 Geographic Coordinate System.\n\nCreating a simple feature data frame from an aspatial data frame\nTo convert listings data frame into a simple feature data frame, use the st_as_sf() of the sf packages.\n\nlibrary(dplyr)\nlibrary(sf)\nlibrary(tidyverse)\nlistings_sf <- st_as_sf(listings, coords=c(\"longitude\",\"latitude\"),crs=4326) %>% \n  st_transform(crs=3414)\n\n\ncoords argument requires you to provide the column name of the x-coordinates first then followed by the column name of the y-coordinates.\ncrs argument requires you to provide the coordinates system in epsg format. EPSG: 4326 is wgs84 Geographic Coordinate System and EPSG: 3414 is Singapore SVY21 Projected Coordinate System. You can search for other country’s epsg code by referring to epsg.io.\n%>% is used to nest st_transform() to transform the newly created simple feature data frame into svy21 projected coordinates system.\n\n\nglimpse(listings_sf)\n\nRows: 4,161\nColumns: 17\n$ id                             <dbl> 50646, 71609, 71896, 71903, 275344, 289…\n$ name                           <chr> \"Pleasant Room along Bukit Timah\", \"Ens…\n$ host_id                        <dbl> 227796, 367042, 367042, 367042, 1439258…\n$ host_name                      <chr> \"Sujatha\", \"Belinda\", \"Belinda\", \"Belin…\n$ neighbourhood_group            <chr> \"Central Region\", \"East Region\", \"East …\n$ neighbourhood                  <chr> \"Bukit Timah\", \"Tampines\", \"Tampines\", …\n$ room_type                      <chr> \"Private room\", \"Private room\", \"Privat…\n$ price                          <dbl> 80, 145, 85, 85, 49, 184, 79, 49, 55, 5…\n$ minimum_nights                 <dbl> 92, 92, 92, 92, 60, 92, 92, 60, 60, 60,…\n$ number_of_reviews              <dbl> 18, 20, 24, 47, 14, 12, 133, 17, 12, 3,…\n$ last_review                    <date> 2014-12-26, 2020-01-17, 2019-10-13, 20…\n$ reviews_per_month              <dbl> 0.18, 0.15, 0.18, 0.34, 0.11, 0.10, 1.0…\n$ calculated_host_listings_count <dbl> 1, 6, 6, 6, 44, 6, 7, 44, 44, 44, 6, 7,…\n$ availability_365               <dbl> 365, 340, 265, 365, 296, 285, 365, 181,…\n$ number_of_reviews_ltm          <dbl> 0, 0, 0, 0, 1, 0, 0, 3, 2, 0, 1, 0, 0, …\n$ license                        <chr> NA, NA, NA, NA, \"S0399\", NA, NA, \"S0399…\n$ geometry                       <POINT [m]> POINT (22646.02 35167.9), POINT (…\n\n\nA new column called geometry has been added into the data frame. On the other hand, the longitude and latitude columns have been dropped from the data frame.\n\nplot(listings_sf)\n\nWarning: plotting the first 9 out of 16 attributes; use max.plot = 16 to plot\nall"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#section-f-geoprocessing-with-sf-package",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#section-f-geoprocessing-with-sf-package",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Section F: Geoprocessing with sf package",
    "text": "Section F: Geoprocessing with sf package\n\nBuffering\nThe scenario:\nThe authority is planning to upgrade the exiting cycling path. To do so, they need to acquire 5 metres of reserved land on the both sides of the current cycling path. You are tasked to determine the extend of the land need to be acquired and their total area.\nSolution:\n\nst_buffer()\ncalculate buffer area using st_area() & create new column in sf data frame\nsum AREA column\n\n\nbuffer_cycling <- st_buffer(cyclingpath, dist= 5, nQuadSegs=30)\n\n\nplot(st_geometry(cyclingpath))\n\n\n\n\n\nplot(st_buffer(cyclingpath, dist= 5, nQuadSegs=30))\n\n\n\n\n\n# add a new and calculate new column AREA\nbuffer_cycling$AREA <- st_area(buffer_cycling)\n\n\n# Sum the column AREA\nsum(buffer_cycling$AREA)\n\n1556978 [m^2]\n\n\n\nclass(buffer_cycling)\n\n[1] \"sf\"         \"data.frame\"\n\n\n\nUnderstanding st_buffer() <- page 29\n\nl1 = st_as_sfc(\"LINESTRING(0 0,1 5,4 5,5 2,8 2,9 4,4 6.5)\")\nop = par(mfrow=c(2,3))\nplot(st_buffer(l1, dist = 1, endCapStyle=\"ROUND\"), reset = FALSE, main = \"endCapStyle: ROUND\")\nplot(l1,col='blue',add=TRUE)\nplot(st_buffer(l1, dist = 1, endCapStyle=\"FLAT\"), reset = FALSE, main = \"endCapStyle: FLAT\")\nplot(l1,col='blue',add=TRUE)\nplot(st_buffer(l1, dist = 1, endCapStyle=\"SQUARE\"), reset = FALSE, main = \"endCapStyle: SQUARE\")\nplot(l1,col='blue',add=TRUE)\nplot(st_buffer(l1, dist = 1, nQuadSegs=1), reset = FALSE, main = \"nQuadSegs: 1\")\nplot(l1,col='blue',add=TRUE)\nplot(st_buffer(l1, dist = 1, nQuadSegs=2), reset = FALSE, main = \"nQuadSegs: 2\")\nplot(l1,col='blue',add=TRUE)\nplot(st_buffer(l1, dist = 1, nQuadSegs= 5), reset = FALSE, main = \"nQuadSegs: 5\")\nplot(l1,col='blue',add=TRUE)\n\n\n\n\n\n\nHow to create simple feature (sf) object?\nhttps://mgimond.github.io/Spatial/anatomy-of-simple-feature-objects.html\n\n\n\nPoint-in-polygon count\nThe scenario:\nA pre-school service group want to find out the numbers of pre-schools in each Planning Subzone.\nSolution:\n\nst_intersects() The ST_Intersects() function returns t (TRUE) if the intersection of two geometries does not result in an empty set; otherwise, returns f (FALSE).\n*For intersection on pairs of simple feature geometries (two polygons), use the function st_intersection instead of st_intersects\nlengths() of base R\nGet or set the length of vectors (including lists) and factors, and of any other R object for which a method has been defined.\ntop_n() of dplyr package\n\nCode below shows the points lying in the polygons\n\n#mpsz3414 is polygon (323 entries) but preschool3414 is points (1925 entries)\ntest1 <- st_intersects(mpsz3414, preschool3414)\ntest1\n\nSparse geometry binary predicate list of length 323, where the\npredicate was `intersects'\nfirst 10 elements:\n 1: (empty)\n 2: 703, 1361, 1409, 1663, 1722\n 3: (empty)\n 4: 290, 687, 1071, 1780\n 5: 465, 1901\n 6: 65, 84, 88, 111, 120, 474, 518, 912, 1853, 1899\n 7: 705, 1250, 1407, 1544\n 8: 106, 489\n 9: 325, 793, 1577, 1604, 1803, 1843\n 10: 1656\n\n\nCode below sums the number of points in each polygon\n\nlengths(st_intersects(mpsz3414, preschool3414))\n\n  [1]  0  5  0  4  2 10  4  2  6  1  6  2  0  1  6  0  0  0  0  2  0  1  0  4  3\n [26]  1  7  2  9  7  0  0  4  0  3 10  1  3  0  5  0  3  1  0  3  0  3  1  6  0\n [51]  1  2  1  2  3  0  1  1  2  0  3  0  2  5  1  0 11  3 10  1  2  6  1  4  0\n [76]  0  2 10  0  0  1  0  4  1  2  0  0  3  0  5  3  3  0  0  5  0  0  2  0  3\n[101]  7  0 13  0  3  2  2 23 15 18  0  0  5  5  0  7 20 15  6  1  1  0  0  0  5\n[126]  5  3  0  0  7  4  4  8  5  5  3 11  8  6  0  3  6  2  0  1 21  0  5 14 10\n[151]  7 23 10  4  0  6  4  0  2  7  5  0 30  3 15  0 27 12  3 14  8 10  4  5  9\n[176] 10 25  0  0 11 11 30  8  0  7 17  4  4 58  8  0  3 28  7  2  2  9  3 31 14\n[201]  0 11  0 11  4 10 18 14  0  6 22 16  8 17 13 18  6 18 12  6  0 11  4 10 10\n[226]  7  5  8  1  7 17  3  8  0  0 16 10  9 14  7  7 14  4  1  3 19  2 10  5  9\n[251]  3  0 15  9  4  0  0  7 13 26  0 13 19 14  0 12 21  0  2  0  0 30 17  0 19\n[276]  6  6  5  5  0  0 12 17 18  1  0 16  1  0 47 23  1  7  0  0  9  0  0  0 10\n[301]  0  0  1  0 17 16  8 10  2 13  0  0  0  1  0  0  2  0  0  3  0  0  0\n\n\nCombining all together and creating a new column in mpsz3414\n\n#mpsz3414 is polygon but preschool3414 is points\nmpsz3414$`Presch Count` <- lengths(st_intersects(mpsz3414, preschool3414))\n\n\nsummary(mpsz3414$`Presch Count`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00    0.00    3.00    5.96    9.00   58.00 \n\n\nFind subzone with most number of preschools in Singapore\n\ntop_n(mpsz3414, 1,`Presch Count`)\n\nSimple feature collection with 1 feature and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 39655.33 ymin: 35966 xmax: 42940.57 ymax: 38622.37\nProjected CRS: SVY21 / Singapore TM\n  OBJECTID SUBZONE_NO     SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n1      189          2 TAMPINES EAST    TMSZ02      N   TAMPINES         TM\n     REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR SHAPE_Leng\n1 EAST REGION       ER 21658EAAF84F4D8D 2014-12-05 41122.55 37392.39   10180.62\n  SHAPE_Area                       geometry Presch Count\n1    4339824 MULTIPOLYGON (((42196.76 38...           58\n\n\nNext task: Calculate the density of pre-school by planning subzone.\nSolution:\n\nuse st_area() of sf package to derive the area of each planning subzone\nNext, mutate() of dplyr package is used to compute the density\n\n\nmpsz3414$AREA <- mpsz3414 %>% st_area()\n\n\nmpsz3414 <- mpsz3414 %>% mutate(`PreSch Density` = `Presch Count`/AREA *100000)\n\n\ntop_n(mpsz3414, 5,`PreSch Density`)\n\nSimple feature collection with 5 features and 18 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 25594.22 ymin: 28623.75 xmax: 32860.5 ymax: 48182.13\nProjected CRS: SVY21 / Singapore TM\n  OBJECTID SUBZONE_NO         SUBZONE_N SUBZONE_C CA_IND    PLN_AREA_N\n1       27          8             CECIL    DTSZ08      Y DOWNTOWN CORE\n2       37          4           PHILLIP    DTSZ04      Y DOWNTOWN CORE\n3      253          3   SERANGOON NORTH    SGSZ03      N     SERANGOON\n4      278          3     MANDAI ESTATE    MDSZ03      N        MANDAI\n5      291          3 SEMBAWANG CENTRAL    SBSZ03      N     SEMBAWANG\n  PLN_AREA_C          REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1         DT    CENTRAL REGION       CR 65AA82AF6F4D925D 2014-12-05 29730.20\n2         DT    CENTRAL REGION       CR 615D4EDDEF809F8E 2014-12-05 29706.72\n3         SG NORTH-EAST REGION      NER C685042EC58E5C55 2014-12-05 32458.80\n4         MD      NORTH REGION       NR F6266F7368DBB9AB 2014-12-05 27082.70\n5         SB      NORTH REGION       NR 772A64AB9A93FC3A 2014-12-05 26268.73\n    Y_ADDR SHAPE_Leng SHAPE_Area                       geometry Presch Count\n1 29011.33  2116.0947  196619.86 MULTIPOLYGON (((29808.18 28...            7\n2 29744.91   871.5549   39437.94 MULTIPOLYGON (((29814.11 29...            1\n3 39597.64  3610.7324  684704.30 MULTIPOLYGON (((32860.5 397...           15\n4 45367.46  1633.7084  143137.94 MULTIPOLYGON (((27119.56 45...            5\n5 47558.08  3955.1176  962437.40 MULTIPOLYGON (((26311.14 46...           23\n             AREA   PreSch Density\n1 196619.86 [m^2] 3.560169 [1/m^2]\n2  39437.94 [m^2] 2.535630 [1/m^2]\n3 684704.30 [m^2] 2.190727 [1/m^2]\n4 143137.94 [m^2] 3.493134 [1/m^2]\n5 962437.40 [m^2] 2.389766 [1/m^2]\n\n\n\nplot(mpsz3414[\"PreSch Density\"])"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#section-g-exploratory-data-analysis-eda",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#section-g-exploratory-data-analysis-eda",
    "title": "Hands-on Exercise 1: Geospatial Data Wrangling with R",
    "section": "Section G: Exploratory Data Analysis (EDA)",
    "text": "Section G: Exploratory Data Analysis (EDA)\nUsing ggplot2 functions to create functional and yet truthful statistical graphs for EDA purposes.\n\nhist(mpsz3414$`PreSch Density` ,main = \"Histogram of PreSch Density in Planning subzones\", xlab = \"Density\")\n\n\n\n\n\nggplot(data=mpsz3414,\n       aes(x=as.numeric(`PreSch Density`))) + \n  geom_histogram(bins=20,\n                 color='black',\n                 fill =\"light blue\") +\n  labs(title= 'Are Pre-schools evenly distributed in Singapore?',\n       subtitle = 'There are many planning subzones with a single pre-school, on the other hand, \\nthere are two planning subzones with at least 20 pre-schools',\n       x='Pre-School Density (per km sq)',\n       y= 'Frequency')\n\n\n\n\n\nggplot(data=mpsz3414,\n       aes(x=as.numeric(`PreSch Density`), y= as.numeric(`Presch Count`))) + \n  geom_point(color='blue') +\n  labs(title= 'Scatterplot of Pre-school Count against Density',\n       x='Pre-school Density (per km sq)',\n       y= 'Pre-School Count')"
  },
  {
    "objectID": "Hands-on_Ex02/Hands-on_Ex02.html",
    "href": "Hands-on_Ex02/Hands-on_Ex02.html",
    "title": "Hands-on_Ex02",
    "section": "",
    "text": "In this hands-on exercise, I learn how to plot functional and truthful choropleth maps by using r packages called tmap package.\nBeside tmap package, four other R packages will be used. They are:\n\nreadr for importing delimited text file,\ntidyr for tidying data,\ndplyr for wrangling data and\nsf for handling geospatial data.\n\n\n#pacman::p_load(sf,tmap, tidyverse)\nlibrary(sf)\n\nLinking to GEOS 3.9.3, GDAL 3.5.2, PROJ 8.2.1; sf_use_s2() is TRUE\n\nlibrary(tidyverse)\n\n── Attaching packages\n───────────────────────────────────────\ntidyverse 1.3.2 ──\n\n\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.8     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.1\n✔ readr   2.1.2     ✔ forcats 0.5.2\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\nlibrary(tmap)"
  },
  {
    "objectID": "Hands-on_Ex02/Hands-on_Ex02.html#import-geospatial-data-into-r",
    "href": "Hands-on_Ex02/Hands-on_Ex02.html#import-geospatial-data-into-r",
    "title": "Hands-on_Ex02",
    "section": "2.3.2 Import Geospatial Data into R",
    "text": "2.3.2 Import Geospatial Data into R\n\nmpsz <- st_read(dsn=\"data/geospatial\", layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\yixin-neo\\ISSS624\\Hands-on_Ex02\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\n\nmpsz\n\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 10 features:\n   OBJECTID SUBZONE_NO       SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1         1          1    MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2         2          1    PEARL'S HILL    OTSZ01      Y          OUTRAM\n3         3          3       BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4         4          8  HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5         5          3         REDHILL    BMSZ03      N     BUKIT MERAH\n6         6          7  ALEXANDRA HILL    BMSZ07      N     BUKIT MERAH\n7         7          9   BUKIT HO SWEE    BMSZ09      N     BUKIT MERAH\n8         8          2     CLARKE QUAY    SRSZ02      Y SINGAPORE RIVER\n9         9         13 PASIR PANJANG 1    QTSZ13      N      QUEENSTOWN\n10       10          7       QUEENSWAY    QTSZ07      N      QUEENSTOWN\n   PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1          MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2          OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3          SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4          BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5          BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n6          BM CENTRAL REGION       CR 9D286521EF5E3B59 2014-12-05 25358.82\n7          BM CENTRAL REGION       CR 7839A8577144EFE2 2014-12-05 27680.06\n8          SR CENTRAL REGION       CR 48661DC0FBA09F7A 2014-12-05 29253.21\n9          QT CENTRAL REGION       CR 1F721290C421BFAB 2014-12-05 22077.34\n10         QT CENTRAL REGION       CR 3580D2AFFBEE914C 2014-12-05 24168.31\n     Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1  29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2  29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3  29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4  29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5  30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n6  29991.38   4428.913  1030378.8 MULTIPOLYGON (((25899.7 297...\n7  30230.86   3275.312   551732.0 MULTIPOLYGON (((27746.95 30...\n8  30222.86   2208.619   290184.7 MULTIPOLYGON (((29351.26 29...\n9  29893.78   6571.323  1084792.3 MULTIPOLYGON (((20996.49 30...\n10 30104.18   3454.239   631644.3 MULTIPOLYGON (((24472.11 29..."
  },
  {
    "objectID": "Hands-on_Ex02/Hands-on_Ex02.html#import-attribute-data-into-r",
    "href": "Hands-on_Ex02/Hands-on_Ex02.html#import-attribute-data-into-r",
    "title": "Hands-on_Ex02",
    "section": "2.3.3 Import attribute data into R",
    "text": "2.3.3 Import attribute data into R\n\npopdata <- read_csv(\"data/aspatial/respopagesextod2011to2020.csv\")\n\nRows: 984656 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): PA, SZ, AG, Sex, TOD\ndbl (2): Pop, Time\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\npopdata %>% head()\n\n# A tibble: 6 × 7\n  PA         SZ                     AG     Sex   TOD                   Pop  Time\n  <chr>      <chr>                  <chr>  <chr> <chr>               <dbl> <dbl>\n1 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HDB 1- and 2-Room …     0  2011\n2 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HDB 3-Room Flats       10  2011\n3 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HDB 4-Room Flats       30  2011\n4 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HDB 5-Room and Exe…    50  2011\n5 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HUDC Flats (exclud…     0  2011\n6 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males Landed Properties       0  2011"
  },
  {
    "objectID": "Hands-on_Ex02/Hands-on_Ex02.html#data-preparation",
    "href": "Hands-on_Ex02/Hands-on_Ex02.html#data-preparation",
    "title": "Hands-on_Ex02",
    "section": "2.3.4 Data preparation",
    "text": "2.3.4 Data preparation\nPrepare a data table with year 2020 values. The data table should include the variables PA, SZ, YOUNG, ECONOMY ACTIVE, AGED, TOTAL, DEPENDENCY.\n\nYOUNG: age group 0 to 4 until age groyup 20 to 24,\nECONOMY ACTIVE: age group 25-29 until age group 60-64,\nAGED: age group 65 and above,\nTOTAL: all age group, and\nDEPENDENCY: the ratio between young and aged against economy active group\n\n\n\n\n\n2.3.4.1 Data Wrangling\n\npivot_wider() (rows to column headers) of tidyr package, and\nmutate() (create new cal col), filter() (subset rows), group_by() and select() (select cols) of dplyr package\n\n\npopdata2020 <- popdata %>% \n  filter(Time == 2020) %>% \n  group_by(PA,SZ,AG) %>% \n  summarise(POP = sum(Pop)) %>% \n  ungroup() %>% \n  pivot_wider(names_from = AG,values_from = POP) %>% \n  mutate(YOUNG = rowSums(.[3:6])\n         +rowSums(.[12])) %>% \n  mutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+rowSums(.[13:15])) %>%\n  mutate(AGED = rowSums(.[16:21])) %>%\n  mutate(TOTAL = rowSums(.[3:21])) %>% \n  mutate(DEPENDENCY = (YOUNG + AGED)/`ECONOMY ACTIVE`) %>% \n  select(PA,SZ,YOUNG,`ECONOMY ACTIVE`, AGED, TOTAL, DEPENDENCY)\n\n`summarise()` has grouped output by 'PA', 'SZ'. You can override using the\n`.groups` argument.\n\npopdata2020 \n\n# A tibble: 332 × 7\n   PA         SZ                     YOUNG `ECONOMY ACTIVE`  AGED TOTAL DEPEND…¹\n   <chr>      <chr>                  <dbl>            <dbl> <dbl> <dbl>    <dbl>\n 1 Ang Mo Kio Ang Mo Kio Town Centre  1290             2760   760  4810    0.743\n 2 Ang Mo Kio Cheng San               5640            16460  6050 28150    0.710\n 3 Ang Mo Kio Chong Boon              5100            15000  6470 26570    0.771\n 4 Ang Mo Kio Kebun Bahru             4620            13010  5120 22750    0.749\n 5 Ang Mo Kio Sembawang Hills         1880             3630  1310  6820    0.879\n 6 Ang Mo Kio Shangri-La              3330             9050  3610 15990    0.767\n 7 Ang Mo Kio Tagore                  1940             4480  1530  7950    0.775\n 8 Ang Mo Kio Townsville              4190            11950  5100 21240    0.777\n 9 Ang Mo Kio Yio Chu Kang               0                0     0     0  NaN    \n10 Ang Mo Kio Yio Chu Kang East       1110             2410   750  4270    0.772\n# … with 322 more rows, and abbreviated variable name ¹​DEPENDENCY\n\n\nRefer to this link for difference between group_by() - mutate() and group_by() - summarise()\nungroup() usually done after performing calculation in group()\n\npopdata20201 <- popdata %>% \n  filter(Time == 2020) %>% \n  group_by(PA,SZ,AG) %>% \n  summarise(POP = sum(Pop))\n\n`summarise()` has grouped output by 'PA', 'SZ'. You can override using the\n`.groups` argument.\n\npopdata20201\n\n# A tibble: 6,308 × 4\n# Groups:   PA, SZ [332]\n   PA         SZ                     AG         POP\n   <chr>      <chr>                  <chr>    <dbl>\n 1 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4     170\n 2 Ang Mo Kio Ang Mo Kio Town Centre 10_to_14   280\n 3 Ang Mo Kio Ang Mo Kio Town Centre 15_to_19   340\n 4 Ang Mo Kio Ang Mo Kio Town Centre 20_to_24   270\n 5 Ang Mo Kio Ang Mo Kio Town Centre 25_to_29   260\n 6 Ang Mo Kio Ang Mo Kio Town Centre 30_to_34   310\n 7 Ang Mo Kio Ang Mo Kio Town Centre 35_to_39   330\n 8 Ang Mo Kio Ang Mo Kio Town Centre 40_to_44   400\n 9 Ang Mo Kio Ang Mo Kio Town Centre 45_to_49   480\n10 Ang Mo Kio Ang Mo Kio Town Centre 5_to_9     230\n# … with 6,298 more rows\n\n\n\n\n2.3.4.2 Joining the attribute data and geospatial data\nConvert PA and SZ fields in popdata2020 into all uppercase using:\n\ntoupper() <- to upper case\nmutate.at()<- mutate multiple columns\nargument: .var <- list of columns generated by vars()\nargument: .funs <- a function fun, a quosure style lambda\n\n\npopdata2020 <- popdata2020 %>% \n  mutate_at(.var= vars(PA,SZ),\n            .funs = funs(toupper)) %>%\n  filter(`ECONOMY ACTIVE` >0)\n\nWarning: `funs()` was deprecated in dplyr 0.8.0.\nPlease use a list of either functions or lambdas: \n\n  # Simple named list: \n  list(mean = mean, median = median)\n\n  # Auto named with `tibble::lst()`: \n  tibble::lst(mean, median)\n\n  # Using lambdas\n  list(~ mean(., trim = .2), ~ median(., na.rm = TRUE))\nThis warning is displayed once every 8 hours.\nCall `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.\n\n\nNext, left_join() of dplyr is used to join the geographical data and attribute table using planning subzone name e.g. SUBZONE_N and SZ as the common identifier.\n\nmpsz_pop2020 <- left_join(mpsz, popdata2020,\n                          by = c(\"SUBZONE_N\" = \"SZ\"))\n\n\n#write_rds(mpsz_pop2020, \"data/rds/mpszpop2020.rds\")"
  },
  {
    "objectID": "Hands-on_Ex02/Hands-on_Ex02.html#choropleth-mapping-geospatial-data-using-tmap",
    "href": "Hands-on_Ex02/Hands-on_Ex02.html#choropleth-mapping-geospatial-data-using-tmap",
    "title": "Hands-on_Ex02",
    "section": "2.4 Choropleth Mapping Geospatial Data Using tmap",
    "text": "2.4 Choropleth Mapping Geospatial Data Using tmap\nTwo approaches can be used to prepare thematic map using tmap, they are:\n\nPlotting a thematic map quickly by using qtm() (Quick thematic plot)\nPlotting highly customisable thematic map by using tmap elements.\n\n\n2.4.1 Plotting a choropleth map quickly using qtm()\n\ntop_n(mpsz_pop2020, 1,`DEPENDENCY`)\n\nSimple feature collection with 1 feature and 21 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 42513.65 ymin: 38644.89 xmax: 44163.44 ymax: 41072.58\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO   SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n1      229          6 LOYANG WEST    PRSZ06      N  PASIR RIS         PR\n     REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR SHAPE_Leng\n1 EAST REGION       ER 05FD555397CBEE7A 2014-12-05 43294.83 39888.77   6203.002\n  SHAPE_Area        PA YOUNG ECONOMY ACTIVE AGED TOTAL DEPENDENCY\n1    2114789 PASIR RIS     0             10  190   200         19\n                        geometry\n1 MULTIPOLYGON (((43756.39 39...\n\n\n\ntmap_mode(\"plot\")\n\ntmap mode set to plotting\n\nqtm(mpsz_pop2020,\n    fill = \"DEPENDENCY\")\n\n\n\n\nThings to learn from the code chunk above:\n\ntmap_mode() with “plot” option is used to produce a static map. For interactive mode, “view” option should be used.\nfill argument is used to map the attribute (i.e. DEPENDENCY)\n\n\n\nCreating a Choropleth map by using tmap’s elements\ntm_shape() <- define input data and specify the shape object / spatial data object\ntm_fill() <- fills polygons (no border)\n\nstyle: method to process the color scale when col (data variable) is a numeric variable. To process numeric and categorical use “cat”\npalette : palettes names or vectors of colors. default is taken from tm_layout’s aes.paletttes argument. To reverse the colour scheme , add a “-” prefix.\n\ntm_borders() <- draws the borders of polygons (alpha is 0-1, transparency)\ntm_polygons() (= tm_fill() + tm_borders() )<- fills the polygon and draws the polygon borders\n*qtm = shape + polygon or * qtm = shape + fill + border\ntm_layout() <- specify map layout\n\naes.palette <- ‘seq’ (sequential palettes), ‘div’ (diverging palettes) , ‘cat’ (categorical palettes)\n\ntm_compass() <- create map compass\ntm_scale_bar() <- creates scale bar\ntm_grid() <- creates grid lines (alpha is 0-1, transparency of grid lines)\ntm_credits() <- create a text for credits\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Reds\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha =0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n2.4.2.1 Drawing a base map\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons()\n\n\n\n\n\n\n2.4.2.2 Drawing a choropleth map using tm_polygons()\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons('DEPENDENCY')\n\n\n\n\nThings to learn from tm_polygons():\n\nThe default interval binning used to draw the choropleth map is called “pretty”. A detailed discussion of the data classification methods supported by tmap will be provided in sub-section 4.3.\nThe default colour scheme used is YlOrRd of ColorBrewer. You will learn more about the color scheme in sub-section 4.4.\nBy default, Missing value will be shaded in grey.\n\n\n\n2.4.2.3. Drawing a choropleth map using tm_fill() and tm_border()\n\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY')\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY')+\n  tm_borders(alpha = 1 , lwd = 0.5)\n\n\n\n\nBeside alpha argument, there are three other arguments for tm_borders(), they are:\n\ncol = border colour,\nlwd = border line width. The default is 1, and\nlty = border line type. The default is “solid”.\n\n\n\n\n\n2.4.3 Data classification methods of tmap\nThe point of classification is to take a large number of observations and group them into data ranges or classes.\ntmap provides a total ten data classification methods, namely: fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, and jenks.\nTo define a data classification method, the style argument of tm_fill() or tm_polygons() will be used.\n\nPlotting choropleth maps with built-in classification methods\nQuantile classification with 5 classes The Jenks method clusters data into groups that minimize the within-group variance and maximize the between-group variance.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", n = 5, style = 'jenks') +\n  tm_borders(alpha = 0.5)\n\n\n\n\nEqual data classification\n\ntm_shape(mpsz_pop2020)+\n    tm_fill(\"DEPENDENCY\", n = 5, style = 'equal') +\n  tm_borders(alpha = 0.5)\n\n\n\n\nNotice that the distribution of quantile data classification method are more evenly distributed then equal data classification method.\n\nDIY: Using what you had learned, prepare choropleth maps by using different classification methods supported by tmap and compare their differences.\n\n\ntm_shape(mpsz_pop2020)+\n    tm_fill(\"DEPENDENCY\", n = 5, style = 'kmeans') +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n    tm_fill(\"DEPENDENCY\", n = 5, style = 'sd') +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n    tm_fill(\"DEPENDENCY\", n = 5, style = 'fisher') +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\nDIY: Preparing choropleth maps by using similar classification method but with different numbers of classes (i.e. 2, 6, 10, 20). Compare the output maps, what observation can you draw?\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", n = 3, style = 'jenks') +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", n = 10, style = 'jenks') +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n2.4.3.2 Plotting choropleth maps with custome break\nThe breakpoints can be set explicitly by means of the breaks argument to the tm_fill().\n\nbreaks include min and max\nto have n categories, n+1 elements to be specified in breaks option\nvalues must be in increasing order\n\nGood practise: descriptive statistics on variable before setting break points\n\nsummary(mpsz_pop2020$DEPENDENCY)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.0000  0.6519  0.7025  0.7742  0.7645 19.0000      92 \n\n\n\nboxplot(mpsz_pop2020$DEPENDENCY, outline=FALSE)\n\n\n\n\nWith reference to summary stats and boxplot above,\n\nbreak points are 0.6, 0.7, 0.8, 0.9\nmin = 0 and max = 1.0\nbreak vector is thus c(0, 0.6, 0.7, 0.8, 0.9, 1.0)\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", breaks = c(0, 0.6, 0.7, 0.8, 0.9, 1.0)) +\n  tm_borders(alpha = 0.5)\n\nWarning: Values have found that are higher than the highest break\n\n\n\n\n\n\n\n\n2.4.4 Colour scheme\n\n2.4.4.1 Using ColourBrewer palette\nAssign the preferred colour to palette argument of tm_fill()\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"Blues\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nReverse the colour scheme by adding “-”\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n2.4.5 Map Layouts\n\ncustomise title, scale bar, compass, margins, aspect ratios\nother than colour palette and data classification (breaks) which is done in tm_fill()\n\n\n2.4.5.1 Map Legend\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"jenks\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone \\n(Jenks classification)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            legend.outside = FALSE,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n2.4.5.2 Map style\ntmap allows a wide variety of layout settings to be changed. They can be called by using tmap_style()\nPredefined styles: ‘white’, ‘gray’, ‘natural’, ‘bw’, ‘classic’, ‘cobalt’, albatross’, ‘beaver’, ‘col_blind’, ‘watercolor’\nBelow is an example of classic style\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5)+\n  tmap_style('natural')\n\ntmap style set to \"natural\"\n\n\nother available styles are: \"white\", \"gray\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\n\n\n2.4.5.3 Cartographic Furniture\nCan include other map furniture like compass, scale bar, and grid lines\ntmap_style has to be used at the last, think cannot mix with tm\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Reds\",\n          title = \"No. of persons\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio \\nby planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\")) +\n  tmap_style('natural')\n\ntmap style set to \"natural\"\n\n\nother available styles are: \"white\", \"gray\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\nTo reset the default style, refer below\n\ntmap_style(\"white\")\n\ntmap style set to \"white\"\n\n\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\n2.4.6 Drawing Small Multiple Choropleth Maps\nSmall multiple maps, also referred to as facet maps, are composed of many maps arrange side-by-side, and sometimes stacked vertically. Small multiple maps enable the visualisation of how spatial relationships change with respect to another variable, such as time.\nIn tmap, small multiple maps can be plotted in three ways:\n\nby assigning multiple values to at least one of the asthetic arguments,\nby defining a group-by variable in tm_facets(), and\nby creating multiple stand-alone maps with tmap_arrange().\n\n\n\n2.4.6.1 By assigning multiple values to at least one of the aesthetic arguments\n\ndefine ncols in tm_fill() : c(‘YOUNG’, ‘AGED’ , ‘TOTAL’)\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(c('YOUNG', 'AGED','TOTAL'),\n          style='equal',\n          palette='Blues') +\n  tm_layout(legend.position = c('right','bottom')) +\n  tm_borders(alpha = 0.5) +\n  tmap_style('white')\n\ntmap style set to \"white\"\n\n\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\n\nAssigning multiple values to at least one of the aesthetic arguments\n\n\nshape + polygon method (Prof’s)\n\n\ntm_shape(mpsz_pop2020)+ \n  tm_polygons(c(\"DEPENDENCY\",\"AGED\"),\n          style = c(\"equal\", \"quantile\"), \n          palette = list(\"Blues\",\"Greens\")) +\n  tm_layout(legend.position = c(\"right\", \"bottom\")) +\n  tmap_style('white')\n\ntmap style set to \"white\"\n\n\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\n\nshape + fill + borders method (YX’s)\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(c('YOUNG', 'AGED','TOTAL'),\n          style=c('equal', 'quantile', 'equal'),\n          palette= list('Blues', 'Greens', 'Reds')) +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.position = c('right','bottom'))\n\n\n\n#  tmap_style('white')\n\n\n\n2.4.6.2 By defining a group-by variable in tm_facets()\nIn this example, multiple small choropleth maps are created by using tm_facets().\nthres.poly: number that specifies the threshold at which polygons are taken into account. The number itself corresponds to the proportion of the area sizes of the polygons to the total polygon size. By default, all polygons are drawn.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          style= 'quantile',\n          palette = 'Blues',\n          thres.poly = 0) +\n  tm_facets(by = 'REGION_N',\n            free.coords = TRUE,\n            drop.shapes = TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c('center','center'),\n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n\nWarning: The argument drop.shapes has been renamed to drop.units, and is\ntherefore deprecated\n\n\n\n\n\n\n\n2.4.6.3 By creating multiple stand-alone maps with tmap_arrange()\nCreating multiple stand-alone maps with tmap_arrange() asp : aspect ratio\nnrow : number of rows (ncols)\n\nyoungmap <- tm_shape(mpsz_pop2020) + \n  tm_polygons('YOUNG',\n              style= 'quantile',\n              palette = 'Blues')\n\nagedmap <- tm_shape(mpsz_pop2020) + \n  tm_polygons('AGED',\n              style= 'quantile',\n              palette = 'Blues')\n\ntmap_arrange(youngmap,agedmap, asp = 3, nrow=2)\n\n\n\n\n\n\n\n2.4.7 Mappping Spatial Object Meeting a Selection Criterion\n\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N == \"CENTRAL REGION\",]) +\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(main.title = \"Mapping spatial obj with conditions \\n(Central Region)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.45, \n            legend.width = 5.0,\n            legend.outside = TRUE,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\nWarning in pre_process_gt(x, interactive = interactive, orig_crs =\ngm$shape.orig_crs): legend.width controls the width of the legend within a map.\nPlease use legend.outside.size to control the width of the outside legend\n\n\n\n\n\n\n\n2.4.8. Tmap summary\nFrom chap 2, using tmap package to plot\n1. tm_shape+ tm_polygon\n2. tm_shape+ tm_fill + tm_borders _ tm_layout\n3. qtm\nChap 2: To plot small multiple chloroplath maps via qtm or tmap elements:\n1. Add multiple values to tm_polygon or tm_fill\n2. Tm_facets\n3. Tm_arrange\nChap 3: To plot small multiple layered chloroplath maps via plot() method:\n 4. To arrange the maps via plot(),\npar(mfrow=c(2,2)) <- 2x2 layout\nFrom chap 3: to add layers to a plot\n1. just keep repeating plot(weight matrix ,coords,add=TRUE)\nhttps://rstudio-pubs-static.s3.amazonaws.com/730482_d7889d9c65c8422f843b3d4e0196633c.html"
  },
  {
    "objectID": "Hands-on_Ex02/Hands-on_Ex02.html#reference",
    "href": "Hands-on_Ex02/Hands-on_Ex02.html#reference",
    "title": "Hands-on_Ex02",
    "section": "2.5 Reference",
    "text": "2.5 Reference\n\n2.5.1 All about tmap package\n\ntmap: Thematic Maps in R\ntmap\ntmap: get started!\ntmap: changes in version 2.0\ntmap: creating thematic maps in a flexible way (useR!2015)\nExploring and presenting maps with tmap (useR!2017)\n\n\n\n2.5.2 Geospatial data wrangling\n\nsf: Simple Features for R\nSimple Features for R: StandardizedSupport for Spatial Vector Data\nReading, Writing and Converting Simple Features\n\n\n\n2.5.3 Data wrangling\n\ndplyr\nTidy data\ntidyr: Easily Tidy Data with ‘spread()’ and ‘gather()’ Functions"
  },
  {
    "objectID": "Hands-on_Ex03/Hands-on_ex03.html",
    "href": "Hands-on_Ex03/Hands-on_ex03.html",
    "title": "Hands-on_Ex03",
    "section": "",
    "text": "In this hands-on exercise, I will learn how to compute spatial weights."
  },
  {
    "objectID": "Hands-on_Ex03/Hands-on_ex03.html#the-study-area-and-data",
    "href": "Hands-on_Ex03/Hands-on_ex03.html#the-study-area-and-data",
    "title": "Hands-on_Ex03",
    "section": "3.2 The Study Area and Data",
    "text": "3.2 The Study Area and Data\n\nHunan country boundary layer -geospatial data in ESRI shapefile format\nhunan_2012.csv - contains local development indicators in 2012\n\n\n3.2.1 Getting Started (ctrl-atl-i)\n\nlibrary(sf)\n\nLinking to GEOS 3.9.3, GDAL 3.5.2, PROJ 8.2.1; sf_use_s2() is TRUE\n\nlibrary(spdep)\n\nLoading required package: sp\n\n\nLoading required package: spData\n\n\nTo access larger datasets in this package, install the spDataLarge\npackage with: `install.packages('spDataLarge',\nrepos='https://nowosad.github.io/drat/', type='source')`\n\nlibrary(tmap)\nlibrary(tidyverse)\n\n── Attaching packages\n───────────────────────────────────────\ntidyverse 1.3.2 ──\n\n\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.8     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.1\n✔ readr   2.1.2     ✔ forcats 0.5.2\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()"
  },
  {
    "objectID": "Hands-on_Ex03/Hands-on_ex03.html#getting-the-data-into-r-environment",
    "href": "Hands-on_Ex03/Hands-on_ex03.html#getting-the-data-into-r-environment",
    "title": "Hands-on_Ex03",
    "section": "3.3 Getting the Data Into R Environment",
    "text": "3.3 Getting the Data Into R Environment\n\n3.3.1 Import shapefile into r environment\n\nhunan <- st_read(dsn='data/geospatial' ,\n                 layer = 'Hunan')\n\nReading layer `Hunan' from data source \n  `C:\\yixin-neo\\ISSS624\\Hands-on_Ex03\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\n\n\n3.3.2 Import csv file into r environment\n\nhunan2012 <- read_csv('data/aspatial/Hunan_2012.csv')\n\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\n3.3.3 Performing relational join\nUpdate attribute table of Hunan’s SpatialPolygonDataFrame (dbf) with attribute field of hunan2012 dataframe. (csv)\n\nhunan <- left_join(hunan, hunan2012)\n\nJoining, by = \"County\"\n\n\nhunan ’s coordinate system is WGS 84. Does it mean that we are nut using projected system here?\n\nst_geometry(hunan)\n\nGeometry set for 88 features \nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n\n\nPOLYGON ((112.0625 29.75523, 112.069 29.74544, ...\n\n\nPOLYGON ((112.2288 29.11684, 112.2339 29.11214,...\n\n\nPOLYGON ((111.8927 29.6013, 111.8906 29.59811, ...\n\n\nPOLYGON ((111.3731 29.94649, 111.3737 29.94167,...\n\n\nPOLYGON ((111.6324 29.76288, 111.6312 29.75165,..."
  },
  {
    "objectID": "Hands-on_Ex03/Hands-on_ex03.html#visualising-regional-development-indicator",
    "href": "Hands-on_Ex03/Hands-on_ex03.html#visualising-regional-development-indicator",
    "title": "Hands-on_Ex03",
    "section": "3.4 Visualising Regional Development Indicator",
    "text": "3.4 Visualising Regional Development Indicator\n\nprepare basemap and choropleth map showing distribution of GDPCC 2012 by using qtm() of tmap package\n\n\nbasemap <- tm_shape(hunan) +\n  tm_polygons() +\n  tm_text('NAME_3', size = 0.3)\n\ngdppc <- qtm(hunan, 'GDPPC')\n\ntmap_arrange(basemap, gdppc, asp = 1, ncol=2)"
  },
  {
    "objectID": "Hands-on_Ex03/Hands-on_ex03.html#computing-contiguity-spatial-weights",
    "href": "Hands-on_Ex03/Hands-on_ex03.html#computing-contiguity-spatial-weights",
    "title": "Hands-on_Ex03",
    "section": "3.5 Computing Contiguity Spatial Weights",
    "text": "3.5 Computing Contiguity Spatial Weights\n\nuse poly2nb() of spdep package to compute contiguity weight matrices\nthis weight matrices has class of ‘nb’\nthis function builds a neighbour list based on regions with contiguous boundaries\nthe ‘queen’ argument’s default value is set to FALSE (first order neighbours). Might need to set to TRUE when needed\n\n\n3.5.1 Computing (QUEEN) contiguity based neighbours\n\nwm_q <- poly2nb(hunan, queen=TRUE) #wm_q is class 'nb'\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\n\n88 area units in Hunan\nmost connected unit (88) has 11 neighbours\ntwo area units (30 & 65) with only one neighbour\nThe ‘link number distribution’ tells us the frequency distribution ( 2 county has 1 neighbour, 2 county has 2 neighbours, 12 county has 3 neighbours)\n\nTo see the neighbours of the first polygon, use code chunk below:\n\nwm_q[[1]]\n\n[1]  2  3  4 57 85\n\n\n\nclass(wm_q[[1]])\n\n[1] \"integer\"\n\n\nYX tried to show the neighbours of first 2 polygons\n\nwm_q[1:2]\n\n[[1]]\n[1]  2  3  4 57 85\n\n[[2]]\n[1]  1 57 58 78 85\n\n\nTo retrieve the country name of the Polygon ID = 1, use code chunk below:\n\nhunan$County[1]\n\n[1] \"Anxiang\"\n\n\nTo reveal the country names of the five neighbouring polygons,\n\nhunan$NAME_3[c(2,3,4,57,85)]\n\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n\n\nTo retrieve the GDPPC of the five neighbour countries,\n\nnb1 <- wm_q[[1]]\nnb1 <- hunan$GDPPC[nb1]\nnb1\n\n[1] 20981 34592 24473 21311 22879\n\n\nYX’s practise (use c(2,3,4,57,85)) instead of wm_q[[1]]\n\nnb1 <- wm_q[[1]] #neighbours of polygon ID=1\nnb1 <- hunan$GDPPC[c(2,3,4,57,85)] #retrieve GDPPC of neighbours of polygon ID= 1\nnb1\n\n[1] 20981 34592 24473 21311 22879\n\n\nTo display the complete weight matrix, use str()\n\nrow 1: neighbours of polygon ID =1\nrow 2: neighbours of polygon ID =2 etc..\n\n\nstr(wm_q)\n\nList of 88\n $ : int [1:5] 2 3 4 57 85\n $ : int [1:5] 1 57 58 78 85\n $ : int [1:4] 1 4 5 85\n $ : int [1:4] 1 3 5 6\n $ : int [1:4] 3 4 6 85\n $ : int [1:5] 4 5 69 75 85\n $ : int [1:4] 67 71 74 84\n $ : int [1:7] 9 46 47 56 78 80 86\n $ : int [1:6] 8 66 68 78 84 86\n $ : int [1:8] 16 17 19 20 22 70 72 73\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:3] 11 15 17\n $ : int [1:4] 13 14 17 83\n $ : int [1:5] 10 17 22 72 83\n $ : int [1:7] 10 11 14 15 16 72 83\n $ : int [1:5] 20 22 23 77 83\n $ : int [1:6] 10 20 21 73 74 86\n $ : int [1:7] 10 18 19 21 22 23 82\n $ : int [1:5] 19 20 35 82 86\n $ : int [1:5] 10 16 18 20 83\n $ : int [1:7] 18 20 38 41 77 79 82\n $ : int [1:5] 25 28 31 32 54\n $ : int [1:5] 24 28 31 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:3] 26 29 42\n $ : int [1:5] 24 25 33 49 54\n $ : int [1:3] 27 37 42\n $ : int 33\n $ : int [1:8] 24 25 32 36 39 40 56 81\n $ : int [1:8] 24 31 50 54 55 56 75 85\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 47 80 82 86\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:4] 29 42 43 44\n $ : int [1:4] 23 44 77 79\n $ : int [1:5] 31 40 42 43 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:7] 26 27 29 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:4] 37 38 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:3] 8 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:5] 32 48 52 54 55\n $ : int [1:3] 48 49 52\n $ : int [1:5] 48 49 50 51 54\n $ : int [1:3] 48 55 75\n $ : int [1:6] 24 28 32 49 50 52\n $ : int [1:5] 32 48 50 53 75\n $ : int [1:7] 8 31 32 36 78 80 85\n $ : int [1:6] 1 2 58 64 76 85\n $ : int [1:5] 2 57 68 76 78\n $ : int [1:4] 60 61 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:7] 12 59 60 62 63 77 87\n $ : int [1:3] 61 77 87\n $ : int [1:4] 12 61 77 83\n $ : int [1:2] 57 76\n $ : int 76\n $ : int [1:5] 9 67 68 76 84\n $ : int [1:4] 7 66 76 84\n $ : int [1:5] 9 58 66 76 78\n $ : int [1:3] 6 75 85\n $ : int [1:3] 10 72 73\n $ : int [1:3] 7 73 74\n $ : int [1:5] 10 11 16 17 70\n $ : int [1:5] 10 19 70 71 74\n $ : int [1:6] 7 19 71 73 84 86\n $ : int [1:6] 6 32 53 55 69 85\n $ : int [1:7] 57 58 64 65 66 67 68\n $ : int [1:7] 18 23 38 61 62 63 83\n $ : int [1:7] 2 8 9 56 58 68 85\n $ : int [1:7] 23 38 40 41 43 44 45\n $ : int [1:8] 8 34 35 36 41 45 47 56\n $ : int [1:6] 25 26 31 33 39 42\n $ : int [1:5] 20 21 23 35 41\n $ : int [1:9] 12 13 15 16 17 18 22 63 77\n $ : int [1:6] 7 9 66 67 74 86\n $ : int [1:11] 1 2 3 5 6 32 56 57 69 75 ...\n $ : int [1:9] 8 9 19 21 35 46 47 74 84\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language poly2nb(pl = hunan, queen = TRUE)\n - attr(*, \"type\")= chr \"queen\"\n - attr(*, \"sym\")= logi TRUE\n\n\n\n\n3.5.2 Creating (ROOK) contiguity based neighbours\nTo compute the Rook contiguity weight matrix,\n\nwm_r <- poly2nb(hunan, queen=FALSE)\nsummary(wm_r)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links\n\n\n\n88 area units in Hunan\nmost connected unit (85) has 11 neighbours\ntwo area units (30 & 65) with only one neighbour\n\n\n\n3.5.3 Visualising contiguity weights (find centroid coords first)\n\na connectivity graph takes a point and displays a line to each neighbouring point\nneed a point in polygon via polygon centroids <- calculate using the sf package first\n\nTo obtain coordinates in a separate data frame\n\ninput vector is the geometry column of us.bound, an sf object <- a polygon\napply mapping function (st_centroid) on input vector <- find the CG of this polygon\nuse map_dbl variation of map from the purrr package\n\nAfter finding centroid, to access longitude values\n\ndouble bracket notation [[ ]] and 1\n\n\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n\nTo access the latitude value\n\ndouble bracket notation [[ ]] and 2\n\n\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n\nWith both longitude and latitude, use cbind() to combine both in the same object,\n\ncoords <- cbind(longitude, latitude)\n\nCheck the first few observations,\n\nhead(coords)\n\n     longitude latitude\n[1,]  112.1531 29.44362\n[2,]  112.0372 28.86489\n[3,]  111.8917 29.47107\n[4,]  111.7031 29.74499\n[5,]  111.6138 29.49258\n[6,]  111.0341 29.79863\n\n\n\n3.5.3.1 Plotting Queen contiguity based neighbours map\nUse the plot() function\n\nThe shape of the markers: The plot markers are by default small, empty circles. These are also known as plot characters - denoted by pch. You can change these by adding a new pch value in the plot function. Pch values 0 to 25 are valid and give several different symbols on the graph. Pch 0 is for a square, 1 is for a circle, 3 is for a triangle, 4 is for a cross and so on.\nSize of the plot markers: This aspect of a graph can be controlled using the cex parameter. The cex parameter can be set to 0.5 if you want the markers to be 50% smaller and 1.5 if you want them to be 50% larger.\nColor of the plot markers: The symbols can be assigned one or many colors. These colors can be selected from a list provided by R under the colors() function.\n\nwm_ q is weight matrix using queen method (88 rows of list of neighbours)\ncoords is an array of x,y coordinates for each of the 88 counties\n\nplot(hunan$geometry, border = 'lightgrey')\nplot(wm_q, coords, pch = 19, cex = 0.6, add= TRUE, col='red')\n\n\n\n\n\n\n3.5.3.2 Plotting Rook contiguity based neighbours map\n\nplot(hunan$geometry, border = 'lightgrey')\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col =\"blue\")\n\n\n\n\n\n\n3.5.3.3 Plotting both Queen and Rook contiguity based neighbours maps\nUse the par(mfrow) function\n\npar(mfrow = c(1,2))  # by 1 by 2 plotting matrix\nplot(hunan$geometry, border=\"lightgrey\", main=\"Queen Contiguity\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\")\nplot(hunan$geometry, border=\"lightgrey\", main=\"Rook Contiguity\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\")"
  },
  {
    "objectID": "Hands-on_Ex03/Hands-on_ex03.html#computing-distance-based-neighbours",
    "href": "Hands-on_Ex03/Hands-on_ex03.html#computing-distance-based-neighbours",
    "title": "Hands-on_Ex03",
    "section": "3.6 Computing distance based neighbours",
    "text": "3.6 Computing distance based neighbours\n\nIn this section, I will derive distance-based weight matrices by using dnearneigh() of spdep package.\ndnearneigh(x, d1, d2, row.names = NULL, longlat = NULL, bounds=c(\"GE\", \"LE\"),\n use_kd_tree=TRUE, symtest=FALSE, use_s2=packageVersion(\"s2\") > \"1.0.7\", k=200,\n dwithin=TRUE)\nidentifies neighbours using distance band with lower d1= and upper d2= bounds controlled by the bounds= argument\nIf unprojected coordinates are used and either specified in the coordinates object x or with x as a two column matrix and longlat=TRUE, great circle distances in km will be calculated assuming the WGS84 reference ellipsoid.\n\n\n3.6.1 First, determine the cut-off distance (upper distance threshold to be considered a neighbour)\nFirst, determine the upper limit for distance band by using the steps below:\n\nReturn a matrix with the indices of points belonging to the set of the k nearest neighbours of each other by using knearneigh() of spdep. Output: NN of poly1 = poly3, NN of poly2 = poly 78 etc…. The output iz a knn object with class ‘knn’.\n$nn\n[,1]\n[1,] 3\n[2,] 78\n[3,] 1\nAfter applying knearneigh() , convert the knn object into a neighbours list of class nb with a list of integer vectors containing neighbour region number ids by using knn2nb().\n\nNeighbour list object:\nNumber of regions: 88\nNumber of nonzero links: 88\nPercentage nonzero weights: 1.136364\nAverage number of links: 1\nNon-symmetric neighbours list\n\nReturn the length of neighbour relationship edges by using nbdists() of spdep. <- returns the distance to one’s nearest neighbour? 88 polygons means 88 nearest neighbours. The function returns in the units of the coordinates if the coordinates are projected (in km if unprojected)\n\n[[1]]\n[1] 25.53398\n[[2]]\n[1] 43.03114\n[[3]]\n[1] 25.53398\n\nRemove the list structure of the returned object by using unlist(). The output is in numeric format.\n\nOutput: 25.53398 43.03114 25.53398 29.28480 29.28480 45.98097 58.52704 28.95985 34.45062 37.99885 44.49442 33.48816 35.98123\n\n#coords <- coordinates(hunan)\nk1 <- knn2nb(knearneigh(coords)) # nb class with 1 NN\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE)) #dist to 1 NN, class numeric\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\nThe summary report shows that the largest first nearest neighbour distance is 61.79. So using this as the upper threshold will help to ensure that all units (polygons) will have at least one neighbour.\n\nclass (k1)\n\n[1] \"nb\"\n\n\n\nclass(k1dists)\n\n[1] \"numeric\"\n\n\n\n\n3.6.2 Computing fixed distance weight matrix\n(Earlier, we had used poly2nb(hunan, queen=TRUE/FALSE) to find neighbours using Queen or Rook method)\nNow, to find neighbours using distance, we use the dnearneigh() ,\n\nlonglad argument: TRUE if point coordinates are geographical longitude-latitude decimal degrees\n\nDoes the average number of links mean that each polygon has average number of 3.6 nearest neighbours with upper bound of 62?\n\nwm_d62 <- dnearneigh(coords,0, 62, longlat=TRUE)  #class 'nb' by upper bound distance\nwm_d62\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n\n\n\nstr(wm_d62)\n\nList of 88\n $ : int [1:5] 3 4 5 57 64\n $ : int [1:4] 57 58 78 85\n $ : int [1:4] 1 4 5 57\n $ : int [1:3] 1 3 5\n $ : int [1:4] 1 3 4 85\n $ : int 69\n $ : int [1:2] 67 84\n $ : int [1:4] 9 46 47 78\n $ : int [1:4] 8 46 68 84\n $ : int [1:4] 16 22 70 72\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:2] 11 17\n $ : int 13\n $ : int [1:4] 10 17 22 83\n $ : int [1:3] 11 14 16\n $ : int [1:3] 20 22 63\n $ : int [1:5] 20 21 73 74 82\n $ : int [1:5] 18 19 21 22 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:4] 10 16 18 20\n $ : int [1:3] 41 77 82\n $ : int [1:4] 25 28 31 54\n $ : int [1:4] 24 28 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:2] 26 29\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:2] 27 37\n $ : int 33\n $ : int [1:2] 24 36\n $ : int 50\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:5] 31 34 45 56 80\n $ : int [1:2] 29 42\n $ : int [1:3] 44 77 79\n $ : int [1:4] 40 42 43 81\n $ : int [1:3] 39 45 79\n $ : int [1:5] 23 35 45 79 82\n $ : int [1:5] 26 37 39 43 81\n $ : int [1:3] 39 42 44\n $ : int [1:2] 38 43\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:5] 8 9 35 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:4] 48 49 50 52\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:2] 48 55\n $ : int [1:5] 24 28 49 50 52\n $ : int [1:4] 48 50 53 75\n $ : int 36\n $ : int [1:5] 1 2 3 58 64\n $ : int [1:5] 2 57 64 66 68\n $ : int [1:3] 60 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:5] 12 60 62 63 87\n $ : int [1:4] 61 63 77 87\n $ : int [1:5] 12 18 61 62 83\n $ : int [1:4] 1 57 58 76\n $ : int 76\n $ : int [1:5] 58 67 68 76 84\n $ : int [1:2] 7 66\n $ : int [1:4] 9 58 66 84\n $ : int [1:2] 6 75\n $ : int [1:3] 10 72 73\n $ : int [1:2] 73 74\n $ : int [1:3] 10 11 70\n $ : int [1:4] 19 70 71 74\n $ : int [1:5] 19 21 71 73 86\n $ : int [1:2] 55 69\n $ : int [1:3] 64 65 66\n $ : int [1:3] 23 38 62\n $ : int [1:2] 2 8\n $ : int [1:4] 38 40 41 45\n $ : int [1:5] 34 35 36 45 47\n $ : int [1:5] 25 26 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:4] 12 13 16 63\n $ : int [1:4] 7 9 66 68\n $ : int [1:2] 2 5\n $ : int [1:4] 21 46 47 74\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language dnearneigh(x = coords, d1 = 0, d2 = 62, longlat = TRUE)\n - attr(*, \"dnn\")= num [1:2] 0 62\n - attr(*, \"bounds\")= chr [1:2] \"GE\" \"LE\"\n - attr(*, \"nbtype\")= chr \"distance\"\n - attr(*, \"sym\")= logi TRUE\n\n\nAnother way to display the structure of the weight matrix is to combine table() and card() of spdep.\n\ntable(hunan$County, card(wm_d62))\n\n               \n                1 2 3 4 5 6\n  Anhua         1 0 0 0 0 0\n  Anren         0 0 0 1 0 0\n  Anxiang       0 0 0 0 1 0\n  Baojing       0 0 0 0 1 0\n  Chaling       0 0 1 0 0 0\n  Changning     0 0 1 0 0 0\n  Changsha      0 0 0 1 0 0\n  Chengbu       0 1 0 0 0 0\n  Chenxi        0 0 0 1 0 0\n  Cili          0 1 0 0 0 0\n  Dao           0 0 0 1 0 0\n  Dongan        0 0 1 0 0 0\n  Dongkou       0 0 0 1 0 0\n  Fenghuang     0 0 0 1 0 0\n  Guidong       0 0 1 0 0 0\n  Guiyang       0 0 0 1 0 0\n  Guzhang       0 0 0 0 0 1\n  Hanshou       0 0 0 1 0 0\n  Hengdong      0 0 0 0 1 0\n  Hengnan       0 0 0 0 1 0\n  Hengshan      0 0 0 0 0 1\n  Hengyang      0 0 0 0 0 1\n  Hongjiang     0 0 0 0 1 0\n  Huarong       0 0 0 1 0 0\n  Huayuan       0 0 0 1 0 0\n  Huitong       0 0 0 1 0 0\n  Jiahe         0 0 0 0 1 0\n  Jianghua      0 0 1 0 0 0\n  Jiangyong     0 1 0 0 0 0\n  Jingzhou      0 1 0 0 0 0\n  Jinshi        0 0 0 1 0 0\n  Jishou        0 0 0 0 0 1\n  Lanshan       0 0 0 1 0 0\n  Leiyang       0 0 0 1 0 0\n  Lengshuijiang 0 0 1 0 0 0\n  Li            0 0 1 0 0 0\n  Lianyuan      0 0 0 0 1 0\n  Liling        0 1 0 0 0 0\n  Linli         0 0 0 1 0 0\n  Linwu         0 0 0 1 0 0\n  Linxiang      1 0 0 0 0 0\n  Liuyang       0 1 0 0 0 0\n  Longhui       0 0 1 0 0 0\n  Longshan      0 1 0 0 0 0\n  Luxi          0 0 0 0 1 0\n  Mayang        0 0 0 0 0 1\n  Miluo         0 0 0 0 1 0\n  Nan           0 0 0 0 1 0\n  Ningxiang     0 0 0 1 0 0\n  Ningyuan      0 0 0 0 1 0\n  Pingjiang     0 1 0 0 0 0\n  Qidong        0 0 1 0 0 0\n  Qiyang        0 0 1 0 0 0\n  Rucheng       0 1 0 0 0 0\n  Sangzhi       0 1 0 0 0 0\n  Shaodong      0 0 0 0 1 0\n  Shaoshan      0 0 0 0 1 0\n  Shaoyang      0 0 0 1 0 0\n  Shimen        1 0 0 0 0 0\n  Shuangfeng    0 0 0 0 0 1\n  Shuangpai     0 0 0 1 0 0\n  Suining       0 0 0 0 1 0\n  Taojiang      0 1 0 0 0 0\n  Taoyuan       0 1 0 0 0 0\n  Tongdao       0 1 0 0 0 0\n  Wangcheng     0 0 0 1 0 0\n  Wugang        0 0 1 0 0 0\n  Xiangtan      0 0 0 1 0 0\n  Xiangxiang    0 0 0 0 1 0\n  Xiangyin      0 0 0 1 0 0\n  Xinhua        0 0 0 0 1 0\n  Xinhuang      1 0 0 0 0 0\n  Xinning       0 1 0 0 0 0\n  Xinshao       0 0 0 0 0 1\n  Xintian       0 0 0 0 1 0\n  Xupu          0 1 0 0 0 0\n  Yanling       0 0 1 0 0 0\n  Yizhang       1 0 0 0 0 0\n  Yongshun      0 0 0 1 0 0\n  Yongxing      0 0 0 1 0 0\n  You           0 0 0 1 0 0\n  Yuanjiang     0 0 0 0 1 0\n  Yuanling      1 0 0 0 0 0\n  Yueyang       0 0 1 0 0 0\n  Zhijiang      0 0 0 0 1 0\n  Zhongfang     0 0 0 1 0 0\n  Zhuzhou       0 0 0 0 1 0\n  Zixing        0 0 1 0 0 0\n\n\n\nn_comp <- n.comp.nb(wm_d62)\nn_comp$nc\n\n[1] 1\n\n\n\ntable(n_comp$comp.id)\n\n\n 1 \n88 \n\n\n\n3.6.2.1 Plotting fixed distance weight matrix\n\nwm_d62 is the fixed distance weight matrix,\ncoords refers to long, lat coordinates for CG of each polygon\nk1 is the integer ID of the polygon which is the nearest neighbour to me\n\n\nplot(hunan$geometry, border = 'lightgrey')\nplot (wm_d62, coords,add=TRUE)\nplot(k1, coords, add=TRUE, col ='red', length=0.08)\n\n\n\n\nThe red lines shows the links of 1st nearest neighbours and the black lines show the lines of neighbours within the cut-off distance of 62km.\nTo plot red and black side by side,\n\npar(mfrow=c(1,2))\nplot(hunan$geometry, border='light grey', main=\"1st NN\")\nplot(k1, coords, add=TRUE, col=\"red\", length='0.08')\nplot(hunan$geometry, border='light grey', main='Distance Link')\nplot(wm_d62, coords, add=TRUE, pch=19, cex=0.6)\n\n\n\n\n\n\n\n3.6.3 Computing adaptive distance weight matrix\nOne of the characteristics of fixed distance weight matrix is that more densely settled areas (usually the urban areas) tend to have more neighbours and the less densely settled areas (usually the rural counties) tend to have lesser neighbours. Having many neighbours smoothes the neighbour relationship across more neighbours.\nIt is possible to control the numbers of neighbours directly using k-nearest neighbours, either accepting asymmetric neighbours or imposing symmetry as shown in the code chunk below.\n\nknn6 <- knn2nb(knearneigh(coords, k = 6)) # class nb by fixed NN\nknn6\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 528 \nPercentage nonzero weights: 6.818182 \nAverage number of links: 6 \nNon-symmetric neighbours list\n\n\n*as seen above, each polygon has strictly six neighbours\n\nstr(knn6)\n\nList of 88\n $ : int [1:6] 2 3 4 5 57 64\n $ : int [1:6] 1 3 57 58 78 85\n $ : int [1:6] 1 2 4 5 57 85\n $ : int [1:6] 1 3 5 6 69 85\n $ : int [1:6] 1 3 4 6 69 85\n $ : int [1:6] 3 4 5 69 75 85\n $ : int [1:6] 9 66 67 71 74 84\n $ : int [1:6] 9 46 47 78 80 86\n $ : int [1:6] 8 46 66 68 84 86\n $ : int [1:6] 16 19 22 70 72 73\n $ : int [1:6] 10 14 16 17 70 72\n $ : int [1:6] 13 15 60 61 63 83\n $ : int [1:6] 12 15 60 61 63 83\n $ : int [1:6] 11 15 16 17 72 83\n $ : int [1:6] 12 13 14 17 60 83\n $ : int [1:6] 10 11 17 22 72 83\n $ : int [1:6] 10 11 14 16 72 83\n $ : int [1:6] 20 22 23 63 77 83\n $ : int [1:6] 10 20 21 73 74 82\n $ : int [1:6] 18 19 21 22 23 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:6] 10 16 18 19 20 83\n $ : int [1:6] 18 20 41 77 79 82\n $ : int [1:6] 25 28 31 52 54 81\n $ : int [1:6] 24 28 31 33 54 81\n $ : int [1:6] 25 27 29 33 42 81\n $ : int [1:6] 26 29 30 37 42 81\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:6] 26 27 37 42 43 81\n $ : int [1:6] 26 27 28 33 49 81\n $ : int [1:6] 24 25 36 39 40 54\n $ : int [1:6] 24 31 50 54 55 56\n $ : int [1:6] 25 26 28 30 49 81\n $ : int [1:6] 36 40 41 45 56 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:6] 26 27 29 42 43 44\n $ : int [1:6] 23 43 44 62 77 79\n $ : int [1:6] 25 40 42 43 44 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:6] 26 27 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:6] 37 38 39 42 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:6] 8 9 35 47 78 86\n $ : int [1:6] 8 21 35 46 80 86\n $ : int [1:6] 49 50 51 52 53 55\n $ : int [1:6] 28 33 48 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:6] 28 48 49 50 52 54\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:6] 48 50 51 52 55 75\n $ : int [1:6] 24 28 49 50 51 52\n $ : int [1:6] 32 48 50 52 53 75\n $ : int [1:6] 32 34 36 78 80 85\n $ : int [1:6] 1 2 3 58 64 68\n $ : int [1:6] 2 57 64 66 68 78\n $ : int [1:6] 12 13 60 61 87 88\n $ : int [1:6] 12 13 59 61 63 87\n $ : int [1:6] 12 13 60 62 63 87\n $ : int [1:6] 12 38 61 63 77 87\n $ : int [1:6] 12 18 60 61 62 83\n $ : int [1:6] 1 3 57 58 68 76\n $ : int [1:6] 58 64 66 67 68 76\n $ : int [1:6] 9 58 67 68 76 84\n $ : int [1:6] 7 65 66 68 76 84\n $ : int [1:6] 9 57 58 66 78 84\n $ : int [1:6] 4 5 6 32 75 85\n $ : int [1:6] 10 16 19 22 72 73\n $ : int [1:6] 7 19 73 74 84 86\n $ : int [1:6] 10 11 14 16 17 70\n $ : int [1:6] 10 19 21 70 71 74\n $ : int [1:6] 19 21 71 73 84 86\n $ : int [1:6] 6 32 50 53 55 69\n $ : int [1:6] 58 64 65 66 67 68\n $ : int [1:6] 18 23 38 61 62 63\n $ : int [1:6] 2 8 9 46 58 68\n $ : int [1:6] 38 40 41 43 44 45\n $ : int [1:6] 34 35 36 41 45 47\n $ : int [1:6] 25 26 28 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:6] 12 13 15 16 22 63\n $ : int [1:6] 7 9 66 68 71 74\n $ : int [1:6] 2 3 4 5 56 69\n $ : int [1:6] 8 9 21 46 47 74\n $ : int [1:6] 59 60 61 62 63 88\n $ : int [1:6] 59 60 61 62 63 87\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language knearneigh(x = coords, k = 6)\n - attr(*, \"sym\")= logi FALSE\n - attr(*, \"type\")= chr \"knn\"\n - attr(*, \"knn-k\")= num 6\n - attr(*, \"class\")= chr \"nb\"\n\n\n\n3.6.3.1 Plotting distance based neighbours\n\nplot(hunan$geometry, border=\"light grey\")\nplot(knn6, coords, pch= 19, cex=0.6, add=TRUE, col='red')"
  },
  {
    "objectID": "Hands-on_Ex03/Hands-on_ex03.html#weights-based-on-idw",
    "href": "Hands-on_Ex03/Hands-on_ex03.html#weights-based-on-idw",
    "title": "Hands-on_Ex03",
    "section": "3.7 Weights based on IDW",
    "text": "3.7 Weights based on IDW\nCompute the spatial weight matrix using the Inversed Distance Method\n\nrecall from lecture that closer polygon has greater weightage if we take inverse\n\nFirst compute distance between areas using y using nbdists() of spdep.\n\nGiven a list of spatial neighbour links (a neighbours list of object type nb), the function returns the Euclidean distances along the links in a list of the same form as the neighbours list. If longlat = TRUE, Great Circle distances are used.\n\nThen obtain the inversed-dist spatial weight matrix (ids) using lapply() to apply the function 1/(x), where x is the distance.\n\ndist <- nbdists(wm_q, coords, longlat = TRUE)  # class nbdists\n# [[1]] 65.12941 25.53398 54.91802 35.61352 87.32760\n#[[2]] 65.12941 56.67944 51.92312 43.03114 58.16151\nids <-lapply (dist, function(x) 1/(x)) # class list, inverse dist \nhead(ids)\n\n[[1]]\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n\n[[2]]\n[1] 0.01535405 0.01764308 0.01925924 0.02323898 0.01719350\n\n[[3]]\n[1] 0.03916350 0.02822040 0.03695795 0.01395765\n\n[[4]]\n[1] 0.01820896 0.02822040 0.03414741 0.01539065\n\n[[5]]\n[1] 0.03695795 0.03414741 0.01524598 0.01618354\n\n[[6]]\n[1] 0.015390649 0.015245977 0.021748129 0.011883901 0.009810297\n\n\n\n3.7.1 Row-standardised weights matrix\nUse the nb2listw()\nnb2listw(neighbours, glist=NULL, style=\"W\", zero.policy=NULL)\nArguments\n\n\n\n\n\n\n\nneighbours\nan object of class nb\n\n\n\n\nglist\nlist of general weights corresponding to neighbours\n\n\nstyle\nstyle can take values “W”, “B”, “C”, “U”, “minmax” and “S”\n\n\nzero.policy\ndefault NULL, use global option value; if FALSE stop with error for any empty neighbour sets, if TRUE permit the weights list to be formed with zero-length weights vectors\n\n\n\nDetails\nStarting from a binary neighbours list, in which regions are either listed as neighbours or are absent (thus not in the set of neighbours for some definition), the function adds a weights list with values given by the coding scheme style chosen.\nWeights to each neighboring polygon\n\neach neighboring polygon will be assigned equal weight (style=“W”) <- row standardised\nThis is accomplished by assigning the fraction 1/(#ofneighbors) to each neighboring county then summing the weighted income values\ndrawback of this method is that polygon along the edge will base their lagged values on fewer polygons, thus over estimating the true nature of spatial autocorrelation in the data. Next time can consider other more robust options are available, notably style=“B” <- basic binary coding\n\n\nrswm_q <- nb2listw(wm_q, style = 'W', zero.policy = TRUE)\nrswm_q # class\"listw\" \"nb\"  \n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\nThe zero.policy=TRUE option allows for lists of non-neighbors. This should be used with caution since the user may not be aware of missing neighbors in their dataset however, a zero.policy of FALSE would return an error.\nTo see the weight of the first polygon’s four neighbours type:\n\nrswm_q$weights[1]\n\n[[1]]\n[1] 0.2 0.2 0.2 0.2 0.2\n\n\nExplanation of above: Each neighbor is assigned a 0.2 of the total weight. This means that when R computes the average neighboring income values, each neighbor’s income will be multiplied by 0.2 before being tallied.\nYX’s practise (There are two variables in rswm_q, namely $neighbours and $ weight)\n\nstr(rswm_q)\n\nList of 3\n $ style     : chr \"W\"\n $ neighbours:List of 88\n  ..$ : int [1:5] 2 3 4 57 85\n  ..$ : int [1:5] 1 57 58 78 85\n  ..$ : int [1:4] 1 4 5 85\n  ..$ : int [1:4] 1 3 5 6\n  ..$ : int [1:4] 3 4 6 85\n  ..$ : int [1:5] 4 5 69 75 85\n  ..$ : int [1:4] 67 71 74 84\n  ..$ : int [1:7] 9 46 47 56 78 80 86\n  ..$ : int [1:6] 8 66 68 78 84 86\n  ..$ : int [1:8] 16 17 19 20 22 70 72 73\n  ..$ : int [1:3] 14 17 72\n  ..$ : int [1:5] 13 60 61 63 83\n  ..$ : int [1:4] 12 15 60 83\n  ..$ : int [1:3] 11 15 17\n  ..$ : int [1:4] 13 14 17 83\n  ..$ : int [1:5] 10 17 22 72 83\n  ..$ : int [1:7] 10 11 14 15 16 72 83\n  ..$ : int [1:5] 20 22 23 77 83\n  ..$ : int [1:6] 10 20 21 73 74 86\n  ..$ : int [1:7] 10 18 19 21 22 23 82\n  ..$ : int [1:5] 19 20 35 82 86\n  ..$ : int [1:5] 10 16 18 20 83\n  ..$ : int [1:7] 18 20 38 41 77 79 82\n  ..$ : int [1:5] 25 28 31 32 54\n  ..$ : int [1:5] 24 28 31 33 81\n  ..$ : int [1:4] 27 33 42 81\n  ..$ : int [1:3] 26 29 42\n  ..$ : int [1:5] 24 25 33 49 54\n  ..$ : int [1:3] 27 37 42\n  ..$ : int 33\n  ..$ : int [1:8] 24 25 32 36 39 40 56 81\n  ..$ : int [1:8] 24 31 50 54 55 56 75 85\n  ..$ : int [1:5] 25 26 28 30 81\n  ..$ : int [1:3] 36 45 80\n  ..$ : int [1:6] 21 41 47 80 82 86\n  ..$ : int [1:6] 31 34 40 45 56 80\n  ..$ : int [1:4] 29 42 43 44\n  ..$ : int [1:4] 23 44 77 79\n  ..$ : int [1:5] 31 40 42 43 81\n  ..$ : int [1:6] 31 36 39 43 45 79\n  ..$ : int [1:6] 23 35 45 79 80 82\n  ..$ : int [1:7] 26 27 29 37 39 43 81\n  ..$ : int [1:6] 37 39 40 42 44 79\n  ..$ : int [1:4] 37 38 43 79\n  ..$ : int [1:6] 34 36 40 41 79 80\n  ..$ : int [1:3] 8 47 86\n  ..$ : int [1:5] 8 35 46 80 86\n  ..$ : int [1:5] 50 51 52 53 55\n  ..$ : int [1:4] 28 51 52 54\n  ..$ : int [1:5] 32 48 52 54 55\n  ..$ : int [1:3] 48 49 52\n  ..$ : int [1:5] 48 49 50 51 54\n  ..$ : int [1:3] 48 55 75\n  ..$ : int [1:6] 24 28 32 49 50 52\n  ..$ : int [1:5] 32 48 50 53 75\n  ..$ : int [1:7] 8 31 32 36 78 80 85\n  ..$ : int [1:6] 1 2 58 64 76 85\n  ..$ : int [1:5] 2 57 68 76 78\n  ..$ : int [1:4] 60 61 87 88\n  ..$ : int [1:4] 12 13 59 61\n  ..$ : int [1:7] 12 59 60 62 63 77 87\n  ..$ : int [1:3] 61 77 87\n  ..$ : int [1:4] 12 61 77 83\n  ..$ : int [1:2] 57 76\n  ..$ : int 76\n  ..$ : int [1:5] 9 67 68 76 84\n  ..$ : int [1:4] 7 66 76 84\n  ..$ : int [1:5] 9 58 66 76 78\n  ..$ : int [1:3] 6 75 85\n  ..$ : int [1:3] 10 72 73\n  ..$ : int [1:3] 7 73 74\n  ..$ : int [1:5] 10 11 16 17 70\n  ..$ : int [1:5] 10 19 70 71 74\n  ..$ : int [1:6] 7 19 71 73 84 86\n  ..$ : int [1:6] 6 32 53 55 69 85\n  ..$ : int [1:7] 57 58 64 65 66 67 68\n  ..$ : int [1:7] 18 23 38 61 62 63 83\n  ..$ : int [1:7] 2 8 9 56 58 68 85\n  ..$ : int [1:7] 23 38 40 41 43 44 45\n  ..$ : int [1:8] 8 34 35 36 41 45 47 56\n  ..$ : int [1:6] 25 26 31 33 39 42\n  ..$ : int [1:5] 20 21 23 35 41\n  ..$ : int [1:9] 12 13 15 16 17 18 22 63 77\n  ..$ : int [1:6] 7 9 66 67 74 86\n  ..$ : int [1:11] 1 2 3 5 6 32 56 57 69 75 ...\n  ..$ : int [1:9] 8 9 19 21 35 46 47 74 84\n  ..$ : int [1:4] 59 61 62 88\n  ..$ : int [1:2] 59 87\n  ..- attr(*, \"class\")= chr \"nb\"\n  ..- attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n  ..- attr(*, \"call\")= language poly2nb(pl = hunan, queen = TRUE)\n  ..- attr(*, \"type\")= chr \"queen\"\n  ..- attr(*, \"sym\")= logi TRUE\n $ weights   :List of 88\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:8] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num 1\n  ..$ : num [1:8] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n  ..$ : num [1:8] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:2] 0.5 0.5\n  ..$ : num 1\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:8] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:9] 0.111 0.111 0.111 0.111 0.111 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:11] 0.0909 0.0909 0.0909 0.0909 0.0909 ...\n  ..$ : num [1:9] 0.111 0.111 0.111 0.111 0.111 ...\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:2] 0.5 0.5\n  ..- attr(*, \"mode\")= chr \"binary\"\n  ..- attr(*, \"W\")= logi TRUE\n  ..- attr(*, \"comp\")=List of 1\n  .. ..$ d: num [1:88] 5 5 4 4 4 5 4 7 6 8 ...\n - attr(*, \"class\")= chr [1:2] \"listw\" \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language nb2listw(neighbours = wm_q, style = \"W\", zero.policy = TRUE)\n\n\nUsing the same method, we can also derive a row standardised distance weight matrix (closer neighbours have higher weightings) by using the code chunk below.\n*notice that the spatial weight matrix using inverse weight method is used here and with style = ‘B’\n\nrswm_ids <- nb2listw(wm_q, glist=ids, style='B', zero.policy=TRUE)\nrswm_ids # class \"listw\" weights list \"nb\"  \n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn       S0        S1     S2\nB 88 7744 8.786867 0.3776535 3.8137\n\n\n\nrswm_ids$weights[1]\n\n[[1]]\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n\n\n\nsummary(unlist(rswm_ids$weights))\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n0.008218 0.015088 0.018739 0.019614 0.022823 0.040338"
  },
  {
    "objectID": "Hands-on_Ex03/Hands-on_ex03.html#application-of-spatial-weight-matrix",
    "href": "Hands-on_Ex03/Hands-on_ex03.html#application-of-spatial-weight-matrix",
    "title": "Hands-on_Ex03",
    "section": "3.8 Application of Spatial Weight Matrix",
    "text": "3.8 Application of Spatial Weight Matrix\nIn this section, you will learn how to create four different spatial lagged variables, they are:\n\nspatial lag with row-standardized weights,\nspatial lag as a sum of neighbouring values,\nspatial window average, and spatial window sum.\n\n\n3.8.1 Spatial lag with row-standardized weights\n\ncompute the average neighbour GDPCC values for each polygon\ncommonly called spatially lagged values\nIn the code below, use spatial weight matrix (equal weightage of 0.2 for poly1 etc.. ) by 0.2 * 20981 + 0.2 * 34592 + 0.2 * 24473 + 0.2 * 21311 + 0.2 * 22879 = 24847.20 for poly1 “Anxiang”\n22724.80 is the average GDPPC for poly2 based on equal weightage (0.2) of all its five neighbours . 24143.25 for poly3 based on equal weightage (0.25) based on four neighbours.\n\n\nGDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)\nGDPPC.lag # numeric class\n\n [1] 24847.20 22724.80 24143.25 27737.50 27270.25 21248.80 43747.00 33582.71\n [9] 45651.17 32027.62 32671.00 20810.00 25711.50 30672.33 33457.75 31689.20\n[17] 20269.00 23901.60 25126.17 21903.43 22718.60 25918.80 20307.00 20023.80\n[25] 16576.80 18667.00 14394.67 19848.80 15516.33 20518.00 17572.00 15200.12\n[33] 18413.80 14419.33 24094.50 22019.83 12923.50 14756.00 13869.80 12296.67\n[41] 15775.17 14382.86 11566.33 13199.50 23412.00 39541.00 36186.60 16559.60\n[49] 20772.50 19471.20 19827.33 15466.80 12925.67 18577.17 14943.00 24913.00\n[57] 25093.00 24428.80 17003.00 21143.75 20435.00 17131.33 24569.75 23835.50\n[65] 26360.00 47383.40 55157.75 37058.00 21546.67 23348.67 42323.67 28938.60\n[73] 25880.80 47345.67 18711.33 29087.29 20748.29 35933.71 15439.71 29787.50\n[81] 18145.00 21617.00 29203.89 41363.67 22259.09 44939.56 16902.00 16930.00\n\n\nRecalled in the previous section, we retrieved the GDPPC of these five countries (neighbours of poly1 using queen method) by using the code chunk below.\n\nnb1 <- wm_q[[1]]\nnb1 <- hunan$GDPPC[nb1]\nnb1\n\n[1] 20981 34592 24473 21311 22879\n\n\nWe can append the spatially lag GDPPC values onto hunan sf data frame by using the code chunk below.\n\nlag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC)) # two lists: county and ave GDPC appended\nlag.res <- as.data.frame(lag.list) # class dataframe of Anxiang - 24847.20 , Hanshou 22724.80 etc\ncolnames(lag.res) <- c('NAME_3', 'lag GDPPC') # rename the col of lag.res\nhunan <- left_join(hunan,lag.res)\n\nJoining, by = \"NAME_3\"\n\n\nThe average neighboring income values for each county is now stored as a new column ‘lag GDPPC’ in hunan sf\n\nhead(hunan)\n\nSimple feature collection with 6 features and 36 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 110.4922 ymin: 28.61762 xmax: 112.3013 ymax: 30.12812\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3 Shape_Leng Shape_Area  County    City\n1 Changde 21098 Anxiang      County   1.869074 0.10056190 Anxiang Changde\n2 Changde 21100 Hanshou      County   2.360691 0.19978745 Hanshou Changde\n3 Changde 21101  Jinshi County City   1.425620 0.05302413  Jinshi Changde\n4 Changde 21102      Li      County   3.474325 0.18908121      Li Changde\n5 Changde 21103   Linli      County   2.289506 0.11450357   Linli Changde\n6 Changde 21104  Shimen      County   4.171918 0.37194707  Shimen Changde\n  avg_wage deposite     FAI Gov_Rev Gov_Exp     GDP GDPPC     GIO   Loan  NIPCR\n1    31935   5517.2  3541.0  243.64  1779.5 12482.0 23667  5108.9 2806.9 7693.7\n2    32265   7979.0  8665.0  386.13  2062.4 15788.0 20981 13491.0 4550.0 8269.9\n3    28692   4581.7  4777.0  373.31  1148.4  8706.9 34592 10935.0 2242.0 8169.9\n4    32541  13487.0 16066.0  709.61  2459.5 20322.0 24473 18402.0 6748.0 8377.0\n5    32667    564.1  7781.2  336.86  1538.7 10355.0 25554  8214.0  358.0 8143.1\n6    33261   8334.4 10531.0  548.33  2178.8 16293.0 27137 17795.0 6026.5 6156.0\n   Bed    Emp  EmpR EmpRT Pri_Stu Sec_Stu Household Household_R NOIP Pop_R\n1 1931 336.39 270.5 205.9  19.584  17.819     148.1       135.4   53 346.0\n2 2560 456.78 388.8 246.7  42.097  33.029     240.2       208.7   95 553.2\n3  848 122.78  82.1  61.7   8.723   7.592      81.9        43.7   77  92.4\n4 2038 513.44 426.8 227.1  38.975  33.938     268.5       256.0   96 539.7\n5 1440 307.36 272.2 100.8  23.286  18.943     129.1       157.2   99 246.6\n6 2502 392.05 329.6 193.8  29.245  26.104     190.6       184.7  122 399.2\n    RSCG Pop_T    Agri Service Disp_Inc      RORP    ROREmp lag GDPPC\n1 3957.9 528.3 4524.41   14100    16610 0.6549309 0.8041262  24847.20\n2 4460.5 804.6 6545.35   17727    18925 0.6875466 0.8511756  22724.80\n3 3683.0 251.8 2562.46    7525    19498 0.3669579 0.6686757  24143.25\n4 7110.2 832.5 7562.34   53160    18985 0.6482883 0.8312558  27737.50\n5 3604.9 409.3 3583.91    7031    18604 0.6024921 0.8856065  27270.25\n6 6490.7 600.5 5266.51    6981    19275 0.6647794 0.8407091  21248.80\n                        geometry\n1 POLYGON ((112.0625 29.75523...\n2 POLYGON ((112.2288 29.11684...\n3 POLYGON ((111.8927 29.6013,...\n4 POLYGON ((111.3731 29.94649...\n5 POLYGON ((111.6324 29.76288...\n6 POLYGON ((110.8825 30.11675...\n\n\nNext, we will plot both the GDPPC and spatial lag GDPPC for comparison using the code chunk below.\n\ngdppc <- qtm (hunan, 'GDPPC')\nlag_gdppc <- qtm(hunan, 'lag GDPPC')\ntmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)\n\n\n\n\n\n\n3.8.2 Spatial lag as a sum of neighboring values\nPart 1: Obtain binary weights spatial weight matrix ‘b_weights’:\nwm_q (aka neighbour list) is a ‘nb’ class containing neighbour IDs for each polygon. E.g. first three polygons has neighbours\n$ : int [1:5] 2 3 4 57 85\n$ : int [1:5] 1 57 58 78 85\n$ : int [1:4] 1 4 5 85\nTo create a binary list, we will now apply lambda function of 0*neighbour ID + 1 ; so that if there is a neighbour, the value is 1.\nPart 2: Create the standardise row matrix using nb2listw() , with glist argument = b_weights to take binary feature into account\n\nb_weights <- lapply(wm_q, function(x) 0*x + 1) # class 'list'\n# [[2]]\n#[1] 1 1 1 1 1\n#[[3]]\n#[1] 1 1 1 1\n\nb_weights2 <- nb2listw(wm_q, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2 # class \"listw\" , \"nb\"\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224\n\n\nWith the proper weights assigned, we can use lag.listw to compute a lag variable from our weight and GDPPC.\n\nlag_sum <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\nlag.res <- as.data.frame(lag_sum)\ncolnames(lag.res) <- c('NAME_3', 'lag_sum GDPPC')\n\nexamine lag_sum (list of polygon and the sum of their neighbours’ GDPPC)\n\nlag_sum\n\n[[1]]\n [1] \"Anxiang\"       \"Hanshou\"       \"Jinshi\"        \"Li\"           \n [5] \"Linli\"         \"Shimen\"        \"Liuyang\"       \"Ningxiang\"    \n [9] \"Wangcheng\"     \"Anren\"         \"Guidong\"       \"Jiahe\"        \n[13] \"Linwu\"         \"Rucheng\"       \"Yizhang\"       \"Yongxing\"     \n[17] \"Zixing\"        \"Changning\"     \"Hengdong\"      \"Hengnan\"      \n[21] \"Hengshan\"      \"Leiyang\"       \"Qidong\"        \"Chenxi\"       \n[25] \"Zhongfang\"     \"Huitong\"       \"Jingzhou\"      \"Mayang\"       \n[29] \"Tongdao\"       \"Xinhuang\"      \"Xupu\"          \"Yuanling\"     \n[33] \"Zhijiang\"      \"Lengshuijiang\" \"Shuangfeng\"    \"Xinhua\"       \n[37] \"Chengbu\"       \"Dongan\"        \"Dongkou\"       \"Longhui\"      \n[41] \"Shaodong\"      \"Suining\"       \"Wugang\"        \"Xinning\"      \n[45] \"Xinshao\"       \"Shaoshan\"      \"Xiangxiang\"    \"Baojing\"      \n[49] \"Fenghuang\"     \"Guzhang\"       \"Huayuan\"       \"Jishou\"       \n[53] \"Longshan\"      \"Luxi\"          \"Yongshun\"      \"Anhua\"        \n[57] \"Nan\"           \"Yuanjiang\"     \"Jianghua\"      \"Lanshan\"      \n[61] \"Ningyuan\"      \"Shuangpai\"     \"Xintian\"       \"Huarong\"      \n[65] \"Linxiang\"      \"Miluo\"         \"Pingjiang\"     \"Xiangyin\"     \n[69] \"Cili\"          \"Chaling\"       \"Liling\"        \"Yanling\"      \n[73] \"You\"           \"Zhuzhou\"       \"Sangzhi\"       \"Yueyang\"      \n[77] \"Qiyang\"        \"Taojiang\"      \"Shaoyang\"      \"Lianyuan\"     \n[81] \"Hongjiang\"     \"Hengyang\"      \"Guiyang\"       \"Changsha\"     \n[85] \"Taoyuan\"       \"Xiangtan\"      \"Dao\"           \"Jiangyong\"    \n\n[[2]]\n [1] 124236 113624  96573 110950 109081 106244 174988 235079 273907 256221\n[11]  98013 104050 102846  92017 133831 158446 141883 119508 150757 153324\n[21] 113593 129594 142149 100119  82884  74668  43184  99244  46549  20518\n[31] 140576 121601  92069  43258 144567 132119  51694  59024  69349  73780\n[41]  94651 100680  69398  52798 140472 118623 180933  82798  83090  97356\n[51]  59482  77334  38777 111463  74715 174391 150558 122144  68012  84575\n[61] 143045  51394  98279  47671  26360 236917 220631 185290  64640  70046\n[71] 126971 144693 129404 284074 112268 203611 145238 251536 108078 238300\n[81] 108870 108085 262835 248182 244850 404456  67608  33860\n\n\nNext, we will append the lag_sum GDPPC field into hunan sf data frame by using the code chunk below.\n\nhunan <- left_join(hunan, lag.res)\n\nJoining, by = \"NAME_3\"\n\n\nPlot both the GDPPC and Spatial Lag Sum GDPPC for comparison\n\ngdppc <- qtm(hunan, \"GDPPC\")\nlag_sum_gdppc <- qtm(hunan, \"lag_sum GDPPC\")\ntmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)\n\n\n\n\n\n\n3.8.3 Spatial window average\n\nrow-standardized weights\nincludes the diagonal element\n\nNeed to add the diagonal element to the neighbour structure before assigning weights. Start by using include.self to include ‘k6’ to a new variable before directly altering its structure to add diagonal element.\n\nwm_q1 <- wm_q\n\nIF we want to add the diagonal element to the neighbour list, we just need to use include.self() from spdep. Use this instead to overwrite: wm_q1 <- include.self(wm_q1)\n\nwm_q1 <- include.self(wm_q1) #look the same as wm_q1 but diff structurally\n\nTo obtain the row standardised weights with diagonal, use nb2listw()\n\nwm_q1 <- nb2listw(wm_q1)\nwm_q1\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 30.90265 357.5308\n\n\nCreate the lag variable from our weight structure and GDPPC variable.\n\nlag_w_avg_gpdpc <- lag.listw(wm_q1, \n                             hunan$GDPPC)\nlag_w_avg_gpdpc\n\n [1] 24650.50 22434.17 26233.00 27084.60 26927.00 22230.17 47621.20 37160.12\n [9] 49224.71 29886.89 26627.50 22690.17 25366.40 25825.75 30329.00 32682.83\n[17] 25948.62 23987.67 25463.14 21904.38 23127.50 25949.83 20018.75 19524.17\n[25] 18955.00 17800.40 15883.00 18831.33 14832.50 17965.00 17159.89 16199.44\n[33] 18764.50 26878.75 23188.86 20788.14 12365.20 15985.00 13764.83 11907.43\n[41] 17128.14 14593.62 11644.29 12706.00 21712.29 43548.25 35049.00 16226.83\n[49] 19294.40 18156.00 19954.75 18145.17 12132.75 18419.29 14050.83 23619.75\n[57] 24552.71 24733.67 16762.60 20932.60 19467.75 18334.00 22541.00 26028.00\n[65] 29128.50 46569.00 47576.60 36545.50 20838.50 22531.00 42115.50 27619.00\n[73] 27611.33 44523.29 18127.43 28746.38 20734.50 33880.62 14716.38 28516.22\n[81] 18086.14 21244.50 29568.80 48119.71 22310.75 43151.60 17133.40 17009.33\n\n\nconvert the lag variable listw object into a data.frame by using as.data.frame().\n\nlag.list.wm_q1 <- list(hunan$NAME_3, lag.listw(wm_q1, \n                             hunan$GDPPC))\nlag.list.wm_q1\n\n[[1]]\n [1] \"Anxiang\"       \"Hanshou\"       \"Jinshi\"        \"Li\"           \n [5] \"Linli\"         \"Shimen\"        \"Liuyang\"       \"Ningxiang\"    \n [9] \"Wangcheng\"     \"Anren\"         \"Guidong\"       \"Jiahe\"        \n[13] \"Linwu\"         \"Rucheng\"       \"Yizhang\"       \"Yongxing\"     \n[17] \"Zixing\"        \"Changning\"     \"Hengdong\"      \"Hengnan\"      \n[21] \"Hengshan\"      \"Leiyang\"       \"Qidong\"        \"Chenxi\"       \n[25] \"Zhongfang\"     \"Huitong\"       \"Jingzhou\"      \"Mayang\"       \n[29] \"Tongdao\"       \"Xinhuang\"      \"Xupu\"          \"Yuanling\"     \n[33] \"Zhijiang\"      \"Lengshuijiang\" \"Shuangfeng\"    \"Xinhua\"       \n[37] \"Chengbu\"       \"Dongan\"        \"Dongkou\"       \"Longhui\"      \n[41] \"Shaodong\"      \"Suining\"       \"Wugang\"        \"Xinning\"      \n[45] \"Xinshao\"       \"Shaoshan\"      \"Xiangxiang\"    \"Baojing\"      \n[49] \"Fenghuang\"     \"Guzhang\"       \"Huayuan\"       \"Jishou\"       \n[53] \"Longshan\"      \"Luxi\"          \"Yongshun\"      \"Anhua\"        \n[57] \"Nan\"           \"Yuanjiang\"     \"Jianghua\"      \"Lanshan\"      \n[61] \"Ningyuan\"      \"Shuangpai\"     \"Xintian\"       \"Huarong\"      \n[65] \"Linxiang\"      \"Miluo\"         \"Pingjiang\"     \"Xiangyin\"     \n[69] \"Cili\"          \"Chaling\"       \"Liling\"        \"Yanling\"      \n[73] \"You\"           \"Zhuzhou\"       \"Sangzhi\"       \"Yueyang\"      \n[77] \"Qiyang\"        \"Taojiang\"      \"Shaoyang\"      \"Lianyuan\"     \n[81] \"Hongjiang\"     \"Hengyang\"      \"Guiyang\"       \"Changsha\"     \n[85] \"Taoyuan\"       \"Xiangtan\"      \"Dao\"           \"Jiangyong\"    \n\n[[2]]\n [1] 24650.50 22434.17 26233.00 27084.60 26927.00 22230.17 47621.20 37160.12\n [9] 49224.71 29886.89 26627.50 22690.17 25366.40 25825.75 30329.00 32682.83\n[17] 25948.62 23987.67 25463.14 21904.38 23127.50 25949.83 20018.75 19524.17\n[25] 18955.00 17800.40 15883.00 18831.33 14832.50 17965.00 17159.89 16199.44\n[33] 18764.50 26878.75 23188.86 20788.14 12365.20 15985.00 13764.83 11907.43\n[41] 17128.14 14593.62 11644.29 12706.00 21712.29 43548.25 35049.00 16226.83\n[49] 19294.40 18156.00 19954.75 18145.17 12132.75 18419.29 14050.83 23619.75\n[57] 24552.71 24733.67 16762.60 20932.60 19467.75 18334.00 22541.00 26028.00\n[65] 29128.50 46569.00 47576.60 36545.50 20838.50 22531.00 42115.50 27619.00\n[73] 27611.33 44523.29 18127.43 28746.38 20734.50 33880.62 14716.38 28516.22\n[81] 18086.14 21244.50 29568.80 48119.71 22310.75 43151.60 17133.40 17009.33\n\n\n\nlag_wm_q1.res <- as.data.frame(lag.list.wm_q1)\nhead(lag_wm_q1.res)\n\n  c..Anxiang....Hanshou....Jinshi....Li....Linli....Shimen....Liuyang...\n1                                                                Anxiang\n2                                                                Hanshou\n3                                                                 Jinshi\n4                                                                     Li\n5                                                                  Linli\n6                                                                 Shimen\n  c.24650.5..22434.1666666667..26233..27084.6..26927..22230.1666666667..\n1                                                               24650.50\n2                                                               22434.17\n3                                                               26233.00\n4                                                               27084.60\n5                                                               26927.00\n6                                                               22230.17\n\n\nrenames the field names of lag_wm_q1.res object into NAME_3 and lag_window_avg GDPPC respectively.\n\ncolnames(lag_wm_q1.res) <- c(\"NAME_3\", \"lag_window_avg GDPPC\")\n\nAppend lag_window_avg GDPPC values onto hunan sf data.frame by using left_join() of dplyr package.\n\nhunan <- left_join(hunan, lag_wm_q1.res)\n\nJoining, by = \"NAME_3\"\n\n\nqtm() of tmap package is used to plot the GDPPC and lag_window_avg GDPPC map next to each other for quick comparison.\n\ngdppc <- qtm(hunan, \"GDPPC\")\nw_avg_gdppc <- qtm(hunan, \"lag_window_avg GDPPC\")\ntmap_arrange(gdppc, w_avg_gdppc, asp=1, ncol=2)\n\n\n\n\n\n\n3.8.4 Spatial window sum\nThe spatial window sum is the counter part of the window average, but\n\nwithout using row-standardized weights.\nassign binary weights to the neighbor structure that includes the diagonal element.\n\n\nwm_q2 <- wm_q\n\nAdd the diagonal element to the neighbour list, we just need to use include.self() from spdep.\n\nwm_q2 <- include.self(wm_q2)\n\n\nsummary(wm_q2)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 10 12 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 2 links\n1 most connected region:\n85 with 12 links\n\n\nAssign binary weights to the neighbour structure that includes the diagonal element. (If there is a neighbour, give a value of 1)\n\nb_weights <- lapply(wm_q2, function(x) 0*x +1)\nb_weights[1:5]\n\n[[1]]\n[1] 1 1 1 1 1 1\n\n[[2]]\n[1] 1 1 1 1 1 1\n\n[[3]]\n[1] 1 1 1 1 1\n\n[[4]]\n[1] 1 1 1 1 1\n\n[[5]]\n[1] 1 1 1 1 1\n\n\nuse nb2listw() and glist() to explicitly assign weight values.\n\nb_weigths2 <- nb2listw(wm_q2,glist=b_weights, style='B')\nb_weights2\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224\n\n\nWith our new weight structure, we can compute the lag variable with lag.listw().\n\nw_sum_gdppc <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\nw_sum_gdppc\n\n[[1]]\n [1] \"Anxiang\"       \"Hanshou\"       \"Jinshi\"        \"Li\"           \n [5] \"Linli\"         \"Shimen\"        \"Liuyang\"       \"Ningxiang\"    \n [9] \"Wangcheng\"     \"Anren\"         \"Guidong\"       \"Jiahe\"        \n[13] \"Linwu\"         \"Rucheng\"       \"Yizhang\"       \"Yongxing\"     \n[17] \"Zixing\"        \"Changning\"     \"Hengdong\"      \"Hengnan\"      \n[21] \"Hengshan\"      \"Leiyang\"       \"Qidong\"        \"Chenxi\"       \n[25] \"Zhongfang\"     \"Huitong\"       \"Jingzhou\"      \"Mayang\"       \n[29] \"Tongdao\"       \"Xinhuang\"      \"Xupu\"          \"Yuanling\"     \n[33] \"Zhijiang\"      \"Lengshuijiang\" \"Shuangfeng\"    \"Xinhua\"       \n[37] \"Chengbu\"       \"Dongan\"        \"Dongkou\"       \"Longhui\"      \n[41] \"Shaodong\"      \"Suining\"       \"Wugang\"        \"Xinning\"      \n[45] \"Xinshao\"       \"Shaoshan\"      \"Xiangxiang\"    \"Baojing\"      \n[49] \"Fenghuang\"     \"Guzhang\"       \"Huayuan\"       \"Jishou\"       \n[53] \"Longshan\"      \"Luxi\"          \"Yongshun\"      \"Anhua\"        \n[57] \"Nan\"           \"Yuanjiang\"     \"Jianghua\"      \"Lanshan\"      \n[61] \"Ningyuan\"      \"Shuangpai\"     \"Xintian\"       \"Huarong\"      \n[65] \"Linxiang\"      \"Miluo\"         \"Pingjiang\"     \"Xiangyin\"     \n[69] \"Cili\"          \"Chaling\"       \"Liling\"        \"Yanling\"      \n[73] \"You\"           \"Zhuzhou\"       \"Sangzhi\"       \"Yueyang\"      \n[77] \"Qiyang\"        \"Taojiang\"      \"Shaoyang\"      \"Lianyuan\"     \n[81] \"Hongjiang\"     \"Hengyang\"      \"Guiyang\"       \"Changsha\"     \n[85] \"Taoyuan\"       \"Xiangtan\"      \"Dao\"           \"Jiangyong\"    \n\n[[2]]\n [1] 124236 113624  96573 110950 109081 106244 174988 235079 273907 256221\n[11]  98013 104050 102846  92017 133831 158446 141883 119508 150757 153324\n[21] 113593 129594 142149 100119  82884  74668  43184  99244  46549  20518\n[31] 140576 121601  92069  43258 144567 132119  51694  59024  69349  73780\n[41]  94651 100680  69398  52798 140472 118623 180933  82798  83090  97356\n[51]  59482  77334  38777 111463  74715 174391 150558 122144  68012  84575\n[61] 143045  51394  98279  47671  26360 236917 220631 185290  64640  70046\n[71] 126971 144693 129404 284074 112268 203611 145238 251536 108078 238300\n[81] 108870 108085 262835 248182 244850 404456  67608  33860\n\n\nConvert the lag variable listw object into a data.frame by using as.data.frame().\nRename the field names of w_sum_gdppc.res object into NAME_3 and w_sum GDPPC respectively.\n\nw_sum_gdppc.res <- as.data.frame(w_sum_gdppc)\ncolnames(w_sum_gdppc.res) <- c(\"NAME_3\", \"w_sum GDPPC\")\n\nAppend w_sum GDPPC values onto hunan sf data.frame by using left_join() of dplyr package\n\nhunan <- left_join(hunan, w_sum_gdppc.res)\n\nJoining, by = \"NAME_3\"\n\n\nUse qtm() of tmap package is used to plot the GDPPC and lag_sum GDPPC map next to each other for quick comparison\n\ngdppc <- qtm(hunan, \"GDPPC\")\nw_sum_gdppc <- qtm(hunan, \"w_sum GDPPC\")\ntmap_arrange(gdppc, w_sum_gdppc, asp=1, ncol=2)\n\n\n\n\n1. Coords- refers to coordinates (x,y) of centroid’s CG\n2. Neighbour id list (Queen, rook, dist based, fix nn)\n3. Spatial weight matrix based on inverse distance matrix (ids) nbdists () & lapply () , based on a neighbour id list\n4.1. Row standardize matrix using rswm_q<-nb2listw(wm_q) (equal weight for each neighbour)\n4.2. Row standardize inverse distance matrix using Rswm_ids<-nb2listw(neighbour id list wm_q, glist= ids)\n5.1 Create spatially lagged values with standardized weights for each polygon - lag.listw(rswm_q, hunan$gdppc) (Usually standardised rows (for find ave spatial lagged variables) for Queen/Rook methods)\n5.2. Create spatially lagged values as SUM of neighbouring values\n\nCreate neighbour structure with Binary weights using b_weights<-lapply (wm_q, function(x) 0*x+1)\nb_weights2<-Nb2listw(wm_q, glist=b_weights) to assign weights\nCreate lag sum variable (a calculated variable for each polygons’s gdppc neighbour sum) using lag.listw(b_weights2, hunan$gdpcc) again\n\n5.3. Spatial Window AVERAGE (create neighbour structure with (or without) diagonals , standardize rows with equal weight)\n\nwm_q1 <-Include.self(wm_q)\nStandardize row weights using nb2listw() again\nUse lag.listw() again to get spatially lag variable\nAppend, set as df, rename cols, left join , plot qtm x2 and tm_arrange()\n\n5.4. Spatial Weights SUM (without row standardized weights, assign binary weights to neighbour structure with (or without) diagonal element)"
  },
  {
    "objectID": "Hands-on_Ex03/Hands-on_ex03.html#references",
    "href": "Hands-on_Ex03/Hands-on_ex03.html#references",
    "title": "Hands-on_Ex03",
    "section": "3.9 References",
    "text": "3.9 References\n\nCreating Neighbours using sf objects"
  },
  {
    "objectID": "Hands-on_Ex04/Hands-on_Ex04.html",
    "href": "Hands-on_Ex04/Hands-on_Ex04.html",
    "title": "Hands-on_Ex04",
    "section": "",
    "text": "In this hands-on exercises, I will be\n1. computing Global (GSA) by using spdep package.\n2. computing Local measure of Spatial Autocorrelation (LISA) to detect clusters and outliers by using spdep packages\n3. computing Getis-Ord’s Gi-statistics for detecting hot spot or/ and cold spot area by using spdep package\n4. visualising the analysis output by using tmap package"
  },
  {
    "objectID": "Hands-on_Ex04/Hands-on_Ex04.html#getting-started",
    "href": "Hands-on_Ex04/Hands-on_Ex04.html#getting-started",
    "title": "Hands-on_Ex04",
    "section": "4.2 Getting Started",
    "text": "4.2 Getting Started\nRecall\n\nwm_q is neighbour list (class = nb) <- poly2nb()\nfor distance based concept, find coordinates to relate to polygons first. Next find the upper bound so that each polygon has at least one neighbour. Use knearneigh() to find k-nearest neighbour, then convert knn object to nb object using knn2nb(). Lastly, use nbdists() to calculate distance of all neighbours. Use unlist() to remove list structure. use summary (k1dists) to check details. Get the threshold distance.\nNow we have coords and a distance threshold , we can create a neighbour list of nb class using dnearneigh(coords, 0, 62, longlat = TRUE)\n\nwm_d62 is a neighbour list obj with class nb, made from dnearneighbour(). Use summary(wm_d62) to check details. Use str(wm_d62) to see attributes, then index (wm_d62[1:5]) to view first 5 neighbour list.\n\nAlternatively, we can create a neighbour list based on adaptive distance using knn2nb( knearneigh(coords, k = 6)). knn6 is a neighbour list obj with class nb. We can plot the neighbours on map.\nUse nb2listw() to convert from nb obj to listw obj (To create spatial weight object to calculate spatial lag later)\n\nIn hands-on 3 , rswm_q is equal weightage spatial matrix object via rows standardisation <- nb2listw( nb class obj) . This is based on contiguity concept.\nIn hands-on 3, rswm_ids is a weighted spatial matrix object using contiguity concept, but infused with ids (inverse distance matrix, class list) <- nb2listw(nb class obj, glist = ids, style=‘B’). This is also based on contiguity method, but style B which is more robust as we differ the weighting according to another inverse distance matrix separately derived.\nin hands-on 4, wm62_lw is the binary weight spatial matrix object using fixed-distance concept. wm62_lw <- nb2listw(wm_d62, style = ‘B’). Can use summary(wm62_lw) for quick discovery. str(wm62_lw) to check attributes and then index wm62_lw$weights[1:5] to check the first five weights of our spatial weights matrix (binary)\nin hands-on 4, knn_lw is the binary weight spatial matrix object using adaptive distance concept (fixed number of neighbours)\n\nGDPPC.lag <- a spatial lag variable that gives the averaged neighbour GDPPC value for one’s neighbours <- lag.listw( weight matrix, shapefile file $ col)\nOther points to note: cbind() is to combine data frame with same number of rows.\n\nhunan is a simple feature collection with class ‘sf’ , ’ data frame’\nCreate a new sf data frame (hunan.gi) by adding a localG vector to hunan as a new column, use cbind() and then rename column. as.matrix(gi.fixed) straightens the Gi values into 1 col of 88 rows.\n\nhunan.gi <- cbind(hunan, as.matrix(gi.fixed)) %>% rename(gstat_fixed = as.matrix.gi.fixed.)\n\nSimilarly, create a new sf data frame by adding localMI vector to hunan sf dataframe as a new column,\n\nhunan.localMI <- cbind(hunan,localMI)%>% rename(Pr.Ii = Pr.z….E.Ii..)\n\nTo add a new lag_GDPPC column into hunan:\n\nhunan$lag_GDPPC <- lag.listw(rswm_q, hunan$GDPPC)\n\nAdd a new column of standardised GDPPC by scaling original GDPPC column.\n\nhunan$Z.GDPPC <- scale(hunan$GDPPC) %>% as.vector\n\nThe most indirect method (hands-on 3)\n\nlag.list <- list ( hunan$NAME_3, lag.listw (rswm_q, hunan $ GDPPC))\nlag.res <- as.data.frame(lag.list)\ncolnames(lag.res) <- c(‘colname1’ , ‘colname2’)\nhunan <- leftjoin(hunan, lag.res)\n\n\n\n\n4.2.1 The analytical question\n\nis there equal distribution of development in the province?\nif answer is NO, we ask “is there sign of clustering?” (GLOBAL spatial autocorrelation)\nif YES, “Where are the clusters” (LOCAL spatial autocorrelation)\n\nIn this case study, we are interested to examine the spatial pattern of a selected development indicator (i.e. GDP per capita) of Hunan Provice, People Republic of China.\n\n\n4.2.2 The Study Area and Data\nTwo data sets will be used in this hands-on exercise:\n\ngeospatial data: Hunan province administrative boundary layer at county level in ESRI shapefile format\naspatial data: Hunan_2012.csv containing local development indicators\n\n\n\n4.2.3 Setting the Analytical Tools\nPackages we need:\n\nsf is use for importing and handling geospatial data in R,\ntidyverse is mainly use for wrangling attribute data in R,\nspdep will be used to compute spatial weights, global and local spatial autocorrelation statistics, and\ntmap will be used to prepare cartographic quality chropleth map.\n\n\nlibrary(sf)\n\nLinking to GEOS 3.9.3, GDAL 3.5.2, PROJ 8.2.1; sf_use_s2() is TRUE\n\nlibrary(spdep)\n\nLoading required package: sp\n\n\nLoading required package: spData\n\n\nTo access larger datasets in this package, install the spDataLarge\npackage with: `install.packages('spDataLarge',\nrepos='https://nowosad.github.io/drat/', type='source')`\n\nlibrary(tmap)\nlibrary(tidyverse)\n\n── Attaching packages\n───────────────────────────────────────\ntidyverse 1.3.2 ──\n\n\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.8     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.1\n✔ readr   2.1.2     ✔ forcats 0.5.2\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()"
  },
  {
    "objectID": "Hands-on_Ex04/Hands-on_Ex04.html#getting-the-data-into-r-environment",
    "href": "Hands-on_Ex04/Hands-on_Ex04.html#getting-the-data-into-r-environment",
    "title": "Hands-on_Ex04",
    "section": "4.3 Getting the Data Into R Environment",
    "text": "4.3 Getting the Data Into R Environment\n\n4.3.1 Import shapefile into r environment\n\nhunan <-st_read(dsn='data/geospatial',\n                layer= 'Hunan')\n\nReading layer `Hunan' from data source \n  `C:\\yixin-neo\\ISSS624\\Hands-on_Ex04\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\n*data is in WSG84 format, not projected yet. If we are going to extract the data, better not to st_transform() to project coordinate system first.\n\n\n4.3.2 Import csv file into r environment\n\nhunan2012 <- read_csv('data/aspatial/Hunan_2012.csv')\n\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\n4.3.3 Performing relational join\n\nhunan <- left_join(hunan, hunan2012) %>% \n  select(1:4, 7, 15)\n\nJoining, by = \"County\"\n\n\nJoined by ‘County’, selected only columns NAME_2, ID_3, NAME_3, ENGTYPE_3, County, GDPPC, geometry is automatically included as last variable\n\n\n4.3.4 Visualising Regional Development Indicator\nNow we will prepare basemap and a choropleth map showing the distribution of GDPPC 2012 by using qtm() of tmap package\n*tm_fill() ’s n refer to the number of equal intervals\n\nequal <- tm_shape(hunan)+\n  tm_fill('GDPPC',\n          n=5,\n          style='equal') +\n  tm_borders(alpha=0.5) +\n  tm_layout(main.title = 'Equal interval classification',\n            main.title.size=0.8,\n            legend.height = 0.2,\n            legend.width = 0.2)\n\nquantile <- tm_shape(hunan)+\n  tm_fill('GDPPC',\n          n=5,\n          style='quantile') +\n  tm_borders(alpha=0.5) +\n  tm_layout(main.title = 'Equal quantile classification',\n            main.title.size=0.8,\n            legend.height = 0.2,\n            legend.width = 0.2)\n\ntmap_arrange(equal, quantile, asp =1, ncol=2)\n\nLegend labels were too wide. The labels have been resized to 0.36, 0.33, 0.33, 0.33, 0.33. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger.\nLegend labels were too wide. The labels have been resized to 0.36, 0.33, 0.33, 0.33, 0.33. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger."
  },
  {
    "objectID": "Hands-on_Ex04/Hands-on_Ex04.html#global-spatial-autocorrelation",
    "href": "Hands-on_Ex04/Hands-on_Ex04.html#global-spatial-autocorrelation",
    "title": "Hands-on_Ex04",
    "section": "4.4 Global Spatial Autocorrelation",
    "text": "4.4 Global Spatial Autocorrelation\n\ncompute global spatial autocorrelation statistics\nperform spatial complete randomness test for global spatial autocorrelation.\n\n\n4.4.1 Computing Contiguity Spatial Weights\n\nConstruct a spatial weights of study area using poly2nb() of the spdep package. This builds a neighbour list using contiguous boundaries.\n\n\nwm_q <- poly2nb(hunan, queen=TRUE)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\nThe summary report above shows that there are 88 area units in Hunan. The most connected area unit has 11 neighbours. There are two area units with only one neighbours. The mode is 5 neighbours and there are 24 county with 5 neighbours.\n\n\n4.4.2 Row-standardised weights matrix\nThis is one of the ways to assign weights to each neighboring polygon. Each neighbouring polygons will be assigned to equal weight (style = “W”). A fraction of (1/ #neighbours) will be assigned to each neighbouring country, then summing up the weighted GDPPC values.\nThis is an intuitive way to summarise neighbours’ values, but the drawback is that polygon along the edges have less neighbours and thus we might over or under estimate the true nature of the spatial autocorrelation in the data. Note that more robust option are available, notably style =“B” of the nb2listw() function.\n\nhelp(nb2listw)\n\nstarting httpd help server ... done\n\n\n\nrswm_q <- nb2listw(wm_q,\n                   style = \"W\",\n                   zero.policy=TRUE)\nrswm_q\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\n\nclass(rswm_q)\n\n[1] \"listw\" \"nb\"   \n\n\n\nattributes(rswm_q)\n\n$names\n[1] \"style\"      \"neighbours\" \"weights\"   \n\n$class\n[1] \"listw\" \"nb\"   \n\n$region.id\n [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\" \"12\" \"13\" \"14\" \"15\"\n[16] \"16\" \"17\" \"18\" \"19\" \"20\" \"21\" \"22\" \"23\" \"24\" \"25\" \"26\" \"27\" \"28\" \"29\" \"30\"\n[31] \"31\" \"32\" \"33\" \"34\" \"35\" \"36\" \"37\" \"38\" \"39\" \"40\" \"41\" \"42\" \"43\" \"44\" \"45\"\n[46] \"46\" \"47\" \"48\" \"49\" \"50\" \"51\" \"52\" \"53\" \"54\" \"55\" \"56\" \"57\" \"58\" \"59\" \"60\"\n[61] \"61\" \"62\" \"63\" \"64\" \"65\" \"66\" \"67\" \"68\" \"69\" \"70\" \"71\" \"72\" \"73\" \"74\" \"75\"\n[76] \"76\" \"77\" \"78\" \"79\" \"80\" \"81\" \"82\" \"83\" \"84\" \"85\" \"86\" \"87\" \"88\"\n\n$call\nnb2listw(neighbours = wm_q, style = \"W\", zero.policy = TRUE)\n\n#attributes(rswm_q)$region.id\n\n\nmethods(class = \"nb\")\n\n[1] aggregate edit      intersect plot      print     setdiff   subset   \n[8] summary   union    \nsee '?methods' for accessing help and source code\n\n\nThe input of nb2listw() must be an object of class nb. The syntax of the function has two major arguments, namely style and zero.poly.\n\nstyle can take values “W”, “B”, “C”, “U”, “minmax” and “S”. B is the basic binary coding, W is row standardised (sums over all links to n), C is globally standardised (sums over all links to n), U is equal to C divided by the number of neighbours (sums over all links to unity), while S is the variance-stabilizing coding scheme proposed by Tiefelsdorf et al. 1999, p. 167-168 (sums over all links to n).\nIf zero policy is set to TRUE, weights vectors of zero length are inserted for regions without neighbour in the neighbours list. These will in turn generate lag values of zero, equivalent to the sum of products of the zero row t(rep(0, length=length(neighbours))) %*% x, for arbitrary numerical vector x of length length(neighbours). The spatially lagged value of x for the zero-neighbour region will then be zero, which may (or may not) be a sensible choice.\n\n\n\n4.4.3 Global Spatial Autocorrelation: Moran’s I\nIn this section, I will perform Moran’s I statistics testing by using moran.test() of spdep.\n\n\n4.4.4 Moran’s I test\n“na.omit() returns the object with incomplete cases removed”\n\nmoran.test(hunan$GDPPC,\n           listw=rswm_q,\n           zero.policy=TRUE,\n           na.action=na.omit)\n\n\n    Moran I test under randomisation\n\ndata:  hunan$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n\n\nNull hypothesis: The data observations are randomised.\nAlternative hypothesis: The data observations are not randomised (etc, clustering or deviations are observed between some observations)\nThe Moran’s I statistic value is positive, it implies that some clustering is observed.\nAt a p-value of less than 0.05, we have enough statistical evidence to reject the null hypothesis and conclude that some of the observation are not randomly distributed.\n\n4.4.4.1 Computing Monte Carlo Moran’s I\nThe code chunk below performs permutation test for Moran’s I statistic by using moran.mc() of spdep. A total of 1000 simulation will be performed. When there is uncertainty in the data (data changes every week), we use Monte Carlo simulation (rand(), randbetween(), poisson(), depending on understanding of data), to generate 1000 random values)\n* simulation starts from ‘1’, to get 1000 simulations, we start at 1 and end with 999 (inclusive)\n\nset.seed(1234)\n\nbperm = moran.mc(hunan$GDPPC,\n                 listw=rswm_q,\n                 nsim=999,\n                 zero.policy= TRUE,\n                 na.action=na.omit)\n\nbperm\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n\n\nWith a Moran I value of 0.30075 (positive means clustering, 0 means random, neg means deviation) , and a p value of less than 0.05 (statisfically significant), there are signs of clustering in the GDPPC in Hunan in some regions.\n\n\n4.4.4.2 Visualising Monte Carlo Moran’s I\nIt is always a good practice for us the examine the simulated Moran’s I test statistics in greater detail. This can be achieved by plotting the distribution of the statistical values as a histogram by using the code chunk below.\nIn the code chunk below hist() and abline() of R Graphics are used.\n\nstr(bperm)\n\nList of 7\n $ statistic  : Named num 0.301\n  ..- attr(*, \"names\")= chr \"statistic\"\n $ parameter  : Named num 1000\n  ..- attr(*, \"names\")= chr \"observed rank\"\n $ p.value    : num 0.001\n $ alternative: chr \"greater\"\n $ method     : chr \"Monte-Carlo simulation of Moran I\"\n $ data.name  : chr \"hunan$GDPPC \\nweights: rswm_q  \\nnumber of simulations + 1: 1000 \\n\"\n $ res        : num [1:1000] 0.05798 0.09954 0.06943 -0.10422 0.00381 ...\n - attr(*, \"class\")= chr [1:2] \"htest\" \"mc.sim\"\n\n\n\nclass(bperm)\n\n[1] \"htest\"  \"mc.sim\"\n\n\nAre these Moran’s I statistic values generated?\n\nhead(bperm$res)\n\n[1]  0.057980205  0.099537421  0.069425139 -0.104223988  0.003811019\n[6] -0.060131690\n\n\n\nmean(bperm$res[1:999])\n\n[1] -0.01504572\n\n\n\nvar(bperm$res[1:999])\n\n[1] 0.004371574\n\n\n\nsummary(bperm$res[1:999])\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.18339 -0.06168 -0.02125 -0.01505  0.02611  0.27593 \n\n\nPlot histogram breaks: number of histogram cells\nfreq: logical; if TRUE, the histogram graphic is a representation of frequencies, the counts component of the result; if FALSE, probability densities, component density, are plotted (so that the histogram has a total area of one). Defaults to TRUE if and only if breaks are equidistant (and probability is not specified).\n\nhist(bperm$res,\n     freq=TRUE,\n     breaks= 20,\n     xlab= \"Simulated Moran's I\"\n     )\nabline(v = 0, col=\"red\")\n\n\n\n\nConclusion: Moran I value obtained earlier was 0.30075, it is likely to be more extreme than the critical value, which means highly likely that my dataset is very different from the null hypothesis. In other words, Moran I value of 0.30075 shows that signs of clustering is likely to be true than it is to be expected by chance alone.\nChallenge: Plot histogram using ggplot2 instead\n\nlibrary(ggplot2)\nbperm.df <- as.data.frame(bperm$res)\ncolnames(bperm.df)[1] <- 'res'\n\nc <- ggplot(bperm.df, aes(res))\n\nc +\n  geom_histogram(boundary = 0,\n                 colour = 'black',\n                 binwidth =0.02,\n                 alpha= 0.5) +\n  geom_vline(xintercept=0,\n             colour = 'red') +\n  labs(title = \"Histogram of Moran's I\",\n       x = \"Simulated Moran' I \")\n\n\n\n\n\n\n\n4.4.5 Global Spatial Autocorrelation: Geary’s\nIn this section, you will learn how to perform Geary’s c statistics testing by using appropriate functions of spdep package.\n\n4.4.5.1 Geary’s C test\nGeary’s C test for spatial autocorrelation by using geary.test() of spdep.\n\ngeary.test(hunan$GDPPC, listw=rswm_q)\n\n\n    Geary C test under randomisation\n\ndata:  hunan$GDPPC \nweights: rswm_q \n\nGeary C statistic standard deviate = 3.6108, p-value = 0.0001526\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n        0.6907223         1.0000000         0.0073364 \n\n\nNull hypothesis: The data observations are randomised.\nAlternative hypothesis: The data observations are not randomised (etc, clustering or deviations are observed between some observations)\nThe Geary’s C statistic value (=0.6907223) is between 0 and 1, it implies that some clustering is observed.\n1 means completely random, 1-3 means deviations\nAt a p-value of less than 0.05, we have enough statistical evidence to reject the null hypothesis and conclude that some of the observation are not randomly distributed.\n\n\n4.4.5.2 Computing Monte Carlo Geary’s C\nThe code chunk below performs permutation test for Geary’s C statistic by using geary.mc() of spdep.\n\nset.seed(1234)\nbpermg = geary.mc(hunan$GDPPC,\n                  listw=rswm_q,\n                  nsim=999)\nbpermg\n\n\n    Monte-Carlo simulation of Geary C\n\ndata:  hunan$GDPPC \nweights: rswm_q \nnumber of simulations + 1: 1000 \n\nstatistic = 0.69072, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n\n\nSame statistical conclusion as above.\n\nclass(bpermg)\n\n[1] \"htest\"  \"mc.sim\"\n\nmethods(class='htest')\n\n[1] print\nsee '?methods' for accessing help and source code\n\nattributes(bperm)\n\n$names\n[1] \"statistic\"   \"parameter\"   \"p.value\"     \"alternative\" \"method\"     \n[6] \"data.name\"   \"res\"        \n\n$class\n[1] \"htest\"  \"mc.sim\"\n\nstr(bperm)\n\nList of 7\n $ statistic  : Named num 0.301\n  ..- attr(*, \"names\")= chr \"statistic\"\n $ parameter  : Named num 1000\n  ..- attr(*, \"names\")= chr \"observed rank\"\n $ p.value    : num 0.001\n $ alternative: chr \"greater\"\n $ method     : chr \"Monte-Carlo simulation of Moran I\"\n $ data.name  : chr \"hunan$GDPPC \\nweights: rswm_q  \\nnumber of simulations + 1: 1000 \\n\"\n $ res        : num [1:1000] 0.05798 0.09954 0.06943 -0.10422 0.00381 ...\n - attr(*, \"class\")= chr [1:2] \"htest\" \"mc.sim\"\n\n\n\n\n4.4.5.3 Visualising the Monte Carlo Geary’s C\nPlot a histogram to reveal the distribution of the simulated values\n\nmean(bpermg$res[1:999])\n\n[1] 1.004402\n\n\n\nvar(bpermg$res[1:999])\n\n[1] 0.007436493\n\n\n\nsummary(bpermg$res[1:999])\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.7142  0.9502  1.0052  1.0044  1.0595  1.2722 \n\n\n\nhist(bpermg$res,\n     freq= TRUE,\n     breaks=20,\n     xlab='Simulated Geary C')\n\nabline(v=1, col='red')\n\n\n\n\nFor Geary C, 1 means close to randomness. With a Geary C statistic value of 0.6907223, it is highly likely for this value to be more extreme than critical value on the left side. It means high chance we can reject the null hypthesis and conclude that there are signs of clustering. These signs are likely to be real than expected by chance?"
  },
  {
    "objectID": "Hands-on_Ex04/Hands-on_Ex04.html#spatial-correlogram",
    "href": "Hands-on_Ex04/Hands-on_Ex04.html#spatial-correlogram",
    "title": "Hands-on_Ex04",
    "section": "4.5 Spatial Correlogram",
    "text": "4.5 Spatial Correlogram\nSpatial correlograms are great to examine patterns of spatial autocorrelation in your data or model residuals. They show how correlated are pairs of spatial observations when you increase the distance (lag) between them - they are plots of some index of autocorrelation (Moran’s I or Geary’s c) against distance. Although correlograms are not as fundamental as variograms (a keystone concept of geostatistics), they are very useful as an exploratory and descriptive tool. For this purpose they actually provide richer information than variograms.\n\n4.5.1 Compute Moran’s I correlogram\n\nto compute 6-lag (means contiguity order = 6) spatial correlogram of GDPPC, use the sp.correlogram() of the spdep package."
  },
  {
    "objectID": "Hands-on_Ex04/Hands-on_Ex04.html#cluster-and-outlier-analysis",
    "href": "Hands-on_Ex04/Hands-on_Ex04.html#cluster-and-outlier-analysis",
    "title": "Hands-on_Ex04",
    "section": "4.6 Cluster and Outlier Analysis",
    "text": "4.6 Cluster and Outlier Analysis\nLocal Indicators of Spatial Association or LISA are statistics that evaluate the existence of clusters in the spatial arrangement of a given variable. For instance if we are studying cancer rates among census tracts in a given city local clusters in the rates mean that there are areas that have higher or lower rates than is to be expected by chance alone; that is, the values occurring are above or below those of a random distribution in space.\nIn this section, I will apply appropriate Local Indicators for Spatial Association (LISA), especially local Moran’I to detect cluster and/or outlier from GDP per capita 2012 of Hunan Province, PRC.\n\n4.6.1 Computing local Moran’s I\nLISA of an observation gives an indication of the extent of significant spatial clustering of similar values around that observation.\nTo compute local Moran’s I, the localmoran() function of spdep will be used.\n\ncomputes Ii values, given a set of zi values and a listw object providing neighbour weighting information for the polygon associated with the zi values.\n\nThe code chunks below are used to compute local Moran’s I of GDPPC2012 at the county level.\norder(hunan$County) gives 56 10 1 48 70 18 84 … the 56th element is the smallest, followed by 10th element as second smallest… Run order(c(1,5,2,8)) will get output: 1 3 2 4\n\nfips <- order(hunan$County) #by alphabetical order?\nfips\n\n [1] 56 10  1 48 70 18 84 37 24 69 87 38 39 49 11 83 50  2 19 20 21 82 81 64 51\n[26] 26 12 59 88 27  3 52 60 22 34  4 80 71  5 13 65  7 40 53 54 28 66 57  8 61\n[51] 67 23 77 14 75 41 46 79  6 35 62 42 78 85 29  9 43 86 47 68 36 30 44 45 63\n[76] 31 72 15 55 16 73 58 32 76 33 25 74 17\n\n\n\nclass(fips)\n\n[1] \"integer\"\n\n\n\nlocalMI <- localmoran(hunan$GDPPC,rswm_q)\nhead(localMI)\n\n            Ii          E.Ii       Var.Ii        Z.Ii Pr(z != E(Ii))\n1 -0.001468468 -2.815006e-05 4.723841e-04 -0.06626904      0.9471636\n2  0.025878173 -6.061953e-04 1.016664e-02  0.26266425      0.7928094\n3 -0.011987646 -5.366648e-03 1.133362e-01 -0.01966705      0.9843090\n4  0.001022468 -2.404783e-07 5.105969e-06  0.45259801      0.6508382\n5  0.014814881 -6.829362e-05 1.449949e-03  0.39085814      0.6959021\n6 -0.038793829 -3.860263e-04 6.475559e-03 -0.47728835      0.6331568\n\n\n\nclass(localMI)\n\n[1] \"localmoran\" \"matrix\"     \"array\"     \n\n\nlocalmoran() function returns a matrix of values whose columns are:\n\nIi: the local Moran’s I statistics\nE.Ii: the expectation of local moran statistic under the randomisation hypothesis\nVar.Ii: the variance of local moran statistic under the randomisation hypothesis\nZ.Ii:the standard deviate of local moran statistic\nPr(): the p-value of local moran statistic\n\nThe code chunk below list the content of the local Moran matrix derived by using printCoefmat().\nPrint Coefficient Matrices\nUtility function to be used in higher-level print methods, such as those for summary.lm, summary.glm and anova. The goal is to provide a flexible interface with smart defaults such that often, only x needs to be specified.\n\nlocalMI[c(1,2,3,4)]\n\n[1] -0.001468468  0.025878173 -0.011987646  0.001022468\n\n\nFips is an object of integer class. It contains the row ids if rows are to be arranged in alphabetical order.\n\nprintCoefmat(data.frame(\n  localMI[fips,],\n  row.names=hunan$County[fips],\n  check.names = FALSE))\n\n                       Ii        E.Ii      Var.Ii    Z.Ii Pr(z != E(Ii))    \nAnhua         -2.2493e-02 -5.0048e-03  5.8235e-02 -0.0725      0.9422301    \nAnren         -3.9932e-01 -7.0111e-03  7.0348e-02 -1.4791      0.1391057    \nAnxiang       -1.4685e-03 -2.8150e-05  4.7238e-04 -0.0663      0.9471636    \nBaojing        3.4737e-01 -5.0089e-03  8.3636e-02  1.2185      0.2230456    \nChaling        2.0559e-02 -9.6812e-04  2.7711e-02  0.1293      0.8971056    \nChangning     -2.9868e-05 -9.0010e-09  1.5105e-07 -0.0768      0.9387606    \nChangsha       4.9022e+00 -2.1348e-01  2.3194e+00  3.3590      0.0007822 ***\nChengbu        7.3725e-01 -1.0534e-02  2.2132e-01  1.5895      0.1119416    \nChenxi         1.4544e-01 -2.8156e-03  4.7116e-02  0.6830      0.4946117    \nCili           7.3176e-02 -1.6747e-03  4.7902e-02  0.3420      0.7323546    \nDao            2.1420e-01 -2.0824e-03  4.4123e-02  1.0297      0.3031703    \nDongan         1.5210e-01 -6.3485e-04  1.3471e-02  1.3159      0.1881947    \nDongkou        5.2918e-01 -6.4461e-03  1.0748e-01  1.6338      0.1023002    \nFenghuang      1.8013e-01 -6.2832e-03  1.3257e-01  0.5120      0.6086619    \nGuidong       -5.9160e-01 -1.3086e-02  3.7003e-01 -0.9510      0.3415864    \nGuiyang        1.8240e-01 -3.6908e-03  3.2610e-02  1.0305      0.3027630    \nGuzhang        2.8466e-01 -8.5054e-03  1.4152e-01  0.7793      0.4357997    \nHanshou        2.5878e-02 -6.0620e-04  1.0167e-02  0.2627      0.7928094    \nHengdong       9.9964e-03 -4.9063e-04  6.7742e-03  0.1274      0.8986110    \nHengnan        2.8064e-02 -3.2160e-04  3.7597e-03  0.4629      0.6434065    \nHengshan      -5.8201e-03 -3.0437e-05  5.1076e-04 -0.2562      0.7978131    \nHengyang       6.2997e-02 -1.3046e-03  2.1865e-02  0.4349      0.6636633    \nHongjiang      1.8790e-01 -2.3019e-03  3.1725e-02  1.0678      0.2855921    \nHuarong       -1.5389e-02 -1.8667e-03  8.1030e-02 -0.0475      0.9621124    \nHuayuan        8.3772e-02 -8.5569e-04  2.4495e-02  0.5407      0.5887023    \nHuitong        2.5997e-01 -5.2447e-03  1.1077e-01  0.7969      0.4255374    \nJiahe         -1.2431e-01 -3.0550e-03  5.1111e-02 -0.5363      0.5917276    \nJianghua       2.8651e-01 -3.8280e-03  8.0968e-02  1.0204      0.3075618    \nJiangyong      2.4337e-01 -2.7082e-03  1.1746e-01  0.7180      0.4727569    \nJingzhou       1.8270e-01 -8.5106e-04  2.4363e-02  1.1759      0.2396152    \nJinshi        -1.1988e-02 -5.3666e-03  1.1334e-01 -0.0197      0.9843090    \nJishou        -2.8680e-01 -2.6305e-03  4.4028e-02 -1.3543      0.1756424    \nLanshan        6.3334e-02 -9.6365e-04  2.0441e-02  0.4497      0.6529132    \nLeiyang        1.1581e-02 -1.4948e-04  2.5082e-03  0.2342      0.8148123    \nLengshuijiang -1.7903e+00 -8.2129e-02  2.1598e+00 -1.1623      0.2451020    \nLi             1.0225e-03 -2.4048e-07  5.1060e-06  0.4526      0.6508382    \nLianyuan      -1.4672e-01 -1.8983e-03  1.9145e-02 -1.0467      0.2952490    \nLiling         1.3774e+00 -1.5097e-02  4.2601e-01  2.1335      0.0328837 *  \nLinli          1.4815e-02 -6.8294e-05  1.4499e-03  0.3909      0.6959021    \nLinwu         -2.4621e-03 -9.0703e-06  1.9258e-04 -0.1768      0.8596957    \nLinxiang       6.5904e-02 -2.9028e-03  2.5470e-01  0.1363      0.8915545    \nLiuyang        3.3688e+00 -7.7502e-02  1.5180e+00  2.7972      0.0051555 ** \nLonghui        8.0801e-01 -1.1377e-02  1.5538e-01  2.0787      0.0376449 *  \nLongshan       7.5663e-01 -1.1100e-02  3.1449e-01  1.3690      0.1709996    \nLuxi           1.8177e-01 -2.4855e-03  3.4249e-02  0.9956      0.3194403    \nMayang         2.1852e-01 -5.8773e-03  9.8049e-02  0.7166      0.4736044    \nMiluo          1.8704e+00 -1.6927e-02  2.7925e-01  3.5715      0.0003550 ***\nNan           -9.5789e-03 -4.9497e-04  6.8341e-03 -0.1099      0.9125016    \nNingxiang      1.5607e+00 -7.3878e-02  8.0012e-01  1.8274      0.0676458 .  \nNingyuan       2.0910e-01 -7.0884e-03  8.2306e-02  0.7536      0.4511108    \nPingjiang     -9.8964e-01 -2.6457e-03  5.6027e-02 -4.1698      3.049e-05 ***\nQidong         1.1806e-01 -2.1207e-03  2.4747e-02  0.7640      0.4448892    \nQiyang         6.1966e-02 -7.3374e-04  8.5743e-03  0.6771      0.4983276    \nRucheng       -3.6992e-01 -8.8999e-03  2.5272e-01 -0.7181      0.4726740    \nSangzhi        2.5053e-01 -4.9470e-03  6.8000e-02  0.9797      0.3272227    \nShaodong      -3.2659e-02 -3.6592e-05  5.0546e-04 -1.4510      0.1467765    \nShaoshan       2.1223e+00 -5.0227e-02  1.3668e+00  1.8583      0.0631298 .  \nShaoyang       5.9499e-01 -1.1253e-02  1.3012e-01  1.6807      0.0928305 .  \nShimen        -3.8794e-02 -3.8603e-04  6.4756e-03 -0.4773      0.6331568    \nShuangfeng     9.2835e-03 -2.2867e-03  3.1516e-02  0.0652      0.9480354    \nShuangpai      8.0591e-02 -3.1366e-04  8.9838e-03  0.8536      0.3933400    \nSuining        3.7585e-01 -3.5933e-03  4.1870e-02  1.8544      0.0636875 .  \nTaojiang      -2.5394e-01 -1.2395e-03  1.4477e-02 -2.1002      0.0357113 *  \nTaoyuan        1.4729e-02 -1.2039e-04  8.5103e-04  0.5090      0.6107279    \nTongdao        4.6482e-01 -6.9870e-03  1.9879e-01  1.0582      0.2899569    \nWangcheng      4.4220e+00 -1.1067e-01  1.3596e+00  3.8873      0.0001014 ***\nWugang         7.1003e-01 -7.8144e-03  1.0710e-01  2.1935      0.0282749 *  \nXiangtan       2.4530e-01 -3.6457e-04  3.2319e-03  4.3213      1.551e-05 ***\nXiangxiang     2.6271e-01 -1.2703e-03  2.1290e-02  1.8092      0.0704213 .  \nXiangyin       5.4525e-01 -4.7442e-03  7.9236e-02  1.9539      0.0507157 .  \nXinhua         1.1810e-01 -6.2649e-03  8.6001e-02  0.4241      0.6715036    \nXinhuang       1.5725e-01 -4.1820e-03  3.6648e-01  0.2667      0.7897221    \nXinning        6.8928e-01 -9.6674e-03  2.0328e-01  1.5502      0.1210854    \nXinshao        5.7578e-02 -8.5932e-03  1.1769e-01  0.1929      0.8470456    \nXintian       -7.4050e-03 -5.1493e-03  1.0877e-01 -0.0068      0.9945429    \nXupu           3.2406e-01 -5.7468e-03  5.7735e-02  1.3726      0.1698803    \nYanling       -6.9021e-02 -5.9211e-04  9.9306e-03 -0.6867      0.4922880    \nYizhang       -2.6844e-01 -2.2463e-03  4.7588e-02 -1.2202      0.2223756    \nYongshun       6.3064e-01 -1.1350e-02  1.8830e-01  1.4795      0.1390190    \nYongxing       4.3411e-01 -9.0735e-03  1.5088e-01  1.1409      0.2538993    \nYou            7.8750e-02 -7.2728e-03  1.2116e-01  0.2471      0.8048036    \nYuanjiang      2.0004e-04 -1.7760e-04  2.9798e-03  0.0069      0.9944802    \nYuanling       8.7298e-03 -2.2981e-06  2.3221e-05  1.8121      0.0699726 .  \nYueyang        4.1189e-02 -1.9768e-04  2.3113e-03  0.8608      0.3893219    \nZhijiang       1.0476e-01 -7.8123e-04  1.3100e-02  0.9221      0.3564539    \nZhongfang     -2.2685e-01 -2.1455e-03  3.5927e-02 -1.1855      0.2358293    \nZhuzhou        3.2864e-01 -5.2432e-04  7.2391e-03  3.8688      0.0001094 ***\nZixing        -7.6849e-01 -8.8210e-02  9.4057e-01 -0.7014      0.4830289    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nYiXin’s prac , filter only those p-value < 0.05\n\nxyz <- data.frame(\n  localMI[fips,],\n  row.names=hunan$County[fips],\n  check.names = FALSE)\n\nxyz %>% \n    filter(`Pr(z != E(Ii))`<=0.05)\n\n                  Ii          E.Ii      Var.Ii      Z.Ii Pr(z != E(Ii))\nChangsha   4.9022015 -0.2134796356 2.319446791  3.359010   7.822232e-04\nLiling     1.3774283 -0.0150967924 0.426010680  2.133501   3.288368e-02\nLiuyang    3.3688217 -0.0775018462 1.518028327  2.797152   5.155523e-03\nLonghui    0.8080051 -0.0113773401 0.155377915  2.078701   3.764485e-02\nMiluo      1.8703719 -0.0169268635 0.279248204  3.571457   3.550005e-04\nPingjiang -0.9896383 -0.0026457393 0.056027187 -4.169793   3.048768e-05\nTaojiang  -0.2539369 -0.0012394888 0.014477052 -2.100200   3.571125e-02\nWangcheng  4.4219586 -0.1106694416 1.359593011  3.887278   1.013746e-04\nWugang     0.7100317 -0.0078144096 0.107104342  2.193450   2.827494e-02\nXiangtan   0.2453007 -0.0003645745 0.003231947  4.321273   1.551317e-05\nZhuzhou    0.3286415 -0.0005243157 0.007239075  3.868772   1.093847e-04\n\n\n\n4.6.1.1 Mapping the local Moran’s I\n\nappend the local Moran’s I dataframe (i.e. localMI) onto hunan SpatialPolygonDataFrame\n\n\nhunan.localMI <- cbind(hunan,localMI)%>%\n  rename(Pr.Ii = Pr.z....E.Ii..)  \n#rename the last column \n#colnames(bperm.df)[1] <- 'res'\nhead(hunan.localMI)\n\nSimple feature collection with 6 features and 11 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 110.4922 ymin: 28.61762 xmax: 112.3013 ymax: 30.12812\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3  County GDPPC           Ii          E.Ii\n1 Changde 21098 Anxiang      County Anxiang 23667 -0.001468468 -2.815006e-05\n2 Changde 21100 Hanshou      County Hanshou 20981  0.025878173 -6.061953e-04\n3 Changde 21101  Jinshi County City  Jinshi 34592 -0.011987646 -5.366648e-03\n4 Changde 21102      Li      County      Li 24473  0.001022468 -2.404783e-07\n5 Changde 21103   Linli      County   Linli 25554  0.014814881 -6.829362e-05\n6 Changde 21104  Shimen      County  Shimen 27137 -0.038793829 -3.860263e-04\n        Var.Ii        Z.Ii     Pr.Ii                       geometry\n1 4.723841e-04 -0.06626904 0.9471636 POLYGON ((112.0625 29.75523...\n2 1.016664e-02  0.26266425 0.7928094 POLYGON ((112.2288 29.11684...\n3 1.133362e-01 -0.01966705 0.9843090 POLYGON ((111.8927 29.6013,...\n4 5.105969e-06  0.45259801 0.6508382 POLYGON ((111.3731 29.94649...\n5 1.449949e-03  0.39085814 0.6959021 POLYGON ((111.6324 29.76288...\n6 6.475559e-03 -0.47728835 0.6331568 POLYGON ((110.8825 30.11675...\n\n\n\n\n4.6.1.2 Mapping local Moran’s I values\nUse the choropleth mapping functions of tmap package to plot local Moran’s I values.\nWhen the variable provided as the col argument is numeric, tmap will use the \"pretty\" style as a default. In other words, it runs tm_polygons(col = \"colname\", style = \"pretty\") invisibly to the user. This style rounds breaks into whole numbers where possible and spaces them evenly.\n\ntm_shape(hunan.localMI)+\n  tm_fill(col='Ii',\n          style=\"pretty\",\n          palette = \"RdBu\",\n          title = \"local Moran statistics\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Local Moran' I statistic\",\n            main.title.size=0.8,\n            legend.height = 0.2,\n            legend.width = 0.2)\n\nVariable(s) \"Ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\n\n\n4.6.1.3 Mapping local Moran’s I p-values\n\nmore meaningful to set our own breaks (alpha = 0.001, 0.01, 0.05, 0.1 etc) instead of using ‘style’\ninverse the color scheme for smaller p-values to have darker blue\n\n\ntm_shape(hunan.localMI)+\n  tm_fill(col='Pr.Ii',\n          breaks = c(-Inf,0.001,0.01,0.05,0.1,Inf),\n          palette = \"-Blues\",\n          title = \"local Moran statistics\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Local Moran' p-values\",\n            main.title.size=0.8,\n            legend.height = 0.2,\n            legend.width = 0.2) +\n  tm_text('County', size = 0.3)\n\nLegend labels were too wide. The labels have been resized to 0.44, 0.48, 0.48, 0.48, 0.50. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger.\n\n\n\n\n\n\n\n4.6.1.4 Mapping both local Moran’s I values and p-values\n\nlocalMI.map <- tm_shape(hunan.localMI)+\n  tm_fill(col='Ii',\n          style=\"pretty\",\n          palette = \"RdBu\",\n          title = \"local Moran statistics\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Local Moran' I statistic\",\n            main.title.size=0.8,\n            legend.height = 0.2,\n            legend.width = 0.2)\n\npvalue.map <- tm_shape(hunan.localMI)+\n  tm_fill(col='Pr.Ii',\n          breaks = c(-Inf,0.001,0.01,0.05,0.1,Inf),\n          palette = \"-Blues\",\n          title = \"local Moran statistics\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Local Moran' p-values\",\n            main.title.size=0.8,\n            legend.height = 0.2,\n            legend.width = 0.2) +\n  tm_text('County', size = 0.3)\n\ntmap_arrange(localMI.map, pvalue.map, asp=1, ncol=2)\n\nVariable(s) \"Ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\nLegend labels were too wide. The labels have been resized to 0.35, 0.39, 0.39, 0.39, 0.40. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger."
  },
  {
    "objectID": "Hands-on_Ex04/Hands-on_Ex04.html#creating-a-lisa-cluster-map",
    "href": "Hands-on_Ex04/Hands-on_Ex04.html#creating-a-lisa-cluster-map",
    "title": "Hands-on_Ex04",
    "section": "4.7 Creating a LISA Cluster Map",
    "text": "4.7 Creating a LISA Cluster Map\nThe LISA Cluster Map shows the significant locations color coded by type of spatial autocorrelation. The first step before we can generate the LISA cluster map is to plot the Moran scatterplot.\n\n4.7.1 Plotting Moran scatterplot\nThe Moran scatterplot is an illustration of the relationship between the values of the chosen attribute at each location and the average value of the same attribute at neighboring locations.\n\nplots the Moran scatterplot of GDPPC 2012 by using moran.plot() of spdep.\n\n\nnci <- moran.plot(hunan$GDPPC,\n                  rswm_q,\n                  labels=as.character(hunan$County),\n                  xlab = \"GDPPC 2012\",\n                  ylab=\"Spatially Lag GDPPC 2012\")\n\n\n\n\nLengshuijiang is in HL quad. “I am a high outlier among low neighbours”\nXiangtan is in LH quad. “I am a low outlier among high neighbours”\nChangsha is in the HH quad\n\n\n4.7.2 Plotting Moran scatterplot with standardised variable\nFirst we will use scale() to centers and scales the variable. Explaining how to scale() function works:\nHere centering is done by subtracting the mean (omitting NAs) the corresponding columns, and scaling is done by dividing the (centered) variable by their standard deviations.\nThe standardised values of GDPPC values have mean of 0 and sd of 1?\n\n#adds a new column in hunan sf dataframe\nhunan$Z.GDPPC <- scale(hunan$GDPPC) %>% \n  as.vector\n\nThe as.vector() added to the end is to make sure that the data type we get out of this is a vector, that map neatly into our dataframe.\nYixin’s observation: without as.vector(), the [‘Z.GDPPC’] column in slotted between [‘GDPPC’] col and [‘geometry’] column. After as.vector(), this variable is after [‘geo’] col!\nNow, plot the Moran scatterplot again by using the code chunk below.\n\nnci2 <- moran.plot(hunan$Z.GDPPC,\n                   rswm_q,\n                   labels=as.character(hunan$County),\n                   xlab = \"GDPPC 2012\",\n                   ylab=\"Spatially Lag z-GDPPC 2012\")\n\n\n\n\n\n\n4.7.3 Preparing LISA map classes\n1. vector(mode=? , length = ? ) is to create a vector (alternative1: a <-c(1,2,3)) (alternative2: series <- 1:10)\n2. mode = ‘numeric’, ‘character’, ‘integer’, ‘logical’\n3. typeof(a) to see datatype of elements inside. Other ways of examining : (class(a), length(a), str(a), attributes(a))\n4. other special values : -Inf, Inf\n5. https://swcarpentry.github.io/r-novice-inflammation/13-supp-data-structures/#:~:text=R’s%20basic%20data%20structures%20include,name%2C%20dimension%2C%20and%20class.\n\nquadrant <- vector(mode = \"numeric\", length = nrow(localMI))\nquadrant\n\n [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[39] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[77] 0 0 0 0 0 0 0 0 0 0 0 0\n\n\n\nnext, derive the lagged variable of interest (GDPPC) and center the spatially lagged variable around its mean\n\n\nhunan$lag_GDPPC <- lag.listw(rswm_q, hunan$GDPPC)\nDV <- hunan$lag_GDPPC - mean(hunan$lag_GDPPC)\nclass(DV)\n\n[1] \"numeric\"\n\n\n\ncenter the local Moran’s around the mean\nthe first col [ , 1] of the localMI matrix contains LocalMoran’s I values\n\n\nLM_I <- localMI[,1] - mean(localMI[,1])\nclass(LM_I)\n\n[1] \"numeric\"\n\n\n\nNext, we will set a statistical significance level for the local Moran.\n\n\nsignif <- 0.05\n\n\nThese four command lines define the low-low (1), low-high (2), high-low (3) and high-high (4) categories.\nHere, are we using filters? Using DV and LM_I vectors to assign value of 1 to quadrant vector (init as all 0)\nDV < 0 means GDPPC spatial lag is lower than mean.; spatial lag is low?\nLM_I < 0 means Local Moran I value is less than mean. LISA of an observation gives an indication of the extent of significant spatial clustering of similar values around that observation. When LM_I > 0 means clustering of HH or LL values. When LM_I < 0 means dispersion of HL or LH values.\n\n\nquadrant[DV < 0 & LM_I > 0] <- 1 # low-low\nquadrant\n\n [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 0\n[39] 1 1 0 1 1 1 0 0 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[77] 0 0 1 0 0 0 0 0 0 0 0 0\n\n\n\nquadrant[DV > 0 & LM_I < 0] <- 2 # low- high\nquadrant[DV < 0 & LM_I < 0] <- 3 # high- low\nquadrant[DV > 0 & LM_I > 0] <- 4 # high-high\nquadrant\n\n [1] 2 3 3 2 2 3 4 4 4 2 2 3 2 2 2 4 3 3 2 3 3 2 3 3 3 3 3 3 1 3 1 3 3 3 3 3 1 3\n[39] 1 1 3 1 1 1 3 4 2 1 3 3 3 3 1 3 1 2 2 2 3 3 3 3 2 3 2 4 2 4 3 3 4 2 2 4 3 2\n[77] 3 2 1 2 3 3 2 4 3 2 3 3\n\n\n\nlastly, place non-significant Moran in the category 0\n\n\nquadrant[localMI[,5]>signif] <- 0\nquadrant\n\n [1] 0 0 0 0 0 0 4 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[39] 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 2 0 0 0 4 0 0 4 0 0\n[77] 0 2 0 0 0 0 0 4 0 2 0 0\n\n\nCombining all together\n\nquadrant <- vector(mode=\"numeric\",length=nrow(localMI))\nhunan$lag_GDPPC <- lag.listw(rswm_q, hunan$GDPPC)\nDV <- hunan$lag_GDPPC - mean(hunan$lag_GDPPC)     \nLM_I <- localMI[,1]   \nsignif <- 0.05       \nquadrant[DV <0 & LM_I>0] <- 1\nquadrant[DV >0 & LM_I<0] <- 2\nquadrant[DV <0 & LM_I<0] <- 3  \nquadrant[DV >0 & LM_I>0] <- 4    \nquadrant[localMI[,5]>signif] <- 0\n\n\n\n4.7.4 Plotting LISA map\n\nnow we build the LISA map by using the code chunks below.\n\n{r} # plus 1 because the indexing in R starts from 1.} c(sort(unique(quadrant)))+1\n\nNow we build LISA map\n\npopup.vars\nnames of data variables that are shown in the popups in \"view\" mode. If convert2density=TRUE, the derived density variable name is suffixed with _density. If NA (default), only aesthetic variables (i.e. specified by col and lwd) are shown). If they are not specified, all variables are shown. Set popup.vars to FALSE to disable popups. When a vector of variable names is provided, the names (if specified) are printed in the popups.\n\nhunan.localMI$quadrant <- quadrant\ncolours <- c(\"#ffffff\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters <- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\ntm_shape(hunan.localMI) +\n  tm_fill(col = 'quadrant',\n          palette= colours[c(sort(unique(quadrant))) + 1],\n          labels = clusters[c(sort(unique(quadrant))) + 1],\n          popups.var = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.height = 0.2,\n            legend.width = 0.2)\n\nSome legend labels were too wide. These labels have been resized to 0.62. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger.\n\n\n\n\n\n\nFor effective visualisation, its better to plot both the local Moran’s I values map and its corresponding p-values next to each other\n\n\ngdppc <- qtm(hunan, 'GDPPC')\n\nhunan.localMI$quadrant <- quadrant\ncolours <- c(\"#ffffff\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters <- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\nLISAmap <- tm_shape(hunan.localMI) +\n  tm_fill(col = 'quadrant',\n          palette= colours[c(sort(unique(quadrant))) + 1],\n          labels = clusters[c(sort(unique(quadrant))) + 1],\n          popups.var = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.height = 0.2,\n            legend.width = 0.2)\n\ntmap_arrange(gdppc, LISAmap, \n             asp = 1, ncol =2)\n\nSome legend labels were too wide. These labels have been resized to 0.46. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger.\n\n\n\n\n\n\nQuadrant has removed all insignificant regions, thus hunan.localMI and hence LISA map do not include p > 0.05\nThe red regions have high GDPCC surrounded regions of by high GDPCC around me (spatial lag gdppc) The dark blue regions have low GDPCC and has low spatial lag (surrounding) gdppc values.\ncan also include the local Moran’s I map and p-value map as shown below for easy comparison.\n\n\ntmap_arrange(localMI.map, pvalue.map, asp=1, ncol=2)\n\nVariable(s) \"Ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\nLegend labels were too wide. The labels have been resized to 0.35, 0.39, 0.39, 0.39, 0.40. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger.\n\n\n\n\n\nThis seems like local MI prior to removing P-values > 0.05"
  },
  {
    "objectID": "Hands-on_Ex04/Hands-on_Ex04.html#hot-spot-and-cold-spot-area-analysis",
    "href": "Hands-on_Ex04/Hands-on_Ex04.html#hot-spot-and-cold-spot-area-analysis",
    "title": "Hands-on_Ex04",
    "section": "4.8 Hot Spot and Cold Spot Area Analysis",
    "text": "4.8 Hot Spot and Cold Spot Area Analysis\nBeside detecting cluster and outliers, localised spatial statistics can be also used to detect hot spot and/or cold spot areas.\n\nThe term ‘hot spot’ has been used generically across disciplines to describe a region or value that is higher relative to its surroundings (Lepers et al 2005, Aben et al 2012, Isobe et al 2015).\n\n4.8.1 Getis and Ord’s G-Statistics\nAn alternative spatial statistics to detect spatial anomalies is the Getis and Ord’s G-statistics (Getis and Ord, 1972; Ord and Getis, 1995).\n\nlooks at neighbours within a defined proximity to identify where either high or low values clutser spatially\nstatistically significant hot-spots are recognised as areas of high values where where other areas within a neighbourhood range also share high values too.\n\nThe analysis consists three steps\n\nDeriving spatial weight matrix\nComputing Gi statistics\nMapping Gi statistics\n\n\n\n4.8.2 Deriving distance-based weight matrix\n\nWe need to define a new set of neighbours using DISTANCE. (earlier, spatial autocorrelation considered units that shared boundaries / contiguous concept)\nThere are two type of distance-based proximity matrix, they are:\n\nfixed distance weight matrix; and\nadaptive distance weight matrix\n\n\n\n4.8.2.1 Deriving the centroid\n\nneed points (x,y) to associate with each polygon in order to make connectivity graphs\nneed these coordinates in a separate data frame , to do this:\n\nUse a mapping function (map_dbl() from the purrr package) to apply a centroid function (st_centroid() ) on each element of a vector and returns another vector of the same length\ninput vector is the geometry column of us.bound\n\nTo get longitude values:\n\nmap the st_centroid() function over the geometry column of us.bound\nafter st_centroid() function is applied, access the longitude values by using double bracket notation [[ ]] and 1.\nto access the latitude values, use [[ ]] and 2.\n\n\nOthers: the map_dbl() outputs double vectors; decimals allowed while map_int() outputs integer vectors.\n\nst_geometry(hunan)\n\nGeometry set for 88 features \nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n\n\nPOLYGON ((112.0625 29.75523, 112.069 29.74544, ...\n\n\nPOLYGON ((112.2288 29.11684, 112.2339 29.11214,...\n\n\nPOLYGON ((111.8927 29.6013, 111.8906 29.59811, ...\n\n\nPOLYGON ((111.3731 29.94649, 111.3737 29.94167,...\n\n\nPOLYGON ((111.6324 29.76288, 111.6312 29.75165,...\n\n\n\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n\n\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n\nCombine the two vectors using cbind\n\ncoords <- cbind(longitude, latitude)\n\n\nhead(coords)\n\n     longitude latitude\n[1,]  112.1531 29.44362\n[2,]  112.0372 28.86489\n[3,]  111.8917 29.47107\n[4,]  111.7031 29.74499\n[5,]  111.6138 29.49258\n[6,]  111.0341 29.79863\n\n\n\n\n4.8.2.2 Determine the cut-off distance\n\nfind my nearest neighbour array ID within coords, and their corresponding (x,y) coordinates using knearneigh() of spdep.\nmynearestneighbour <- knearneigh(coords , k =1)\n\n\nmynearestneighbour <- knearneigh(coords)\n\n\nknearneigh(coords)$nn [1:5]\n\n[1]  3 78  1  5  4\n\n\nNearest neighbour of polygon 1 is polygon 3 etc…\n\nknearneigh(coords)$x [1:5,]\n\n     longitude latitude\n[1,]  112.1531 29.44362\n[2,]  112.0372 28.86489\n[3,]  111.8917 29.47107\n[4,]  111.7031 29.74499\n[5,]  111.6138 29.49258\n\n\n\nConvert the knn object to neighbours list of nb class using knn2nb().\n\n\nk1 <- knn2nb(knearneigh(coords))\nk1\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 88 \nPercentage nonzero weights: 1.136364 \nAverage number of links: 1 \nNon-symmetric neighbours list\n\n\n\nreturn the length of neighbour relationship edges using nbdists() of spdep. The function returns in the units of the coordinates if the coordinates are projected, in km otherwise.\nremove the list structure of the returned object using unlist()\n\n\nk1dists <- unlist(nbdists(k1, coords, longlat=TRUE))\nhead(k1dists)\n\n[1] 25.53398 43.03114 25.53398 29.28480 29.28480 45.98097\n\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\n\nhunan dataset is unprojected dataset\nIf unprojected coordinates are used and either specified in the coordinates object x or with x as a two column matrix and longlat=TRUE, great circle distances in km will be calculated assuming the WGS84 reference ellipsoid.\n\nThe summary report shows that the largest first nearest neighbour distance is 61.79 km, so using this as the upper threshold gives certainty that all units will have at least one neighbour.\nCodes can be combined as shown below\n\n#coords <- coordinates(hunan)\nk1 <- knn2nb(knearneigh(coords))\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\n\n\n4.8.2.3 Computing fixed distance weight matrix\n\nNow we have all the neighbour distances, we can compute the nieghbour list of class nb by using dnearneigh() that requires us to indicate the distance threshold. The output is first a neighbour list of nb class.\n\n\nwm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)\nsummary(wm_d62)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \nLink number distribution:\n\n 1  2  3  4  5  6 \n 6 15 14 26 20  7 \n6 least connected regions:\n6 15 30 32 56 65 with 1 link\n7 most connected regions:\n21 28 35 45 50 52 82 with 6 links\n\n\nI can see my neighbours list using str()\n\n#str(wm_d62)\nwm_d62[1:5]\n\n[[1]]\n[1]  3  4  5 57 64\n\n[[2]]\n[1] 57 58 78 85\n\n[[3]]\n[1]  1  4  5 57\n\n[[4]]\n[1] 1 3 5\n\n[[5]]\n[1]  1  3  4 85\n\n\n\nTo create our spatial distance weight matrix, to convert nb object to spatial weight object wm62_lw: use nb2listw() , where the input arugment is a neighbour list of nb class.\nin the case below, we are using binary weight. So the spatial weight matrix will contain only 1 or 0.\n\n\nwm62_lw <- nb2listw(wm_d62, style= \"B\")\nsummary(wm62_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \nLink number distribution:\n\n 1  2  3  4  5  6 \n 6 15 14 26 20  7 \n6 least connected regions:\n6 15 30 32 56 65 with 1 link\n7 most connected regions:\n21 28 35 45 50 52 82 with 6 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1   S2\nB 88 7744 324 648 5440\n\n\n\nstr(wm62_lw)\n\nList of 3\n $ style     : chr \"B\"\n $ neighbours:List of 88\n  ..$ : int [1:5] 3 4 5 57 64\n  ..$ : int [1:4] 57 58 78 85\n  ..$ : int [1:4] 1 4 5 57\n  ..$ : int [1:3] 1 3 5\n  ..$ : int [1:4] 1 3 4 85\n  ..$ : int 69\n  ..$ : int [1:2] 67 84\n  ..$ : int [1:4] 9 46 47 78\n  ..$ : int [1:4] 8 46 68 84\n  ..$ : int [1:4] 16 22 70 72\n  ..$ : int [1:3] 14 17 72\n  ..$ : int [1:5] 13 60 61 63 83\n  ..$ : int [1:4] 12 15 60 83\n  ..$ : int [1:2] 11 17\n  ..$ : int 13\n  ..$ : int [1:4] 10 17 22 83\n  ..$ : int [1:3] 11 14 16\n  ..$ : int [1:3] 20 22 63\n  ..$ : int [1:5] 20 21 73 74 82\n  ..$ : int [1:5] 18 19 21 22 82\n  ..$ : int [1:6] 19 20 35 74 82 86\n  ..$ : int [1:4] 10 16 18 20\n  ..$ : int [1:3] 41 77 82\n  ..$ : int [1:4] 25 28 31 54\n  ..$ : int [1:4] 24 28 33 81\n  ..$ : int [1:4] 27 33 42 81\n  ..$ : int [1:2] 26 29\n  ..$ : int [1:6] 24 25 33 49 52 54\n  ..$ : int [1:2] 27 37\n  ..$ : int 33\n  ..$ : int [1:2] 24 36\n  ..$ : int 50\n  ..$ : int [1:5] 25 26 28 30 81\n  ..$ : int [1:3] 36 45 80\n  ..$ : int [1:6] 21 41 46 47 80 82\n  ..$ : int [1:5] 31 34 45 56 80\n  ..$ : int [1:2] 29 42\n  ..$ : int [1:3] 44 77 79\n  ..$ : int [1:4] 40 42 43 81\n  ..$ : int [1:3] 39 45 79\n  ..$ : int [1:5] 23 35 45 79 82\n  ..$ : int [1:5] 26 37 39 43 81\n  ..$ : int [1:3] 39 42 44\n  ..$ : int [1:2] 38 43\n  ..$ : int [1:6] 34 36 40 41 79 80\n  ..$ : int [1:5] 8 9 35 47 86\n  ..$ : int [1:5] 8 35 46 80 86\n  ..$ : int [1:5] 50 51 52 53 55\n  ..$ : int [1:4] 28 51 52 54\n  ..$ : int [1:6] 32 48 51 52 54 55\n  ..$ : int [1:4] 48 49 50 52\n  ..$ : int [1:6] 28 48 49 50 51 54\n  ..$ : int [1:2] 48 55\n  ..$ : int [1:5] 24 28 49 50 52\n  ..$ : int [1:4] 48 50 53 75\n  ..$ : int 36\n  ..$ : int [1:5] 1 2 3 58 64\n  ..$ : int [1:5] 2 57 64 66 68\n  ..$ : int [1:3] 60 87 88\n  ..$ : int [1:4] 12 13 59 61\n  ..$ : int [1:5] 12 60 62 63 87\n  ..$ : int [1:4] 61 63 77 87\n  ..$ : int [1:5] 12 18 61 62 83\n  ..$ : int [1:4] 1 57 58 76\n  ..$ : int 76\n  ..$ : int [1:5] 58 67 68 76 84\n  ..$ : int [1:2] 7 66\n  ..$ : int [1:4] 9 58 66 84\n  ..$ : int [1:2] 6 75\n  ..$ : int [1:3] 10 72 73\n  ..$ : int [1:2] 73 74\n  ..$ : int [1:3] 10 11 70\n  ..$ : int [1:4] 19 70 71 74\n  ..$ : int [1:5] 19 21 71 73 86\n  ..$ : int [1:2] 55 69\n  ..$ : int [1:3] 64 65 66\n  ..$ : int [1:3] 23 38 62\n  ..$ : int [1:2] 2 8\n  ..$ : int [1:4] 38 40 41 45\n  ..$ : int [1:5] 34 35 36 45 47\n  ..$ : int [1:5] 25 26 33 39 42\n  ..$ : int [1:6] 19 20 21 23 35 41\n  ..$ : int [1:4] 12 13 16 63\n  ..$ : int [1:4] 7 9 66 68\n  ..$ : int [1:2] 2 5\n  ..$ : int [1:4] 21 46 47 74\n  ..$ : int [1:4] 59 61 62 88\n  ..$ : int [1:2] 59 87\n  ..- attr(*, \"class\")= chr \"nb\"\n  ..- attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n  ..- attr(*, \"call\")= language dnearneigh(x = coords, d1 = 0, d2 = 62, longlat = TRUE)\n  ..- attr(*, \"dnn\")= num [1:2] 0 62\n  ..- attr(*, \"bounds\")= chr [1:2] \"GE\" \"LE\"\n  ..- attr(*, \"nbtype\")= chr \"distance\"\n  ..- attr(*, \"sym\")= logi TRUE\n $ weights   :List of 88\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:3] 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num 1\n  ..$ : num [1:2] 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:3] 1 1 1\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:2] 1 1\n  ..$ : num 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:3] 1 1 1\n  ..$ : num [1:3] 1 1 1\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:6] 1 1 1 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:3] 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:2] 1 1\n  ..$ : num [1:6] 1 1 1 1 1 1\n  ..$ : num [1:2] 1 1\n  ..$ : num 1\n  ..$ : num [1:2] 1 1\n  ..$ : num 1\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:3] 1 1 1\n  ..$ : num [1:6] 1 1 1 1 1 1\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:2] 1 1\n  ..$ : num [1:3] 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:3] 1 1 1\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:3] 1 1 1\n  ..$ : num [1:2] 1 1\n  ..$ : num [1:6] 1 1 1 1 1 1\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:6] 1 1 1 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:6] 1 1 1 1 1 1\n  ..$ : num [1:2] 1 1\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num 1\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:3] 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num 1\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:2] 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:2] 1 1\n  ..$ : num [1:3] 1 1 1\n  ..$ : num [1:2] 1 1\n  ..$ : num [1:3] 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:2] 1 1\n  ..$ : num [1:3] 1 1 1\n  ..$ : num [1:3] 1 1 1\n  ..$ : num [1:2] 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:5] 1 1 1 1 1\n  ..$ : num [1:6] 1 1 1 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:2] 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:4] 1 1 1 1\n  ..$ : num [1:2] 1 1\n  ..- attr(*, \"mode\")= chr \"binary\"\n  ..- attr(*, \"B\")= logi TRUE\n - attr(*, \"class\")= chr [1:2] \"listw\" \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language nb2listw(neighbours = wm_d62, style = \"B\")\n\nwm62_lw$neighbours[1:5]\n\n[[1]]\n[1]  3  4  5 57 64\n\n[[2]]\n[1] 57 58 78 85\n\n[[3]]\n[1]  1  4  5 57\n\n[[4]]\n[1] 1 3 5\n\n[[5]]\n[1]  1  3  4 85\n\n\n\nwm62_lw$weights[1:5]\n\n[[1]]\n[1] 1 1 1 1 1\n\n[[2]]\n[1] 1 1 1 1\n\n[[3]]\n[1] 1 1 1 1\n\n[[4]]\n[1] 1 1 1\n\n[[5]]\n[1] 1 1 1 1\n\n\n\n\n\n4.8.3 Computing adaptive distance weight matrix\nHaving many neighbours smoothes the neighbour relationship across more neighbours. Therefore less densely populated regions have less neighbours. Regions with bigger area will also have less neighbours. So, we might want to CONTROL the number of neighbours using knearneigh() indicating k.\nWe can either accept asymmetric neighbours or impose symmetry.\n\nTo create our neighbours list of class nb based on 8 nearest neighbours:\n\n\nknn <- knn2nb(knearneigh(coords, k=8))\nknn\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\n\n#knn[1:5]\n\n\nTo convert our nb object to spatial weight object with binary weights:\n\n\nknn_lw <- nb2listw(knn, style = \"B\")\nsummary(knn_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\nLink number distribution:\n\n 8 \n88 \n88 least connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n88 most connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0   S1    S2\nB 88 7744 704 1300 23014\n\n\nAll of them are equal in number of connections (above) 8 neighbours, thus 8 binary weights (below).\n\n#str(knn_lw)\n#knn_lw$neighbours[1:10]\nknn_lw$weights[1:5]\n\n[[1]]\n[1] 1 1 1 1 1 1 1 1\n\n[[2]]\n[1] 1 1 1 1 1 1 1 1\n\n[[3]]\n[1] 1 1 1 1 1 1 1 1\n\n[[4]]\n[1] 1 1 1 1 1 1 1 1\n\n[[5]]\n[1] 1 1 1 1 1 1 1 1"
  },
  {
    "objectID": "Hands-on_Ex04/Hands-on_Ex04.html#computing-gi-statistics",
    "href": "Hands-on_Ex04/Hands-on_Ex04.html#computing-gi-statistics",
    "title": "Hands-on_Ex04",
    "section": "4.9 Computing Gi statistics",
    "text": "4.9 Computing Gi statistics\n\n4.9.1 Gi statistics using fixed distance\n\nfips <- order(hunan$County) #by alphabetical order?\ngi.fixed <- localG(hunan$GDPPC, wm62_lw)\ngi.fixed\n\n [1]  0.436075843 -0.265505650 -0.073033665  0.413017033  0.273070579\n [6] -0.377510776  2.863898821  2.794350420  5.216125401  0.228236603\n[11]  0.951035346 -0.536334231  0.176761556  1.195564020 -0.033020610\n[16]  1.378081093 -0.585756761 -0.419680565  0.258805141  0.012056111\n[21] -0.145716531 -0.027158687 -0.318615290 -0.748946051 -0.961700582\n[26] -0.796851342 -1.033949773 -0.460979158 -0.885240161 -0.266671512\n[31] -0.886168613 -0.855476971 -0.922143185 -1.162328599  0.735582222\n[36] -0.003358489 -0.967459309 -1.259299080 -1.452256513 -1.540671121\n[41] -1.395011407 -1.681505286 -1.314110709 -0.767944457 -0.192889342\n[46]  2.720804542  1.809191360 -1.218469473 -0.511984469 -0.834546363\n[51] -0.908179070 -1.541081516 -1.192199867 -1.075080164 -1.631075961\n[56] -0.743472246  0.418842387  0.832943753 -0.710289083 -0.449718820\n[61] -0.493238743 -1.083386776  0.042979051  0.008596093  0.136337469\n[66]  2.203411744  2.690329952  4.453703219 -0.340842743 -0.129318589\n[71]  0.737806634 -1.246912658  0.666667559  1.088613505 -0.985792573\n[76]  1.233609606 -0.487196415  1.626174042 -1.060416797  0.425361422\n[81] -0.837897118 -0.314565243  0.371456331  4.424392623 -0.109566928\n[86]  1.364597995 -1.029658605 -0.718000620\nattr(,\"cluster\")\n [1] Low  Low  High High High High High High High Low  Low  High Low  Low  Low \n[16] High High High High Low  High High Low  Low  High Low  Low  Low  Low  Low \n[31] Low  Low  Low  High Low  Low  Low  Low  Low  Low  High Low  Low  Low  Low \n[46] High High Low  Low  Low  Low  High Low  Low  Low  Low  Low  High Low  Low \n[61] Low  Low  Low  High High High Low  High Low  Low  High Low  High High Low \n[76] High Low  Low  Low  Low  Low  Low  High High Low  High Low  Low \nLevels: Low High\nattr(,\"gstari\")\n[1] FALSE\nattr(,\"call\")\nlocalG(x = hunan$GDPPC, listw = wm62_lw)\nattr(,\"class\")\n[1] \"localG\"\n\n\nThe output of localG() is a vector of G or Gstar values, with attributes “gstari” set to TRUE or FALSE, “call” set to the function call, and class “localG”.\nThe Gi statistics is represented as a Z-score. Greater values represent a greater intensity of clustering and the direction (positive or negative) indicates high or low clusters\n\nNext, join the Gi values to their corresponding hunan sf data frame.\nas.matrix(gi.fixed) will aligned the Gi values into a single row to 88 values (akin to data frame)\ncbind() is column combine for data frames with equal number of rows. to create a new data frame hunan.gi\nrename the column\n\n\nhunan.gi <- cbind(hunan, as.matrix(gi.fixed)) %>% \n  rename(gstat_fixed = as.matrix.gi.fixed.)\n\n\n\n4.9.2 Mapping Gi values with fixed distance weights\nTo map the Gi values derived using fixed distance weight matrix\n\ngdppc <- qtm(hunan, 'GDPPC') +\n  tm_layout(legend.width = 0.2,\n            legend.height = 0.2)\n\nGimap <- tm_shape(hunan.gi) + \n  tm_fill(col='gstat_fixed',\n          palette= '-RdBu',\n          style='pretty',\n          title='local Gi') +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3)\n\ntmap_arrange(gdppc, Gimap,\n             asp=1, ncol=2)\n\nSome legend labels were too wide. These labels have been resized to 0.33, 0.33, 0.33, 0.31. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger.\n\n\nVariable(s) \"gstat_fixed\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\nQuestion: What statistical observation can you draw from the Gi map above?\n\n\n4.9.3 Gi statistics using adaptive distance\n\nfips <- order(hunan$County)\ngi.adaptive <- localG(hunan$GDPPC, knn_lw)\nhunan.gi <- cbind(hunan, as.matrix(gi.adaptive)) %>%\n  rename(gstat_adaptive = as.matrix.gi.adaptive.)\n\n\n\n4.9.4 Mapping Gi values with adaptive distance weights\n\ngdppc <- qtm(hunan, 'GDPPC') +\n  tm_layout(legend.width = 0.2,\n            legend.height = 0.2)\n\nGimap <- tm_shape(hunan.gi) + \n  tm_fill(col='gstat_adaptive',\n          palette= '-RdBu',\n          style='pretty',\n          title='local Gi adaptive') +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3)\n\ntmap_arrange(gdppc, Gimap,\n             asp=1, ncol=2)\n\nSome legend labels were too wide. These labels have been resized to 0.33, 0.33, 0.33, 0.31. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger.\n\n\nVariable(s) \"gstat_adaptive\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\nQuestion: What statistical observation can you draw from the Gi map above?"
  },
  {
    "objectID": "Hands-on_Ex1.html",
    "href": "Hands-on_Ex1.html",
    "title": "Hands-on Exercise 1",
    "section": "",
    "text": "This is the overview paragraph."
  },
  {
    "objectID": "Hands-on_Ex1.html#getting-started",
    "href": "Hands-on_Ex1.html#getting-started",
    "title": "Hands-on Exercise 1",
    "section": "Getting started",
    "text": "Getting started\nThis is the getting started page."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ISSS624",
    "section": "",
    "text": "In this webpage, I am going to share with you my learning journey of Geospatial analytics."
  },
  {
    "objectID": "Hands-on_Ex04/Hands-on_Ex04.html#arguments",
    "href": "Hands-on_Ex04/Hands-on_Ex04.html#arguments",
    "title": "Hands-on_Ex04",
    "section": "Arguments",
    "text": "Arguments\n\nneighbours\n\nan object of class nb\n\nvar\n\na numeric vector\n\norder\n\nmaximum lag order\n\nmethod\n\n“corr” for correlation, “I” for Moran’s I, “C” for Geary’s C\n\nstyle\n\nstyle can take values W, B, C, and S\n\nrandomisation\n\nvariance of I or C calculated under the assumption of randomisation, if FALSE normality\n\nzero.policy\n\ndefault NULL, use global option value; if FALSE stop with error for any empty neighbour sets, if TRUE permit the weights list to be formed with zero-length weights vectors\n\n\nRefer to lecture notes on ORDER, order 1 means first layer of neighbours using the contiguity / boundary method. We want to check how the Moran’s I method changes as the neighbours get further and further away.\n\nMI_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC,\n                          order =6 ,\n                          method = \"I\",\n                          style = \"W\")\n\nplot(MI_corr)\n\n\n\n\nBased on the plot above, not all autocorrelation values might be statistically significant, thus its important to print the analysis results as shown below:\n\nprint(MI_corr)\n\nSpatial correlogram for hunan$GDPPC \nmethod: Moran's I\n         estimate expectation   variance standard deviate Pr(I) two sided    \n1 (88)  0.3007500  -0.0114943  0.0043484           4.7351       2.189e-06 ***\n2 (88)  0.2060084  -0.0114943  0.0020962           4.7505       2.029e-06 ***\n3 (88)  0.0668273  -0.0114943  0.0014602           2.0496        0.040400 *  \n4 (88)  0.0299470  -0.0114943  0.0011717           1.2107        0.226015    \n5 (88) -0.1530471  -0.0114943  0.0012440          -4.0134       5.984e-05 ***\n6 (88) -0.1187070  -0.0114943  0.0016791          -2.6164        0.008886 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nDoes it mean that the Moran’s I statistic estimate for order =4 is not statically significant? If for order 4 is already not statistically significant, do we continue to consider n = 5 and n = 6?\n\n4.5.2 Compute Geary’s C correlogram and plot\nIn the code chunk below, sp.correlogram() of spdep package is used to compute a 6-lag spatial correlogram of GDPPC. The global spatial autocorrelation used in Geary’s C. The plot() of base Graph is then used to plot the output.\n\nGC_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC,\n                          order =6 ,\n                          method = \"C\",\n                          style = \"W\")\n\nplot(GC_corr)\n\n\n\n\nTo check for statistical significance in the Geary C values:\n\nprint(GC_corr)\n\nSpatial correlogram for hunan$GDPPC \nmethod: Geary's C\n        estimate expectation  variance standard deviate Pr(I) two sided    \n1 (88) 0.6907223   1.0000000 0.0073364          -3.6108       0.0003052 ***\n2 (88) 0.7630197   1.0000000 0.0049126          -3.3811       0.0007220 ***\n3 (88) 0.9397299   1.0000000 0.0049005          -0.8610       0.3892612    \n4 (88) 1.0098462   1.0000000 0.0039631           0.1564       0.8757128    \n5 (88) 1.2008204   1.0000000 0.0035568           3.3673       0.0007592 ***\n6 (88) 1.0773386   1.0000000 0.0058042           1.0151       0.3100407    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nGeary C order 3,4,6 are not statistically significant? Do we ignore 3,4,6 only? or we ignore all of 3 to 6?"
  }
]