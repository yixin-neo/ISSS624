{
  "hash": "099e13d54d9ec843f27ebac2f64d8e13",
  "result": {
    "markdown": "---\ntitle: \"Hands-on_Ex03\"\neditor: visual\n---\n\n\n## 3.1 Overview\n\nIn this hands-on exercise, I will learn how to compute spatial weights.\n\n## 3.2 The Study Area and Data\n\n-   Hunan country boundary layer -geospatial data in ESRI shapefile format\n-   hunan_2012.csv - contains local development indicators in 2012\n\n### 3.2.1 Getting Started (ctrl-atl-i)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLinking to GEOS 3.9.3, GDAL 3.5.2, PROJ 8.2.1; sf_use_s2() is TRUE\n```\n:::\n\n```{.r .cell-code}\nlibrary(spdep)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: sp\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: spData\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nTo access larger datasets in this package, install the spDataLarge\npackage with: `install.packages('spDataLarge',\nrepos='https://nowosad.github.io/drat/', type='source')`\n```\n:::\n\n```{.r .cell-code}\nlibrary(tmap)\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages\n───────────────────────────────────────\ntidyverse 1.3.2 ──\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.8     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.1\n✔ readr   2.1.2     ✔ forcats 0.5.2\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n:::\n\n\n## 3.3 Getting the Data Into R Environment\n\n### 3.3.1 Import shapefile into r environment\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn='data/geospatial' ,\n                 layer = 'Hunan')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Hunan' from data source \n  `C:\\yixin-neo\\ISSS624\\Hands-on_Ex03\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n\n### 3.3.2 Import csv file into r environment\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv('data/aspatial/Hunan_2012.csv')\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\n### 3.3.3 Performing relational join\n\nUpdate attribute table of Hunan's SpatialPolygonDataFrame (dbf) with attribute field of hunan2012 dataframe. (csv)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, hunan2012)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"County\"\n```\n:::\n:::\n\n\nhunan 's coordinate system is WGS 84. Does it mean that we are nut using projected system here?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_geometry(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGeometry set for 88 features \nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPOLYGON ((112.0625 29.75523, 112.069 29.74544, ...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPOLYGON ((112.2288 29.11684, 112.2339 29.11214,...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPOLYGON ((111.8927 29.6013, 111.8906 29.59811, ...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPOLYGON ((111.3731 29.94649, 111.3737 29.94167,...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPOLYGON ((111.6324 29.76288, 111.6312 29.75165,...\n```\n:::\n:::\n\n\n## 3.4 Visualising Regional Development Indicator\n\n-   prepare basemap and choropleth map showing distribution of GDPCC 2012 by using qtm() of tmap package\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbasemap <- tm_shape(hunan) +\n  tm_polygons() +\n  tm_text('NAME_3', size = 0.3)\n\ngdppc <- qtm(hunan, 'GDPPC')\n\ntmap_arrange(basemap, gdppc, asp = 1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_ex03_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n## 3.5 Computing Contiguity Spatial Weights\n\n-   use [*poly2nb()*](https://r-spatial.github.io/spdep/reference/poly2nb.html) of **spdep** package to compute contiguity weight matrices\n\n-   this weight matrices has class of 'nb'\n\n-   this function builds a neighbour list based on regions with contiguous boundaries\n\n-   the 'queen' argument's default value is set to FALSE (first order neighbours). Might need to set to TRUE when needed\n\n### 3.5.1 Computing (QUEEN) contiguity based neighbours\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan, queen=TRUE) #wm_q is class 'nb'\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n:::\n:::\n\n\n-   88 area units in Hunan\n\n-   most connected unit (88) has 11 neighbours\n\n-   two area units (30 & 65) with only one neighbour\n\n-   The 'link number distribution' tells us the frequency distribution ( 2 county has 1 neighbour, 2 county has 2 neighbours, 12 county has 3 neighbours)\n\nTo see the neighbours of the first polygon, use code chunk below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  3  4 57 85\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(wm_q[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n\nYX tried to show the neighbours of first 2 polygons\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q[1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1]  2  3  4 57 85\n\n[[2]]\n[1]  1 57 58 78 85\n```\n:::\n:::\n\n\nTo retrieve the country name of the Polygon ID = 1, use code chunk below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan$County[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Anxiang\"\n```\n:::\n:::\n\n\nTo reveal the country names of the five neighbouring polygons,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan$NAME_3[c(2,3,4,57,85)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n```\n:::\n:::\n\n\nTo retrieve the GDPPC of the five neighbour countries,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb1 <- wm_q[[1]]\nnb1 <- hunan$GDPPC[nb1]\nnb1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20981 34592 24473 21311 22879\n```\n:::\n:::\n\n\nYX's practise (use c(2,3,4,57,85)) instead of wm_q\\[\\[1\\]\\]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb1 <- wm_q[[1]] #neighbours of polygon ID=1\nnb1 <- hunan$GDPPC[c(2,3,4,57,85)] #retrieve GDPPC of neighbours of polygon ID= 1\nnb1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20981 34592 24473 21311 22879\n```\n:::\n:::\n\n\nTo display the complete weight matrix, use str()\n\n-   row 1: neighbours of polygon ID =1\n\n-   row 2: neighbours of polygon ID =2 etc..\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 88\n $ : int [1:5] 2 3 4 57 85\n $ : int [1:5] 1 57 58 78 85\n $ : int [1:4] 1 4 5 85\n $ : int [1:4] 1 3 5 6\n $ : int [1:4] 3 4 6 85\n $ : int [1:5] 4 5 69 75 85\n $ : int [1:4] 67 71 74 84\n $ : int [1:7] 9 46 47 56 78 80 86\n $ : int [1:6] 8 66 68 78 84 86\n $ : int [1:8] 16 17 19 20 22 70 72 73\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:3] 11 15 17\n $ : int [1:4] 13 14 17 83\n $ : int [1:5] 10 17 22 72 83\n $ : int [1:7] 10 11 14 15 16 72 83\n $ : int [1:5] 20 22 23 77 83\n $ : int [1:6] 10 20 21 73 74 86\n $ : int [1:7] 10 18 19 21 22 23 82\n $ : int [1:5] 19 20 35 82 86\n $ : int [1:5] 10 16 18 20 83\n $ : int [1:7] 18 20 38 41 77 79 82\n $ : int [1:5] 25 28 31 32 54\n $ : int [1:5] 24 28 31 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:3] 26 29 42\n $ : int [1:5] 24 25 33 49 54\n $ : int [1:3] 27 37 42\n $ : int 33\n $ : int [1:8] 24 25 32 36 39 40 56 81\n $ : int [1:8] 24 31 50 54 55 56 75 85\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 47 80 82 86\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:4] 29 42 43 44\n $ : int [1:4] 23 44 77 79\n $ : int [1:5] 31 40 42 43 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:7] 26 27 29 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:4] 37 38 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:3] 8 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:5] 32 48 52 54 55\n $ : int [1:3] 48 49 52\n $ : int [1:5] 48 49 50 51 54\n $ : int [1:3] 48 55 75\n $ : int [1:6] 24 28 32 49 50 52\n $ : int [1:5] 32 48 50 53 75\n $ : int [1:7] 8 31 32 36 78 80 85\n $ : int [1:6] 1 2 58 64 76 85\n $ : int [1:5] 2 57 68 76 78\n $ : int [1:4] 60 61 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:7] 12 59 60 62 63 77 87\n $ : int [1:3] 61 77 87\n $ : int [1:4] 12 61 77 83\n $ : int [1:2] 57 76\n $ : int 76\n $ : int [1:5] 9 67 68 76 84\n $ : int [1:4] 7 66 76 84\n $ : int [1:5] 9 58 66 76 78\n $ : int [1:3] 6 75 85\n $ : int [1:3] 10 72 73\n $ : int [1:3] 7 73 74\n $ : int [1:5] 10 11 16 17 70\n $ : int [1:5] 10 19 70 71 74\n $ : int [1:6] 7 19 71 73 84 86\n $ : int [1:6] 6 32 53 55 69 85\n $ : int [1:7] 57 58 64 65 66 67 68\n $ : int [1:7] 18 23 38 61 62 63 83\n $ : int [1:7] 2 8 9 56 58 68 85\n $ : int [1:7] 23 38 40 41 43 44 45\n $ : int [1:8] 8 34 35 36 41 45 47 56\n $ : int [1:6] 25 26 31 33 39 42\n $ : int [1:5] 20 21 23 35 41\n $ : int [1:9] 12 13 15 16 17 18 22 63 77\n $ : int [1:6] 7 9 66 67 74 86\n $ : int [1:11] 1 2 3 5 6 32 56 57 69 75 ...\n $ : int [1:9] 8 9 19 21 35 46 47 74 84\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language poly2nb(pl = hunan, queen = TRUE)\n - attr(*, \"type\")= chr \"queen\"\n - attr(*, \"sym\")= logi TRUE\n```\n:::\n:::\n\n\n### 3.5.2 Creating (ROOK) contiguity based neighbours\n\nTo compute the Rook contiguity weight matrix,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_r <- poly2nb(hunan, queen=FALSE)\nsummary(wm_r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links\n```\n:::\n:::\n\n\n-   88 area units in Hunan\n\n-   most connected unit (85) has 11 neighbours\n\n-   two area units (30 & 65) with only one neighbour\n\n### 3.5.3 Visualising contiguity weights (find centroid coords first)\n\n-   a connectivity graph takes a point and displays a line to each neighbouring point\n\n-   need a point in polygon via polygon centroids \\<- calculate using the sf package first\n\nTo obtain coordinates in a separate data frame\n\n1.  input vector is the geometry column of us.bound, an sf object \\<- a polygon\n\n2.  apply mapping function (st_centroid) on input vector \\<- find the CG of this polygon\n\n3.  use map_dbl variation of map from the purrr package\n\nAfter finding centroid, to access longitude values\n\n-   double bracket notation \\[\\[ \\]\\] and 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n```\n:::\n\n\nTo access the latitude value\n\n-   double bracket notation \\[\\[ \\]\\] and 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n```\n:::\n\n\nWith both longitude and latitude, use cbind() to combine both in the same object,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- cbind(longitude, latitude)\n```\n:::\n\n\nCheck the first few observations,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(coords)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     longitude latitude\n[1,]  112.1531 29.44362\n[2,]  112.0372 28.86489\n[3,]  111.8917 29.47107\n[4,]  111.7031 29.74499\n[5,]  111.6138 29.49258\n[6,]  111.0341 29.79863\n```\n:::\n:::\n\n\n#### 3.5.3.1 Plotting Queen contiguity based neighbours map\n\nUse the [plot()](https://www.digitalocean.com/community/tutorials/plot-function-in-r) function\n\n1.  **The shape of the markers:** The plot markers are by default small, empty circles. These are also known as plot characters - denoted by **pch**. You can change these by adding a new **pch** value in the plot function. Pch values 0 to 25 are valid and give several different symbols on the graph. **Pch** 0 is for a square, 1 is for a circle, 3 is for a triangle, 4 is for a cross and so on.\n\n2.  **Size of the plot markers**: This aspect of a graph can be controlled using the **cex** parameter. The **cex** parameter can be set to 0.5 if you want the markers to be 50% smaller and 1.5 if you want them to be 50% larger.\n\n3.  **Color of the plot markers:** The symbols can be assigned one or many colors. These colors can be selected from a list provided by R under the `colors()` function.\n\nwm\\_ q is weight matrix using queen method (88 rows of list of neighbours)\n\ncoords is an array of x,y coordinates for each of the 88 counties\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hunan$geometry, border = 'lightgrey')\nplot(wm_q, coords, pch = 19, cex = 0.6, add= TRUE, col='red')\n```\n\n::: {.cell-output-display}\n![](Hands-on_ex03_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n#### 3.5.3.2 Plotting Rook contiguity based neighbours map\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hunan$geometry, border = 'lightgrey')\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col =\"blue\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_ex03_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n#### 3.5.3.3 Plotting both Queen and Rook contiguity based neighbours maps\n\nUse the [par(mfrow)](https://bookdown.org/ndphillips/YaRrr/arranging-plots-with-parmfrow-and-layout.html) function\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1,2))  # by 1 by 2 plotting matrix\nplot(hunan$geometry, border=\"lightgrey\", main=\"Queen Contiguity\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\")\nplot(hunan$geometry, border=\"lightgrey\", main=\"Rook Contiguity\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_ex03_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n## 3.6 Computing distance based neighbours\n\n-   In this section, I will derive distance-based weight matrices by using [*dnearneigh()*](https://r-spatial.github.io/spdep/reference/dnearneigh.html) of **spdep** package.\n\n        dnearneigh(x, d1, d2, row.names = NULL, longlat = NULL, bounds=c(\"GE\", \"LE\"),\n         use_kd_tree=TRUE, symtest=FALSE, use_s2=packageVersion(\"s2\") > \"1.0.7\", k=200,\n         dwithin=TRUE)\n\n-   identifies neighbours using distance band with lower d1= and upper d2= bounds controlled by the bounds= argument\n\n-   If unprojected coordinates are used and either specified in the coordinates object x or with x as a two column matrix and longlat=TRUE, great circle distances in **km** will be calculated assuming the WGS84 reference ellipsoid.\n\n### 3.6.1 First, determine the cut-off distance (upper distance threshold to be considered a neighbour)\n\nFirst, determine the upper limit for distance band by using the steps below:\n\n-   Return a matrix with the indices of points belonging to the set of the k nearest neighbours of each other by using [*knearneigh()*](https://r-spatial.github.io/spdep/reference/knearneigh.html) of **spdep**. Output: NN of poly1 = poly3, NN of poly2 = poly 78 etc.... The output iz a knn object with class 'knn'.\n\n    \\$nn\n\n    \\[,1\\]\n\n    \\[1,\\] 3\n\n    \\[2,\\] 78\n\n    \\[3,\\] 1\n\n-   After applying *knearneigh()* , convert the knn object into a neighbours list of class nb with a list of integer vectors containing neighbour region number ids by using [*knn2nb()*](https://r-spatial.github.io/spdep/reference/knn2nb.html).\n\nNeighbour list object:\n\nNumber of regions: 88\n\nNumber of nonzero links: 88\n\nPercentage nonzero weights: 1.136364\n\nAverage number of links: 1\n\nNon-symmetric neighbours list\n\n-   Return the length of neighbour relationship edges by using [*nbdists()*](https://r-spatial.github.io/spdep/reference/nbdists.html) of **spdep**. \\<- returns the distance to one's nearest neighbour? 88 polygons means 88 nearest neighbours. The function returns in the units of the coordinates if the coordinates are projected (in km if unprojected)\n\n\\[\\[1\\]\\]\n\n\\[1\\] 25.53398\n\n\\[\\[2\\]\\]\n\n\\[1\\] 43.03114\n\n\\[\\[3\\]\\]\n\n\\[1\\] 25.53398\n\n-   Remove the list structure of the returned object by using [**unlist()**](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/unlist). The output is in numeric format.\n\nOutput: 25.53398 43.03114 25.53398 29.28480 29.28480 45.98097 58.52704 28.95985 34.45062 37.99885 44.49442 33.48816 35.98123\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#coords <- coordinates(hunan)\nk1 <- knn2nb(knearneigh(coords)) # nb class with 1 NN\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE)) #dist to 1 NN, class numeric\nsummary(k1dists)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n```\n:::\n:::\n\n\n**The summary report shows that the largest first nearest neighbour distance is 61.79. So using this as the upper threshold will help to ensure that all units (polygons) will have at least one neighbour**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass (k1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"nb\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(k1dists)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\n### 3.6.2 Computing [fixed]{.underline} distance weight matrix\n\n(Earlier, we had used poly2nb(hunan, queen=TRUE/FALSE) to find neighbours using Queen or Rook method)\n\nNow, to find neighbours using distance, we use the dnearneigh() ,\n\n-   *longlad argument: TRUE if point coordinates are geographical longitude-latitude decimal degrees*\n\nDoes the average number of links mean that each polygon has average number of 3.6 nearest neighbours with upper bound of 62?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_d62 <- dnearneigh(coords,0, 62, longlat=TRUE)  #class 'nb' by upper bound distance\nwm_d62\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(wm_d62)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 88\n $ : int [1:5] 3 4 5 57 64\n $ : int [1:4] 57 58 78 85\n $ : int [1:4] 1 4 5 57\n $ : int [1:3] 1 3 5\n $ : int [1:4] 1 3 4 85\n $ : int 69\n $ : int [1:2] 67 84\n $ : int [1:4] 9 46 47 78\n $ : int [1:4] 8 46 68 84\n $ : int [1:4] 16 22 70 72\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:2] 11 17\n $ : int 13\n $ : int [1:4] 10 17 22 83\n $ : int [1:3] 11 14 16\n $ : int [1:3] 20 22 63\n $ : int [1:5] 20 21 73 74 82\n $ : int [1:5] 18 19 21 22 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:4] 10 16 18 20\n $ : int [1:3] 41 77 82\n $ : int [1:4] 25 28 31 54\n $ : int [1:4] 24 28 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:2] 26 29\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:2] 27 37\n $ : int 33\n $ : int [1:2] 24 36\n $ : int 50\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:5] 31 34 45 56 80\n $ : int [1:2] 29 42\n $ : int [1:3] 44 77 79\n $ : int [1:4] 40 42 43 81\n $ : int [1:3] 39 45 79\n $ : int [1:5] 23 35 45 79 82\n $ : int [1:5] 26 37 39 43 81\n $ : int [1:3] 39 42 44\n $ : int [1:2] 38 43\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:5] 8 9 35 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:4] 48 49 50 52\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:2] 48 55\n $ : int [1:5] 24 28 49 50 52\n $ : int [1:4] 48 50 53 75\n $ : int 36\n $ : int [1:5] 1 2 3 58 64\n $ : int [1:5] 2 57 64 66 68\n $ : int [1:3] 60 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:5] 12 60 62 63 87\n $ : int [1:4] 61 63 77 87\n $ : int [1:5] 12 18 61 62 83\n $ : int [1:4] 1 57 58 76\n $ : int 76\n $ : int [1:5] 58 67 68 76 84\n $ : int [1:2] 7 66\n $ : int [1:4] 9 58 66 84\n $ : int [1:2] 6 75\n $ : int [1:3] 10 72 73\n $ : int [1:2] 73 74\n $ : int [1:3] 10 11 70\n $ : int [1:4] 19 70 71 74\n $ : int [1:5] 19 21 71 73 86\n $ : int [1:2] 55 69\n $ : int [1:3] 64 65 66\n $ : int [1:3] 23 38 62\n $ : int [1:2] 2 8\n $ : int [1:4] 38 40 41 45\n $ : int [1:5] 34 35 36 45 47\n $ : int [1:5] 25 26 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:4] 12 13 16 63\n $ : int [1:4] 7 9 66 68\n $ : int [1:2] 2 5\n $ : int [1:4] 21 46 47 74\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language dnearneigh(x = coords, d1 = 0, d2 = 62, longlat = TRUE)\n - attr(*, \"dnn\")= num [1:2] 0 62\n - attr(*, \"bounds\")= chr [1:2] \"GE\" \"LE\"\n - attr(*, \"nbtype\")= chr \"distance\"\n - attr(*, \"sym\")= logi TRUE\n```\n:::\n:::\n\n\nAnother way to display the structure of the weight matrix is to combine [*table()*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/table) and [*card()*](https://r-spatial.github.io/spdep/reference/card.html) of spdep.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(hunan$County, card(wm_d62))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               \n                1 2 3 4 5 6\n  Anhua         1 0 0 0 0 0\n  Anren         0 0 0 1 0 0\n  Anxiang       0 0 0 0 1 0\n  Baojing       0 0 0 0 1 0\n  Chaling       0 0 1 0 0 0\n  Changning     0 0 1 0 0 0\n  Changsha      0 0 0 1 0 0\n  Chengbu       0 1 0 0 0 0\n  Chenxi        0 0 0 1 0 0\n  Cili          0 1 0 0 0 0\n  Dao           0 0 0 1 0 0\n  Dongan        0 0 1 0 0 0\n  Dongkou       0 0 0 1 0 0\n  Fenghuang     0 0 0 1 0 0\n  Guidong       0 0 1 0 0 0\n  Guiyang       0 0 0 1 0 0\n  Guzhang       0 0 0 0 0 1\n  Hanshou       0 0 0 1 0 0\n  Hengdong      0 0 0 0 1 0\n  Hengnan       0 0 0 0 1 0\n  Hengshan      0 0 0 0 0 1\n  Hengyang      0 0 0 0 0 1\n  Hongjiang     0 0 0 0 1 0\n  Huarong       0 0 0 1 0 0\n  Huayuan       0 0 0 1 0 0\n  Huitong       0 0 0 1 0 0\n  Jiahe         0 0 0 0 1 0\n  Jianghua      0 0 1 0 0 0\n  Jiangyong     0 1 0 0 0 0\n  Jingzhou      0 1 0 0 0 0\n  Jinshi        0 0 0 1 0 0\n  Jishou        0 0 0 0 0 1\n  Lanshan       0 0 0 1 0 0\n  Leiyang       0 0 0 1 0 0\n  Lengshuijiang 0 0 1 0 0 0\n  Li            0 0 1 0 0 0\n  Lianyuan      0 0 0 0 1 0\n  Liling        0 1 0 0 0 0\n  Linli         0 0 0 1 0 0\n  Linwu         0 0 0 1 0 0\n  Linxiang      1 0 0 0 0 0\n  Liuyang       0 1 0 0 0 0\n  Longhui       0 0 1 0 0 0\n  Longshan      0 1 0 0 0 0\n  Luxi          0 0 0 0 1 0\n  Mayang        0 0 0 0 0 1\n  Miluo         0 0 0 0 1 0\n  Nan           0 0 0 0 1 0\n  Ningxiang     0 0 0 1 0 0\n  Ningyuan      0 0 0 0 1 0\n  Pingjiang     0 1 0 0 0 0\n  Qidong        0 0 1 0 0 0\n  Qiyang        0 0 1 0 0 0\n  Rucheng       0 1 0 0 0 0\n  Sangzhi       0 1 0 0 0 0\n  Shaodong      0 0 0 0 1 0\n  Shaoshan      0 0 0 0 1 0\n  Shaoyang      0 0 0 1 0 0\n  Shimen        1 0 0 0 0 0\n  Shuangfeng    0 0 0 0 0 1\n  Shuangpai     0 0 0 1 0 0\n  Suining       0 0 0 0 1 0\n  Taojiang      0 1 0 0 0 0\n  Taoyuan       0 1 0 0 0 0\n  Tongdao       0 1 0 0 0 0\n  Wangcheng     0 0 0 1 0 0\n  Wugang        0 0 1 0 0 0\n  Xiangtan      0 0 0 1 0 0\n  Xiangxiang    0 0 0 0 1 0\n  Xiangyin      0 0 0 1 0 0\n  Xinhua        0 0 0 0 1 0\n  Xinhuang      1 0 0 0 0 0\n  Xinning       0 1 0 0 0 0\n  Xinshao       0 0 0 0 0 1\n  Xintian       0 0 0 0 1 0\n  Xupu          0 1 0 0 0 0\n  Yanling       0 0 1 0 0 0\n  Yizhang       1 0 0 0 0 0\n  Yongshun      0 0 0 1 0 0\n  Yongxing      0 0 0 1 0 0\n  You           0 0 0 1 0 0\n  Yuanjiang     0 0 0 0 1 0\n  Yuanling      1 0 0 0 0 0\n  Yueyang       0 0 1 0 0 0\n  Zhijiang      0 0 0 0 1 0\n  Zhongfang     0 0 0 1 0 0\n  Zhuzhou       0 0 0 0 1 0\n  Zixing        0 0 1 0 0 0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nn_comp <- n.comp.nb(wm_d62)\nn_comp$nc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(n_comp$comp.id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n 1 \n88 \n```\n:::\n:::\n\n\n#### 3.6.2.1 Plotting fixed distance weight matrix\n\n-   wm_d62 is the fixed distance weight matrix,\n\n-   coords refers to long, lat coordinates for CG of each polygon\n\n-   k1 is the integer ID of the polygon which is the nearest neighbour to me\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hunan$geometry, border = 'lightgrey')\nplot (wm_d62, coords,add=TRUE)\nplot(k1, coords, add=TRUE, col ='red', length=0.08)\n```\n\n::: {.cell-output-display}\n![](Hands-on_ex03_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\nThe red lines shows the links of 1st nearest neighbours and the black lines show the lines of neighbours within the cut-off distance of 62km.\n\nTo plot red and black side by side,\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(1,2))\nplot(hunan$geometry, border='light grey', main=\"1st NN\")\nplot(k1, coords, add=TRUE, col=\"red\", length='0.08')\nplot(hunan$geometry, border='light grey', main='Distance Link')\nplot(wm_d62, coords, add=TRUE, pch=19, cex=0.6)\n```\n\n::: {.cell-output-display}\n![](Hands-on_ex03_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\n### 3.6.3 Computing [adaptive]{.underline} distance weight matrix\n\nOne of the characteristics of fixed distance weight matrix is that more densely settled areas (usually the urban areas) tend to have more neighbours and the less densely settled areas (usually the rural counties) tend to have lesser neighbours. Having many neighbours smoothes the neighbour relationship across more neighbours.\n\nIt is possible to control the numbers of neighbours directly using k-nearest neighbours, either accepting asymmetric neighbours or imposing symmetry as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknn6 <- knn2nb(knearneigh(coords, k = 6)) # class nb by fixed NN\nknn6\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 528 \nPercentage nonzero weights: 6.818182 \nAverage number of links: 6 \nNon-symmetric neighbours list\n```\n:::\n:::\n\n\n*\\*as seen above, each polygon has strictly six neighbours*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(knn6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 88\n $ : int [1:6] 2 3 4 5 57 64\n $ : int [1:6] 1 3 57 58 78 85\n $ : int [1:6] 1 2 4 5 57 85\n $ : int [1:6] 1 3 5 6 69 85\n $ : int [1:6] 1 3 4 6 69 85\n $ : int [1:6] 3 4 5 69 75 85\n $ : int [1:6] 9 66 67 71 74 84\n $ : int [1:6] 9 46 47 78 80 86\n $ : int [1:6] 8 46 66 68 84 86\n $ : int [1:6] 16 19 22 70 72 73\n $ : int [1:6] 10 14 16 17 70 72\n $ : int [1:6] 13 15 60 61 63 83\n $ : int [1:6] 12 15 60 61 63 83\n $ : int [1:6] 11 15 16 17 72 83\n $ : int [1:6] 12 13 14 17 60 83\n $ : int [1:6] 10 11 17 22 72 83\n $ : int [1:6] 10 11 14 16 72 83\n $ : int [1:6] 20 22 23 63 77 83\n $ : int [1:6] 10 20 21 73 74 82\n $ : int [1:6] 18 19 21 22 23 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:6] 10 16 18 19 20 83\n $ : int [1:6] 18 20 41 77 79 82\n $ : int [1:6] 25 28 31 52 54 81\n $ : int [1:6] 24 28 31 33 54 81\n $ : int [1:6] 25 27 29 33 42 81\n $ : int [1:6] 26 29 30 37 42 81\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:6] 26 27 37 42 43 81\n $ : int [1:6] 26 27 28 33 49 81\n $ : int [1:6] 24 25 36 39 40 54\n $ : int [1:6] 24 31 50 54 55 56\n $ : int [1:6] 25 26 28 30 49 81\n $ : int [1:6] 36 40 41 45 56 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:6] 26 27 29 42 43 44\n $ : int [1:6] 23 43 44 62 77 79\n $ : int [1:6] 25 40 42 43 44 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:6] 26 27 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:6] 37 38 39 42 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:6] 8 9 35 47 78 86\n $ : int [1:6] 8 21 35 46 80 86\n $ : int [1:6] 49 50 51 52 53 55\n $ : int [1:6] 28 33 48 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:6] 28 48 49 50 52 54\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:6] 48 50 51 52 55 75\n $ : int [1:6] 24 28 49 50 51 52\n $ : int [1:6] 32 48 50 52 53 75\n $ : int [1:6] 32 34 36 78 80 85\n $ : int [1:6] 1 2 3 58 64 68\n $ : int [1:6] 2 57 64 66 68 78\n $ : int [1:6] 12 13 60 61 87 88\n $ : int [1:6] 12 13 59 61 63 87\n $ : int [1:6] 12 13 60 62 63 87\n $ : int [1:6] 12 38 61 63 77 87\n $ : int [1:6] 12 18 60 61 62 83\n $ : int [1:6] 1 3 57 58 68 76\n $ : int [1:6] 58 64 66 67 68 76\n $ : int [1:6] 9 58 67 68 76 84\n $ : int [1:6] 7 65 66 68 76 84\n $ : int [1:6] 9 57 58 66 78 84\n $ : int [1:6] 4 5 6 32 75 85\n $ : int [1:6] 10 16 19 22 72 73\n $ : int [1:6] 7 19 73 74 84 86\n $ : int [1:6] 10 11 14 16 17 70\n $ : int [1:6] 10 19 21 70 71 74\n $ : int [1:6] 19 21 71 73 84 86\n $ : int [1:6] 6 32 50 53 55 69\n $ : int [1:6] 58 64 65 66 67 68\n $ : int [1:6] 18 23 38 61 62 63\n $ : int [1:6] 2 8 9 46 58 68\n $ : int [1:6] 38 40 41 43 44 45\n $ : int [1:6] 34 35 36 41 45 47\n $ : int [1:6] 25 26 28 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:6] 12 13 15 16 22 63\n $ : int [1:6] 7 9 66 68 71 74\n $ : int [1:6] 2 3 4 5 56 69\n $ : int [1:6] 8 9 21 46 47 74\n $ : int [1:6] 59 60 61 62 63 88\n $ : int [1:6] 59 60 61 62 63 87\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language knearneigh(x = coords, k = 6)\n - attr(*, \"sym\")= logi FALSE\n - attr(*, \"type\")= chr \"knn\"\n - attr(*, \"knn-k\")= num 6\n - attr(*, \"class\")= chr \"nb\"\n```\n:::\n:::\n\n\n#### 3.6.3.1 Plotting distance based neighbours\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hunan$geometry, border=\"light grey\")\nplot(knn6, coords, pch= 19, cex=0.6, add=TRUE, col='red')\n```\n\n::: {.cell-output-display}\n![](Hands-on_ex03_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\n\n## 3.7 Weights based on IDW\n\nCompute the spatial weight matrix using the Inversed Distance Method\n\n-   recall from lecture that closer polygon has greater weightage if we take inverse\n\nFirst compute distance between areas using y using [*nbdists()*](https://r-spatial.github.io/spdep/reference/nbdists.html) of **spdep**.\n\n-   Given a list of spatial neighbour links (a neighbours list of object type `nb`), the function returns the Euclidean distances along the links in a list of the same form as the neighbours list. If longlat = TRUE, Great Circle distances are used.\n\nThen obtain the [inversed-dist spatial weight matrix]{.underline} (**ids**) using [lapply()](https://www.geeksforgeeks.org/apply-lapply-sapply-and-tapply-in-r/) to apply the function 1/(x), where x is the distance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist <- nbdists(wm_q, coords, longlat = TRUE)  # class nbdists\n# [[1]] 65.12941 25.53398 54.91802 35.61352 87.32760\n#[[2]] 65.12941 56.67944 51.92312 43.03114 58.16151\nids <-lapply (dist, function(x) 1/(x)) # class list, inverse dist \nhead(ids)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n\n[[2]]\n[1] 0.01535405 0.01764308 0.01925924 0.02323898 0.01719350\n\n[[3]]\n[1] 0.03916350 0.02822040 0.03695795 0.01395765\n\n[[4]]\n[1] 0.01820896 0.02822040 0.03414741 0.01539065\n\n[[5]]\n[1] 0.03695795 0.03414741 0.01524598 0.01618354\n\n[[6]]\n[1] 0.015390649 0.015245977 0.021748129 0.011883901 0.009810297\n```\n:::\n:::\n\n\n### 3.7.1 Row-standardised weights matrix\n\nUse the [nb2listw()](https://search.r-project.org/CRAN/refmans/spdep/html/nb2listw.html)\n\n    nb2listw(neighbours, glist=NULL, style=\"W\", zero.policy=NULL)\n\nArguments\n\n| `neighbours`  | an object of class `nb`                                                                                                                                                     |\n|----------------|--------------------------------------------------------|\n| `glist`       | list of general weights corresponding to neighbours                                                                                                                         |\n| `style`       | `style` can take values \"W\", \"B\", \"C\", \"U\", \"minmax\" and \"S\"                                                                                                                |\n| `zero.policy` | default NULL, use global option value; if FALSE stop with error for any empty neighbour sets, if TRUE permit the weights list to be formed with zero-length weights vectors |\n\nDetails\n\nStarting from a binary neighbours list, in which regions are either listed as neighbours or are absent (thus not in the set of neighbours for some definition), the function adds a weights list with values given by the coding scheme style chosen.\n\nWeights to each neighboring polygon\n\n-   each neighboring polygon will be assigned equal weight (style=\"W\") \\<- row standardised\n\n-   This is accomplished by assigning the fraction 1/(#ofneighbors) to each neighboring county then summing the weighted income values\n\n-   drawback of this method is that polygon along the edge will base their lagged values on fewer polygons, thus over estimating the true nature of spatial autocorrelation in the data. Next time can consider other more robust options are available, notably style=\"B\" \\<- basic binary coding\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q <- nb2listw(wm_q, style = 'W', zero.policy = TRUE)\nrswm_q # class\"listw\" \"nb\"  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n```\n:::\n:::\n\n\nThe zero.policy=TRUE option allows for lists of non-neighbors. This should be used with caution since the user may not be aware of missing neighbors in their dataset however, a zero.policy of FALSE would return an error.\n\nTo see the weight of the first polygon's four neighbours type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q$weights[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 0.2 0.2 0.2 0.2 0.2\n```\n:::\n:::\n\n\nExplanation of above: Each neighbor is assigned a 0.2 of the total weight. This means that when R computes the average neighboring income values, each **neighbor's income will be multiplied by 0.2 before being tallied.**\n\nYX's practise (There are two variables in rswm_q, namely \\$neighbours and \\$ weight)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(rswm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ style     : chr \"W\"\n $ neighbours:List of 88\n  ..$ : int [1:5] 2 3 4 57 85\n  ..$ : int [1:5] 1 57 58 78 85\n  ..$ : int [1:4] 1 4 5 85\n  ..$ : int [1:4] 1 3 5 6\n  ..$ : int [1:4] 3 4 6 85\n  ..$ : int [1:5] 4 5 69 75 85\n  ..$ : int [1:4] 67 71 74 84\n  ..$ : int [1:7] 9 46 47 56 78 80 86\n  ..$ : int [1:6] 8 66 68 78 84 86\n  ..$ : int [1:8] 16 17 19 20 22 70 72 73\n  ..$ : int [1:3] 14 17 72\n  ..$ : int [1:5] 13 60 61 63 83\n  ..$ : int [1:4] 12 15 60 83\n  ..$ : int [1:3] 11 15 17\n  ..$ : int [1:4] 13 14 17 83\n  ..$ : int [1:5] 10 17 22 72 83\n  ..$ : int [1:7] 10 11 14 15 16 72 83\n  ..$ : int [1:5] 20 22 23 77 83\n  ..$ : int [1:6] 10 20 21 73 74 86\n  ..$ : int [1:7] 10 18 19 21 22 23 82\n  ..$ : int [1:5] 19 20 35 82 86\n  ..$ : int [1:5] 10 16 18 20 83\n  ..$ : int [1:7] 18 20 38 41 77 79 82\n  ..$ : int [1:5] 25 28 31 32 54\n  ..$ : int [1:5] 24 28 31 33 81\n  ..$ : int [1:4] 27 33 42 81\n  ..$ : int [1:3] 26 29 42\n  ..$ : int [1:5] 24 25 33 49 54\n  ..$ : int [1:3] 27 37 42\n  ..$ : int 33\n  ..$ : int [1:8] 24 25 32 36 39 40 56 81\n  ..$ : int [1:8] 24 31 50 54 55 56 75 85\n  ..$ : int [1:5] 25 26 28 30 81\n  ..$ : int [1:3] 36 45 80\n  ..$ : int [1:6] 21 41 47 80 82 86\n  ..$ : int [1:6] 31 34 40 45 56 80\n  ..$ : int [1:4] 29 42 43 44\n  ..$ : int [1:4] 23 44 77 79\n  ..$ : int [1:5] 31 40 42 43 81\n  ..$ : int [1:6] 31 36 39 43 45 79\n  ..$ : int [1:6] 23 35 45 79 80 82\n  ..$ : int [1:7] 26 27 29 37 39 43 81\n  ..$ : int [1:6] 37 39 40 42 44 79\n  ..$ : int [1:4] 37 38 43 79\n  ..$ : int [1:6] 34 36 40 41 79 80\n  ..$ : int [1:3] 8 47 86\n  ..$ : int [1:5] 8 35 46 80 86\n  ..$ : int [1:5] 50 51 52 53 55\n  ..$ : int [1:4] 28 51 52 54\n  ..$ : int [1:5] 32 48 52 54 55\n  ..$ : int [1:3] 48 49 52\n  ..$ : int [1:5] 48 49 50 51 54\n  ..$ : int [1:3] 48 55 75\n  ..$ : int [1:6] 24 28 32 49 50 52\n  ..$ : int [1:5] 32 48 50 53 75\n  ..$ : int [1:7] 8 31 32 36 78 80 85\n  ..$ : int [1:6] 1 2 58 64 76 85\n  ..$ : int [1:5] 2 57 68 76 78\n  ..$ : int [1:4] 60 61 87 88\n  ..$ : int [1:4] 12 13 59 61\n  ..$ : int [1:7] 12 59 60 62 63 77 87\n  ..$ : int [1:3] 61 77 87\n  ..$ : int [1:4] 12 61 77 83\n  ..$ : int [1:2] 57 76\n  ..$ : int 76\n  ..$ : int [1:5] 9 67 68 76 84\n  ..$ : int [1:4] 7 66 76 84\n  ..$ : int [1:5] 9 58 66 76 78\n  ..$ : int [1:3] 6 75 85\n  ..$ : int [1:3] 10 72 73\n  ..$ : int [1:3] 7 73 74\n  ..$ : int [1:5] 10 11 16 17 70\n  ..$ : int [1:5] 10 19 70 71 74\n  ..$ : int [1:6] 7 19 71 73 84 86\n  ..$ : int [1:6] 6 32 53 55 69 85\n  ..$ : int [1:7] 57 58 64 65 66 67 68\n  ..$ : int [1:7] 18 23 38 61 62 63 83\n  ..$ : int [1:7] 2 8 9 56 58 68 85\n  ..$ : int [1:7] 23 38 40 41 43 44 45\n  ..$ : int [1:8] 8 34 35 36 41 45 47 56\n  ..$ : int [1:6] 25 26 31 33 39 42\n  ..$ : int [1:5] 20 21 23 35 41\n  ..$ : int [1:9] 12 13 15 16 17 18 22 63 77\n  ..$ : int [1:6] 7 9 66 67 74 86\n  ..$ : int [1:11] 1 2 3 5 6 32 56 57 69 75 ...\n  ..$ : int [1:9] 8 9 19 21 35 46 47 74 84\n  ..$ : int [1:4] 59 61 62 88\n  ..$ : int [1:2] 59 87\n  ..- attr(*, \"class\")= chr \"nb\"\n  ..- attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n  ..- attr(*, \"call\")= language poly2nb(pl = hunan, queen = TRUE)\n  ..- attr(*, \"type\")= chr \"queen\"\n  ..- attr(*, \"sym\")= logi TRUE\n $ weights   :List of 88\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:8] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num 1\n  ..$ : num [1:8] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n  ..$ : num [1:8] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:2] 0.5 0.5\n  ..$ : num 1\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:3] 0.333 0.333 0.333\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:7] 0.143 0.143 0.143 0.143 0.143 ...\n  ..$ : num [1:8] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:5] 0.2 0.2 0.2 0.2 0.2\n  ..$ : num [1:9] 0.111 0.111 0.111 0.111 0.111 ...\n  ..$ : num [1:6] 0.167 0.167 0.167 0.167 0.167 ...\n  ..$ : num [1:11] 0.0909 0.0909 0.0909 0.0909 0.0909 ...\n  ..$ : num [1:9] 0.111 0.111 0.111 0.111 0.111 ...\n  ..$ : num [1:4] 0.25 0.25 0.25 0.25\n  ..$ : num [1:2] 0.5 0.5\n  ..- attr(*, \"mode\")= chr \"binary\"\n  ..- attr(*, \"W\")= logi TRUE\n  ..- attr(*, \"comp\")=List of 1\n  .. ..$ d: num [1:88] 5 5 4 4 4 5 4 7 6 8 ...\n - attr(*, \"class\")= chr [1:2] \"listw\" \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language nb2listw(neighbours = wm_q, style = \"W\", zero.policy = TRUE)\n```\n:::\n:::\n\n\nUsing the same method, we can also derive a row standardised distance weight matrix (closer neighbours have higher weightings) by using the code chunk below.\n\n\\*notice that the spatial weight matrix using inverse weight method is used here and with style = 'B'\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_ids <- nb2listw(wm_q, glist=ids, style='B', zero.policy=TRUE)\nrswm_ids # class \"listw\" weights list \"nb\"  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn       S0        S1     S2\nB 88 7744 8.786867 0.3776535 3.8137\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_ids$weights[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(unlist(rswm_ids$weights))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n0.008218 0.015088 0.018739 0.019614 0.022823 0.040338 \n```\n:::\n:::\n\n\n## 3.8 Application of Spatial Weight Matrix\n\nIn this section, you will learn how to create four different spatial lagged variables, they are:\n\n-   spatial lag with row-standardized weights,\n\n-   spatial lag as a sum of neighbouring values,\n\n-   spatial window average, and spatial window sum.\n\n### 3.8.1 Spatial lag with row-standardized weights\n\n-   compute the average neighbour GDPCC values for each polygon\n\n-   commonly called spatially lagged values\n\n-   In the code below, use spatial weight matrix (equal weightage of 0.2 for poly1 etc.. ) by 0.2 \\* 20981 + 0.2 \\* 34592 + 0.2 \\* 24473 + 0.2 \\* 21311 + 0.2 \\* 22879 = 24847.20 for poly1 \"Anxiang\"\n\n-   22724.80 is the average GDPPC for poly2 based on equal weightage (0.2) of all its five neighbours . 24143.25 for poly3 based on equal weightage (0.25) based on four neighbours.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)\nGDPPC.lag # numeric class\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 24847.20 22724.80 24143.25 27737.50 27270.25 21248.80 43747.00 33582.71\n [9] 45651.17 32027.62 32671.00 20810.00 25711.50 30672.33 33457.75 31689.20\n[17] 20269.00 23901.60 25126.17 21903.43 22718.60 25918.80 20307.00 20023.80\n[25] 16576.80 18667.00 14394.67 19848.80 15516.33 20518.00 17572.00 15200.12\n[33] 18413.80 14419.33 24094.50 22019.83 12923.50 14756.00 13869.80 12296.67\n[41] 15775.17 14382.86 11566.33 13199.50 23412.00 39541.00 36186.60 16559.60\n[49] 20772.50 19471.20 19827.33 15466.80 12925.67 18577.17 14943.00 24913.00\n[57] 25093.00 24428.80 17003.00 21143.75 20435.00 17131.33 24569.75 23835.50\n[65] 26360.00 47383.40 55157.75 37058.00 21546.67 23348.67 42323.67 28938.60\n[73] 25880.80 47345.67 18711.33 29087.29 20748.29 35933.71 15439.71 29787.50\n[81] 18145.00 21617.00 29203.89 41363.67 22259.09 44939.56 16902.00 16930.00\n```\n:::\n:::\n\n\nRecalled in the previous section, we retrieved the GDPPC of these five countries (neighbours of poly1 using queen method) by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb1 <- wm_q[[1]]\nnb1 <- hunan$GDPPC[nb1]\nnb1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20981 34592 24473 21311 22879\n```\n:::\n:::\n\n\nWe can append the spatially lag GDPPC values onto hunan sf data frame by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC)) # two lists: county and ave GDPC appended\nlag.res <- as.data.frame(lag.list) # class dataframe of Anxiang - 24847.20 , Hanshou 22724.80 etc\ncolnames(lag.res) <- c('NAME_3', 'lag GDPPC') # rename the col of lag.res\nhunan <- left_join(hunan,lag.res)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"NAME_3\"\n```\n:::\n:::\n\n\nThe average neighboring income values for each county is now stored as a new column 'lag GDPPC' in hunan sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 6 features and 36 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 110.4922 ymin: 28.61762 xmax: 112.3013 ymax: 30.12812\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3 Shape_Leng Shape_Area  County    City\n1 Changde 21098 Anxiang      County   1.869074 0.10056190 Anxiang Changde\n2 Changde 21100 Hanshou      County   2.360691 0.19978745 Hanshou Changde\n3 Changde 21101  Jinshi County City   1.425620 0.05302413  Jinshi Changde\n4 Changde 21102      Li      County   3.474325 0.18908121      Li Changde\n5 Changde 21103   Linli      County   2.289506 0.11450357   Linli Changde\n6 Changde 21104  Shimen      County   4.171918 0.37194707  Shimen Changde\n  avg_wage deposite     FAI Gov_Rev Gov_Exp     GDP GDPPC     GIO   Loan  NIPCR\n1    31935   5517.2  3541.0  243.64  1779.5 12482.0 23667  5108.9 2806.9 7693.7\n2    32265   7979.0  8665.0  386.13  2062.4 15788.0 20981 13491.0 4550.0 8269.9\n3    28692   4581.7  4777.0  373.31  1148.4  8706.9 34592 10935.0 2242.0 8169.9\n4    32541  13487.0 16066.0  709.61  2459.5 20322.0 24473 18402.0 6748.0 8377.0\n5    32667    564.1  7781.2  336.86  1538.7 10355.0 25554  8214.0  358.0 8143.1\n6    33261   8334.4 10531.0  548.33  2178.8 16293.0 27137 17795.0 6026.5 6156.0\n   Bed    Emp  EmpR EmpRT Pri_Stu Sec_Stu Household Household_R NOIP Pop_R\n1 1931 336.39 270.5 205.9  19.584  17.819     148.1       135.4   53 346.0\n2 2560 456.78 388.8 246.7  42.097  33.029     240.2       208.7   95 553.2\n3  848 122.78  82.1  61.7   8.723   7.592      81.9        43.7   77  92.4\n4 2038 513.44 426.8 227.1  38.975  33.938     268.5       256.0   96 539.7\n5 1440 307.36 272.2 100.8  23.286  18.943     129.1       157.2   99 246.6\n6 2502 392.05 329.6 193.8  29.245  26.104     190.6       184.7  122 399.2\n    RSCG Pop_T    Agri Service Disp_Inc      RORP    ROREmp lag GDPPC\n1 3957.9 528.3 4524.41   14100    16610 0.6549309 0.8041262  24847.20\n2 4460.5 804.6 6545.35   17727    18925 0.6875466 0.8511756  22724.80\n3 3683.0 251.8 2562.46    7525    19498 0.3669579 0.6686757  24143.25\n4 7110.2 832.5 7562.34   53160    18985 0.6482883 0.8312558  27737.50\n5 3604.9 409.3 3583.91    7031    18604 0.6024921 0.8856065  27270.25\n6 6490.7 600.5 5266.51    6981    19275 0.6647794 0.8407091  21248.80\n                        geometry\n1 POLYGON ((112.0625 29.75523...\n2 POLYGON ((112.2288 29.11684...\n3 POLYGON ((111.8927 29.6013,...\n4 POLYGON ((111.3731 29.94649...\n5 POLYGON ((111.6324 29.76288...\n6 POLYGON ((110.8825 30.11675...\n```\n:::\n:::\n\n\nNext, we will plot both the GDPPC and spatial lag GDPPC for comparison using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdppc <- qtm (hunan, 'GDPPC')\nlag_gdppc <- qtm(hunan, 'lag GDPPC')\ntmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_ex03_files/figure-html/unnamed-chunk-48-1.png){width=672}\n:::\n:::\n\n\n### 3.8.2 Spatial lag as a sum of neighboring values\n\n**Part 1: Obtain binary weights spatial weight matrix 'b_weights':**\n\nwm_q (aka neighbour list) is a 'nb' class containing neighbour IDs for each polygon. E.g. first three polygons has neighbours\n\n\\$ : int \\[1:5\\] 2 3 4 57 85\n\n\\$ : int \\[1:5\\] 1 57 58 78 85\n\n\\$ : int \\[1:4\\] 1 4 5 85\n\nTo create a binary list, we will now apply lambda function of 0\\*neighbour ID + 1 ; so that if there is a neighbour, the value is 1.\n\n**Part 2: Create the standardise row matrix using nb2listw() , with glist argument = b_weights to take binary feature into account**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb_weights <- lapply(wm_q, function(x) 0*x + 1) # class 'list'\n# [[2]]\n#[1] 1 1 1 1 1\n#[[3]]\n#[1] 1 1 1 1\n\nb_weights2 <- nb2listw(wm_q, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2 # class \"listw\" , \"nb\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224\n```\n:::\n:::\n\n\nWith the proper weights assigned, we can use lag.listw to compute a lag variable from our weight and GDPPC.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag_sum <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\nlag.res <- as.data.frame(lag_sum)\ncolnames(lag.res) <- c('NAME_3', 'lag_sum GDPPC')\n```\n:::\n\n\nexamine lag_sum (list of polygon and the sum of their neighbours' GDPPC)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag_sum\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n [1] \"Anxiang\"       \"Hanshou\"       \"Jinshi\"        \"Li\"           \n [5] \"Linli\"         \"Shimen\"        \"Liuyang\"       \"Ningxiang\"    \n [9] \"Wangcheng\"     \"Anren\"         \"Guidong\"       \"Jiahe\"        \n[13] \"Linwu\"         \"Rucheng\"       \"Yizhang\"       \"Yongxing\"     \n[17] \"Zixing\"        \"Changning\"     \"Hengdong\"      \"Hengnan\"      \n[21] \"Hengshan\"      \"Leiyang\"       \"Qidong\"        \"Chenxi\"       \n[25] \"Zhongfang\"     \"Huitong\"       \"Jingzhou\"      \"Mayang\"       \n[29] \"Tongdao\"       \"Xinhuang\"      \"Xupu\"          \"Yuanling\"     \n[33] \"Zhijiang\"      \"Lengshuijiang\" \"Shuangfeng\"    \"Xinhua\"       \n[37] \"Chengbu\"       \"Dongan\"        \"Dongkou\"       \"Longhui\"      \n[41] \"Shaodong\"      \"Suining\"       \"Wugang\"        \"Xinning\"      \n[45] \"Xinshao\"       \"Shaoshan\"      \"Xiangxiang\"    \"Baojing\"      \n[49] \"Fenghuang\"     \"Guzhang\"       \"Huayuan\"       \"Jishou\"       \n[53] \"Longshan\"      \"Luxi\"          \"Yongshun\"      \"Anhua\"        \n[57] \"Nan\"           \"Yuanjiang\"     \"Jianghua\"      \"Lanshan\"      \n[61] \"Ningyuan\"      \"Shuangpai\"     \"Xintian\"       \"Huarong\"      \n[65] \"Linxiang\"      \"Miluo\"         \"Pingjiang\"     \"Xiangyin\"     \n[69] \"Cili\"          \"Chaling\"       \"Liling\"        \"Yanling\"      \n[73] \"You\"           \"Zhuzhou\"       \"Sangzhi\"       \"Yueyang\"      \n[77] \"Qiyang\"        \"Taojiang\"      \"Shaoyang\"      \"Lianyuan\"     \n[81] \"Hongjiang\"     \"Hengyang\"      \"Guiyang\"       \"Changsha\"     \n[85] \"Taoyuan\"       \"Xiangtan\"      \"Dao\"           \"Jiangyong\"    \n\n[[2]]\n [1] 124236 113624  96573 110950 109081 106244 174988 235079 273907 256221\n[11]  98013 104050 102846  92017 133831 158446 141883 119508 150757 153324\n[21] 113593 129594 142149 100119  82884  74668  43184  99244  46549  20518\n[31] 140576 121601  92069  43258 144567 132119  51694  59024  69349  73780\n[41]  94651 100680  69398  52798 140472 118623 180933  82798  83090  97356\n[51]  59482  77334  38777 111463  74715 174391 150558 122144  68012  84575\n[61] 143045  51394  98279  47671  26360 236917 220631 185290  64640  70046\n[71] 126971 144693 129404 284074 112268 203611 145238 251536 108078 238300\n[81] 108870 108085 262835 248182 244850 404456  67608  33860\n```\n:::\n:::\n\n\nNext, we will append the *lag_sum GDPPC* field into `hunan` sf data frame by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, lag.res)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"NAME_3\"\n```\n:::\n:::\n\n\nPlot both the *GDPPC* and *Spatial Lag Sum GDPPC* for comparison\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdppc <- qtm(hunan, \"GDPPC\")\nlag_sum_gdppc <- qtm(hunan, \"lag_sum GDPPC\")\ntmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_ex03_files/figure-html/unnamed-chunk-53-1.png){width=672}\n:::\n:::\n\n\n### 3.8.3 Spatial window average\n\n-   row-standardized weights\n\n-   includes the diagonal element\n\nNeed to add the diagonal element to the neighbour structure before assigning weights. Start by using include.self to include 'k6' to a new variable before directly altering its structure to add diagonal element.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q1 <- wm_q\n```\n:::\n\n\nIF we want to add the diagonal element to the neighbour list, we just need to use *include.self()* from **spdep**. Use this instead to overwrite: wm_q1 \\<- include.self(wm_q1)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q1 <- include.self(wm_q1) #look the same as wm_q1 but diff structurally\n```\n:::\n\n\nTo obtain the row standardised weights with diagonal, use nb2listw()\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q1 <- nb2listw(wm_q1)\nwm_q1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 30.90265 357.5308\n```\n:::\n:::\n\n\nCreate the lag variable from our weight structure and GDPPC variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag_w_avg_gpdpc <- lag.listw(wm_q1, \n                             hunan$GDPPC)\nlag_w_avg_gpdpc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 24650.50 22434.17 26233.00 27084.60 26927.00 22230.17 47621.20 37160.12\n [9] 49224.71 29886.89 26627.50 22690.17 25366.40 25825.75 30329.00 32682.83\n[17] 25948.62 23987.67 25463.14 21904.38 23127.50 25949.83 20018.75 19524.17\n[25] 18955.00 17800.40 15883.00 18831.33 14832.50 17965.00 17159.89 16199.44\n[33] 18764.50 26878.75 23188.86 20788.14 12365.20 15985.00 13764.83 11907.43\n[41] 17128.14 14593.62 11644.29 12706.00 21712.29 43548.25 35049.00 16226.83\n[49] 19294.40 18156.00 19954.75 18145.17 12132.75 18419.29 14050.83 23619.75\n[57] 24552.71 24733.67 16762.60 20932.60 19467.75 18334.00 22541.00 26028.00\n[65] 29128.50 46569.00 47576.60 36545.50 20838.50 22531.00 42115.50 27619.00\n[73] 27611.33 44523.29 18127.43 28746.38 20734.50 33880.62 14716.38 28516.22\n[81] 18086.14 21244.50 29568.80 48119.71 22310.75 43151.60 17133.40 17009.33\n```\n:::\n:::\n\n\nconvert the lag variable listw object into a data.frame by using *as.data.frame()*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag.list.wm_q1 <- list(hunan$NAME_3, lag.listw(wm_q1, \n                             hunan$GDPPC))\nlag.list.wm_q1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n [1] \"Anxiang\"       \"Hanshou\"       \"Jinshi\"        \"Li\"           \n [5] \"Linli\"         \"Shimen\"        \"Liuyang\"       \"Ningxiang\"    \n [9] \"Wangcheng\"     \"Anren\"         \"Guidong\"       \"Jiahe\"        \n[13] \"Linwu\"         \"Rucheng\"       \"Yizhang\"       \"Yongxing\"     \n[17] \"Zixing\"        \"Changning\"     \"Hengdong\"      \"Hengnan\"      \n[21] \"Hengshan\"      \"Leiyang\"       \"Qidong\"        \"Chenxi\"       \n[25] \"Zhongfang\"     \"Huitong\"       \"Jingzhou\"      \"Mayang\"       \n[29] \"Tongdao\"       \"Xinhuang\"      \"Xupu\"          \"Yuanling\"     \n[33] \"Zhijiang\"      \"Lengshuijiang\" \"Shuangfeng\"    \"Xinhua\"       \n[37] \"Chengbu\"       \"Dongan\"        \"Dongkou\"       \"Longhui\"      \n[41] \"Shaodong\"      \"Suining\"       \"Wugang\"        \"Xinning\"      \n[45] \"Xinshao\"       \"Shaoshan\"      \"Xiangxiang\"    \"Baojing\"      \n[49] \"Fenghuang\"     \"Guzhang\"       \"Huayuan\"       \"Jishou\"       \n[53] \"Longshan\"      \"Luxi\"          \"Yongshun\"      \"Anhua\"        \n[57] \"Nan\"           \"Yuanjiang\"     \"Jianghua\"      \"Lanshan\"      \n[61] \"Ningyuan\"      \"Shuangpai\"     \"Xintian\"       \"Huarong\"      \n[65] \"Linxiang\"      \"Miluo\"         \"Pingjiang\"     \"Xiangyin\"     \n[69] \"Cili\"          \"Chaling\"       \"Liling\"        \"Yanling\"      \n[73] \"You\"           \"Zhuzhou\"       \"Sangzhi\"       \"Yueyang\"      \n[77] \"Qiyang\"        \"Taojiang\"      \"Shaoyang\"      \"Lianyuan\"     \n[81] \"Hongjiang\"     \"Hengyang\"      \"Guiyang\"       \"Changsha\"     \n[85] \"Taoyuan\"       \"Xiangtan\"      \"Dao\"           \"Jiangyong\"    \n\n[[2]]\n [1] 24650.50 22434.17 26233.00 27084.60 26927.00 22230.17 47621.20 37160.12\n [9] 49224.71 29886.89 26627.50 22690.17 25366.40 25825.75 30329.00 32682.83\n[17] 25948.62 23987.67 25463.14 21904.38 23127.50 25949.83 20018.75 19524.17\n[25] 18955.00 17800.40 15883.00 18831.33 14832.50 17965.00 17159.89 16199.44\n[33] 18764.50 26878.75 23188.86 20788.14 12365.20 15985.00 13764.83 11907.43\n[41] 17128.14 14593.62 11644.29 12706.00 21712.29 43548.25 35049.00 16226.83\n[49] 19294.40 18156.00 19954.75 18145.17 12132.75 18419.29 14050.83 23619.75\n[57] 24552.71 24733.67 16762.60 20932.60 19467.75 18334.00 22541.00 26028.00\n[65] 29128.50 46569.00 47576.60 36545.50 20838.50 22531.00 42115.50 27619.00\n[73] 27611.33 44523.29 18127.43 28746.38 20734.50 33880.62 14716.38 28516.22\n[81] 18086.14 21244.50 29568.80 48119.71 22310.75 43151.60 17133.40 17009.33\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlag_wm_q1.res <- as.data.frame(lag.list.wm_q1)\nhead(lag_wm_q1.res)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  c..Anxiang....Hanshou....Jinshi....Li....Linli....Shimen....Liuyang...\n1                                                                Anxiang\n2                                                                Hanshou\n3                                                                 Jinshi\n4                                                                     Li\n5                                                                  Linli\n6                                                                 Shimen\n  c.24650.5..22434.1666666667..26233..27084.6..26927..22230.1666666667..\n1                                                               24650.50\n2                                                               22434.17\n3                                                               26233.00\n4                                                               27084.60\n5                                                               26927.00\n6                                                               22230.17\n```\n:::\n:::\n\n\nrenames the field names of *lag_wm_q1.res* object into *NAME_3* and *lag_window_avg GDPPC* respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(lag_wm_q1.res) <- c(\"NAME_3\", \"lag_window_avg GDPPC\")\n```\n:::\n\n\nAppend *lag_window_avg GDPPC* values onto *hunan* sf data.frame by using *left_join()* of **dplyr** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, lag_wm_q1.res)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"NAME_3\"\n```\n:::\n:::\n\n\n*qtm()* of **tmap** package is used to plot the GDPPC and lag_window_avg GDPPC map next to each other for quick comparison.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdppc <- qtm(hunan, \"GDPPC\")\nw_avg_gdppc <- qtm(hunan, \"lag_window_avg GDPPC\")\ntmap_arrange(gdppc, w_avg_gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_ex03_files/figure-html/unnamed-chunk-62-1.png){width=672}\n:::\n:::\n\n\n### 3.8.4 Spatial window sum\n\nThe spatial window sum is the counter part of the window average, but\n\n-   without using row-standardized weights.\n\n-   assign binary weights to the neighbor structure that includes the diagonal element.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q2 <- wm_q\n```\n:::\n\n\nAdd the diagonal element to the neighbour list, we just need to use *include.self()* from **spdep**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q2 <- include.self(wm_q2)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(wm_q2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 10 12 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 2 links\n1 most connected region:\n85 with 12 links\n```\n:::\n:::\n\n\nAssign binary weights to the neighbour structure that includes the diagonal element. (If there is a neighbour, give a value of 1)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb_weights <- lapply(wm_q2, function(x) 0*x +1)\nb_weights[1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 1 1 1 1 1\n\n[[2]]\n[1] 1 1 1 1 1 1\n\n[[3]]\n[1] 1 1 1 1 1\n\n[[4]]\n[1] 1 1 1 1 1\n\n[[5]]\n[1] 1 1 1 1 1\n```\n:::\n:::\n\n\nuse *nb2listw()* and *glist()* to explicitly assign weight values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb_weigths2 <- nb2listw(wm_q2,glist=b_weights, style='B')\nb_weights2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224\n```\n:::\n:::\n\n\nWith our new weight structure, we can compute the lag variable with *lag.listw()*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw_sum_gdppc <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\nw_sum_gdppc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n [1] \"Anxiang\"       \"Hanshou\"       \"Jinshi\"        \"Li\"           \n [5] \"Linli\"         \"Shimen\"        \"Liuyang\"       \"Ningxiang\"    \n [9] \"Wangcheng\"     \"Anren\"         \"Guidong\"       \"Jiahe\"        \n[13] \"Linwu\"         \"Rucheng\"       \"Yizhang\"       \"Yongxing\"     \n[17] \"Zixing\"        \"Changning\"     \"Hengdong\"      \"Hengnan\"      \n[21] \"Hengshan\"      \"Leiyang\"       \"Qidong\"        \"Chenxi\"       \n[25] \"Zhongfang\"     \"Huitong\"       \"Jingzhou\"      \"Mayang\"       \n[29] \"Tongdao\"       \"Xinhuang\"      \"Xupu\"          \"Yuanling\"     \n[33] \"Zhijiang\"      \"Lengshuijiang\" \"Shuangfeng\"    \"Xinhua\"       \n[37] \"Chengbu\"       \"Dongan\"        \"Dongkou\"       \"Longhui\"      \n[41] \"Shaodong\"      \"Suining\"       \"Wugang\"        \"Xinning\"      \n[45] \"Xinshao\"       \"Shaoshan\"      \"Xiangxiang\"    \"Baojing\"      \n[49] \"Fenghuang\"     \"Guzhang\"       \"Huayuan\"       \"Jishou\"       \n[53] \"Longshan\"      \"Luxi\"          \"Yongshun\"      \"Anhua\"        \n[57] \"Nan\"           \"Yuanjiang\"     \"Jianghua\"      \"Lanshan\"      \n[61] \"Ningyuan\"      \"Shuangpai\"     \"Xintian\"       \"Huarong\"      \n[65] \"Linxiang\"      \"Miluo\"         \"Pingjiang\"     \"Xiangyin\"     \n[69] \"Cili\"          \"Chaling\"       \"Liling\"        \"Yanling\"      \n[73] \"You\"           \"Zhuzhou\"       \"Sangzhi\"       \"Yueyang\"      \n[77] \"Qiyang\"        \"Taojiang\"      \"Shaoyang\"      \"Lianyuan\"     \n[81] \"Hongjiang\"     \"Hengyang\"      \"Guiyang\"       \"Changsha\"     \n[85] \"Taoyuan\"       \"Xiangtan\"      \"Dao\"           \"Jiangyong\"    \n\n[[2]]\n [1] 124236 113624  96573 110950 109081 106244 174988 235079 273907 256221\n[11]  98013 104050 102846  92017 133831 158446 141883 119508 150757 153324\n[21] 113593 129594 142149 100119  82884  74668  43184  99244  46549  20518\n[31] 140576 121601  92069  43258 144567 132119  51694  59024  69349  73780\n[41]  94651 100680  69398  52798 140472 118623 180933  82798  83090  97356\n[51]  59482  77334  38777 111463  74715 174391 150558 122144  68012  84575\n[61] 143045  51394  98279  47671  26360 236917 220631 185290  64640  70046\n[71] 126971 144693 129404 284074 112268 203611 145238 251536 108078 238300\n[81] 108870 108085 262835 248182 244850 404456  67608  33860\n```\n:::\n:::\n\n\nConvert the lag variable listw object into a data.frame by using *as.data.frame()*.\n\nRename the field names of *w_sum_gdppc.res* object into *NAME_3* and *w_sum GDPPC* respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw_sum_gdppc.res <- as.data.frame(w_sum_gdppc)\ncolnames(w_sum_gdppc.res) <- c(\"NAME_3\", \"w_sum GDPPC\")\n```\n:::\n\n\nAppend *w_sum GDPPC* values onto *hunan* sf data.frame by using *left_join()* of **dplyr** package\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, w_sum_gdppc.res)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"NAME_3\"\n```\n:::\n:::\n\n\nUse *qtm()* of **tmap** package is used to plot the GDPPC and lag_sum GDPPC map next to each other for quick comparison\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdppc <- qtm(hunan, \"GDPPC\")\nw_sum_gdppc <- qtm(hunan, \"w_sum GDPPC\")\ntmap_arrange(gdppc, w_sum_gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_ex03_files/figure-html/unnamed-chunk-71-1.png){width=672}\n:::\n:::\n\n\n1\\. Coords- refers to coordinates (x,y) of centroid's CG\n\n2\\. Neighbour id list (Queen, rook, dist based, fix nn)\n\n3\\. Spatial weight matrix based on inverse distance matrix (ids) nbdists () & lapply () , based on a neighbour id list\n\n4.1. Row standardize matrix using rswm_q\\<-nb2listw(wm_q) (equal weight for each neighbour)\n\n4.2. Row standardize inverse distance matrix using Rswm_ids\\<-nb2listw(neighbour id list wm_q, glist= ids)\n\n5.1 Create spatially lagged values with standardized weights for each polygon - lag.listw(rswm_q, hunan\\$gdppc) (Usually standardised rows (for find ave spatial lagged variables) for Queen/Rook methods)\n\n5.2. Create spatially lagged values as SUM of neighbouring values\n\n-   Create neighbour structure with Binary weights using b_weights\\<-lapply (wm_q, function(x) 0\\*x+1)\n\n-   b_weights2\\<-Nb2listw(wm_q, glist=b_weights) to assign weights\n\n-   Create lag sum variable (a calculated variable for each polygons's gdppc neighbour sum) using lag.listw(b_weights2, hunan\\$gdpcc) again\n\n5.3. Spatial Window AVERAGE (create neighbour structure with (or without) diagonals , standardize rows with equal weight)\n\n-   wm_q1 \\<-Include.self(wm_q)\n\n-   Standardize row weights using nb2listw() again\n\n-   Use lag.listw() again to get spatially lag variable\n\n-   Append, set as df, rename cols, left join , plot qtm x2 and tm_arrange()\n\n5.4. Spatial Weights SUM (without row standardized weights, assign binary weights to neighbour structure with (or without) diagonal element)\n\n## 3.9 References\n\n-   [Creating Neighbours using sf objects](https://cran.r-project.org/web/packages/spdep/vignettes/nb_sf.html)\n",
    "supporting": [
      "Hands-on_ex03_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}