---
title: "Hands-on_Ex03"
editor: visual
---

## 3.1 Overview

In this hands-on exercise, I will learn how to compute spatial weights.

## 3.2 The Study Area and Data

-   Hunan country boundary layer -geospatial data in ESRI shapefile format
-   hunan_2012.csv - contains local development indicators in 2012

### 3.2.1 Getting Started (ctrl-atl-i)

```{r}
library(sf)
library(spdep)
library(tmap)
library(tidyverse)
```

## 3.3 Getting the Data Into R Environment

### 3.3.1 Import shapefile into r environment

```{r}
hunan <- st_read(dsn='data/geospatial' ,
                 layer = 'Hunan')
```

### 3.3.2 Import csv file into r environment

```{r}
hunan2012 <- read_csv('data/aspatial/Hunan_2012.csv')
```

### 3.3.3 Performing relational join

Update attribute table of Hunan's SpatialPolygonDataFrame (dbf) with attribute field of hunan2012 dataframe. (csv)

```{r}
hunan <- left_join(hunan, hunan2012)
```

hunan 's coordinate system is WGS 84. Does it mean that we are nut using projected system here?

```{r}
st_geometry(hunan)
```

## 3.4 Visualising Regional Development Indicator

-   prepare basemap and choropleth map showing distribution of GDPCC 2012 by using qtm() of tmap package

```{r}
basemap <- tm_shape(hunan) +
  tm_polygons() +
  tm_text('NAME_3', size = 0.3)

gdppc <- qtm(hunan, 'GDPPC')

tmap_arrange(basemap, gdppc, asp = 1, ncol=2)
```

## 3.5 Computing Contiguity Spatial Weights

-   use [*poly2nb()*](https://r-spatial.github.io/spdep/reference/poly2nb.html) of **spdep** package to compute contiguity weight matrices

-   this weight matrices has class of 'nb'

-   this function builds a neighbour list based on regions with contiguous boundaries

-   the 'queen' argument's default value is set to FALSE (first order neighbours). Might need to set to TRUE when needed

### 3.5.1 Computing (QUEEN) contiguity based neighbours

```{r}
wm_q <- poly2nb(hunan, queen=TRUE)
summary(wm_q)
```

-   88 area units in Hunan

-   most connected unit (88) has 11 neighbours

-   two area units (30 & 65) with only one neighbour

To see the neighbours of the first polygon, use code chunk below:

```{r}
wm_q[[1]]
```

```{r}
class(wm_q[[1]])
```

YX tried to show the neighbours of first 2 polygons

```{r}
wm_q[1:2]
```

To retrieve the country name of the Polygon ID = 1, use code chunk below:

```{r}
hunan$County[1]

```

To reveal the country names of the five neighbouring polygons,

```{r}
hunan$NAME_3[c(2,3,4,57,85)]
```

To retrieve the GDPPC of the five neighbour countries,

```{r}
nb1 <- wm_q[[1]]
nb1 <- hunan$GDPPC[nb1]
nb1
```

YX's practise (use c(2,3,4,57,85)) instead of wm_q\[\[1\]\]

```{r}
nb1 <- wm_q[[1]] #neighbours of polygon ID=1
nb1 <- hunan$GDPPC[c(2,3,4,57,85)] #retrieve GDPPC of neighbours of polygon ID= 1
nb1
```

To display the complete weight matrix, use str()

-   row 1: neighbours of polygon ID =1

-   row 2: neighbours of polygon ID =2 etc..

```{r}
str(wm_q)
```

### 3.5.2 Creating (ROOK) contiguity based neighbours

To compute the Rook contiguity weight matrix,

```{r}
wm_r <- poly2nb(hunan, queen=FALSE)
summary(wm_r)
```

-   88 area units in Hunan

-   most connected unit (85) has 11 neighbours

-   two area units (30 & 65) with only one neighbour

### 3.5.3 Visualising contiguity weights

-   a connectivity graph takes a point and displays a line to each neighbouring point

-   need a point in polygon via polygon centroids \<- calculate using the sf package first

To obtain coordinates in a separate data frame

1.  input vector is the geometry column of us.bound, an sf object \<- a polygon

2.  apply mapping function (st_centroid) on input vector \<- find the CG of this polygon

3.  use map_dbl variation of map from the purrr package

After finding centroid, to access longitude values

-   double bracket notation \[\[ \]\] and 1

```{r}
longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])
```

To access the latitude value

-   double bracket notation \[\[ \]\] and 2

```{r}
latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])
```

With both longitude and latitude, use cbind() to combine both in the same object,

```{r}
coords <- cbind(longitude, latitude)
```

Check the first few observations,

```{r}
head(coords)
```

#### 3.5.3.1 Plotting Queen contiguity based neighbours map

Use the [plot()](https://www.digitalocean.com/community/tutorials/plot-function-in-r) function

1.  **The shape of the markers:** The plot markers are by default small, empty circles. These are also known as plot characters - denoted by **pch**. You can change these by adding a new **pch** value in the plot function. Pch values 0 to 25 are valid and give several different symbols on the graph. **Pch** 0 is for a square, 1 is for a circle, 3 is for a triangle, 4 is for a cross and so on.

2.  **Size of the plot markers**: This aspect of a graph can be controlled using the **cex** parameter. The **cex** parameter can be set to 0.5 if you want the markers to be 50% smaller and 1.5 if you want them to be 50% larger.

3.  **Color of the plot markers:** The symbols can be assigned one or many colors. These colors can be selected from a list provided by R under the `colors()` function.

wm\_ q is weight matrix using queen method (88 rows of list of neighbours)

coords is an array of x,y coordinates for each of the 88 counties

```{r}
plot(hunan$geometry, border = 'lightgrey')
plot(wm_q, coords, pch = 19, cex = 0.6, add= TRUE, col='red')

```

#### 3.5.3.2 Plotting Rook contiguity based neighbours map

```{r}
plot(hunan$geometry, border = 'lightgrey')
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col ="blue")
```

#### 3.5.3.3 Plotting both Queen and Rook contiguity based neighbours maps

Use the [par(mfrow)](https://bookdown.org/ndphillips/YaRrr/arranging-plots-with-parmfrow-and-layout.html) function

```{r}
par(mfrow = c(1,2))  # by 1 by 2 plotting matrix
plot(hunan$geometry, border="lightgrey", main="Queen Contiguity")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
plot(hunan$geometry, border="lightgrey", main="Rook Contiguity")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

## 3.6 Computing distance based neighbours

-   In this section, I will derive distance-based weight matrices by using [*dnearneigh()*](https://r-spatial.github.io/spdep/reference/dnearneigh.html) of **spdep** package.

        dnearneigh(x, d1, d2, row.names = NULL, longlat = NULL, bounds=c("GE", "LE"),
         use_kd_tree=TRUE, symtest=FALSE, use_s2=packageVersion("s2") > "1.0.7", k=200,
         dwithin=TRUE)

-   identifies neighbours using distance band with lower d1= and upper d2= bounds controlled by the bounds= argument

-   If unprojected coordinates are used and either specified in the coordinates object x or with x as a two column matrix and longlat=TRUE, great circle distances in **km** will be calculated assuming the WGS84 reference ellipsoid.

### 3.6.1 First, determine the cut-off distance (upper distance threshold to be considered a neighbour)

First, determine the upper limit for distance band by using the steps below:

-   Return a matrix with the indices of points belonging to the set of the k nearest neighbours of each other by using [*knearneigh()*](https://r-spatial.github.io/spdep/reference/knearneigh.html) of **spdep**. Output: NN of poly1 = poly3, NN of poly2 = poly 78 etc.... The output iz a knn object with class 'knn'.

    \$nn

    \[,1\]

    \[1,\] 3

    \[2,\] 78

    \[3,\] 1

-   After applying *knearneigh()* , convert the knn object into a neighbours list of class nb with a list of integer vectors containing neighbour region number ids by using [*knn2nb()*](https://r-spatial.github.io/spdep/reference/knn2nb.html).

Neighbour list object:

Number of regions: 88

Number of nonzero links: 88

Percentage nonzero weights: 1.136364

Average number of links: 1

Non-symmetric neighbours list

-   Return the length of neighbour relationship edges by using [*nbdists()*](https://r-spatial.github.io/spdep/reference/nbdists.html) of **spdep**. \<- returns the distance to one's nearest neighbour? 88 polygons means 88 nearest neighbours. The function returns in the units of the coordinates if the coordinates are projected (in km if unprojected)

\[\[1\]\]

\[1\] 25.53398

\[\[2\]\]

\[1\] 43.03114

\[\[3\]\]

\[1\] 25.53398

-   Remove the list structure of the returned object by using [**unlist()**](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/unlist). The output is in numeric format.

Output: 25.53398 43.03114 25.53398 29.28480 29.28480 45.98097 58.52704 28.95985 34.45062 37.99885 44.49442 33.48816 35.98123

```{r}
#coords <- coordinates(hunan)
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)

```

**The summary report shows that the largest first nearest neighbour distance is 61.79. So using this as the upper threshold will help to ensure that all units (polygons) will have at least one neighbour**.

```{r}
class (k1)
```

```{r}
class(k1dists)
```

### 3.6.2 Computing [fixed]{.underline} distance weight matrix

(Earlier, we had used poly2nb(hunan, queen=TRUE/FALSE) to find neighbours using Queen or Rook method)

Now, to find neighbours using distance, we use the dnearneigh() ,

-   *longlad argument: TRUE if point coordinates are geographical longitude-latitude decimal degrees*

Does the average number of links mean that each polygon has average number of 3.6 nearest neighbours with upper bound of 62?

```{r}
wm_d62 <- dnearneigh(coords,0, 62, longlat=TRUE)  #class 'nb'
wm_d62
```

```{r}
str(wm_d62)
```

Another way to display the structure of the weight matrix is to combine [*table()*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/table) and [*card()*](https://r-spatial.github.io/spdep/reference/card.html) of spdep.

```{r}
table(hunan$County, card(wm_d62))
```

```{r}
n_comp <- n.comp.nb(wm_d62)
n_comp$nc
```

```{r}
table(n_comp$comp.id)
```

#### 3.6.2.1 Plotting fixed distance weight matrix

-   wm_d62 is the fixed distance weight matrix,

-   coords refers to long, lat coordinates for CG of each polygon

-   k1 is the integer ID of the polygon which is the nearest neighbour to me

```{r}
plot(hunan$geometry, border = 'lightgrey')
plot (wm_d62, coords,add=TRUE)
plot(k1, coords, add=TRUE, col ='red', length=0.08)
```

The red lines shows the links of 1st nearest neighbours and the black lines show the lines of neighbours within the cut-off distance of 62km.

To plot red and black side by side,

```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border='light grey', main="1st NN")
plot(k1, coords, add=TRUE, col="red", length='0.08')
plot(hunan$geometry, border='light grey', main='Distance Link')
plot(wm_d62, coords, add=TRUE, pch=19, cex=0.6)
```

### 3.6.3 Computing [adaptive]{.underline} distance weight matrix

One of the characteristics of fixed distance weight matrix is that more densely settled areas (usually the urban areas) tend to have more neighbours and the less densely settled areas (usually the rural counties) tend to have lesser neighbours. Having many neighbours smoothes the neighbour relationship across more neighbours.

It is possible to control the numbers of neighbours directly using k-nearest neighbours, either accepting asymmetric neighbours or imposing symmetry as shown in the code chunk below.

```{r}
knn6 <- knn2nb(knearneigh(coords, k = 6))
knn6
```

*\*as seen above, each polygon has strictly six neighbours*

```{r}
str(knn6)
```

#### 3.6.3.1 Plotting distance based neighbours

```{r}
plot(hunan$geometry, border="light grey")
plot(knn6, coords, pch= 19, cex=0.6, add=TRUE, col='red')
```

## 3.7 Weights based on IDW

## 3.8 Application of Spatial Weight Matrix

### 3.8.1 Spatial lag with row-standardized weights

### 3.8.2 Spatial lag as a sum of neighboring values

### 3.8.3 Spatial window average

### 3.8.4 Spatial window sum

## 3.9 References

-   [Creating Neighbours using sf objects](https://cran.r-project.org/web/packages/spdep/vignettes/nb_sf.html)
