---
title: "Hands-on_Ex05"
editor: visual
---

# 5  Geographical Segmentation with Spatially Constrained Clustering Techniques

## 5.1 Overview

In this hands-on exercise, I will

-   delineate homogeneous region by using geographically referenced multivariate data

-   There are two major analysis, namely:

    -   hierarchical cluster analysis; and

    -   spatially constrained cluster analysis.

### 5.1.1 Learning Outcome

-   to convert GIS polygon data into R's simple feature data.frame by using appropriate functions of **sf** package of R;

-   to convert simple feature data.frame into R's SpatialPolygonDataFrame object by using appropriate **sf** of package of R;

-   to perform custer analysis by using *hclust()* of Base R;

-   to perform spatially constrained cluster analysis using *skater()* of Base R; and

-   to visualise the analysis output by using **ggplot2** and **tmap** package.

## 

5.2 Getting Started

### 5.2.1 The analytical question

In this hands-on exercise, we are interested to delineate [Shan State](https://en.wikipedia.org/wiki/Shan_State), [Myanmar](https://en.wikipedia.org/wiki/Myanmar) into homogeneous regions by using multiple Information and Communication technology (ICT) measures, namely: Radio, Television, Land line phone, Mobile phone, Computer, and Internet at home.

## 5.3 The data

Two data sets will be used in this study. They are:

-   Myanmar Township Boundary Data (i.e. *myanmar_township_boundaries*) : This is a GIS data in ESRI shapefile format. It consists of township boundary information of Myanmar. The spatial data are captured in polygon features. \<- geospatial data

-   *Shan-ICT.csv*: This is an extract of [**The 2014 Myanmar Population and Housing Census Myanmar**](https://myanmar.unfpa.org/en/publications/2014-population-and-housing-census-myanmar-data-sheet) at the township level. \< aspatial data

Both data sets are download from [Myanmar Information Management Unit (MIMU)](http://themimu.info/)

### 5.3.1 Installing and loading R packages

```{r}
pacman::p_load(rgdal, spdep, tmap, sf, 
               ggpubr, cluster, factoextra, NbClust,
               heatmaply, corrplot, psych, tidyverse)
```

## 5.4 Data Import and Prepatation

### 5.4.1 Importing geospatial data into R environment

The Myanmar Township Boundary GIS data is in ESRI shapefile format. It will be imported into R environment by using the [*st_read()*](https://www.rdocumentation.org/packages/sf/versions/0.7-2/topics/st_read) function of **sf**. Opening the .prj file in notepad reveals that it is in WGS 84 which has a crs code of 4326.

```{r}
shan_sf <-st_read(dsn='data/geospatial',
                  layer='myanmar_township_boundaries')
```

Check the states in Myanmar:

```{r}
library(funModeling)
freq (data = shan_sf,
input = 'ST')
```

```{r}
#| eval: false
dplyr::count(wp_nga, status_cle, sort = TRUE)
```

Retrieve only the SHAN states

```{r}
shan_sf <- shan_sf %>% 
  filter(ST %in% c("Shan (East)", "Shan (North)", "Shan (South)"))
```

Checking after filtering, Reduced to only 55 Rows, exactly the same as the number of rows in excel ICT file.

```{r}
shan_sf
```

Notice that sf.data.frame is conformed to Hardy Wickham's [tidy](https://edzer.github.io/rstudio_conf/#1) framework.

Since *shan_sf* is conformed to tidy framework, we can also *glimpse()* to reveal the data type of it's fields.

```{r}
glimpse(shan_sf)
```

### 5.4.2 Importing aspatial data into R environment

The csv file will be import using *read_csv* function of **readr** package.

```{r}
ict <- read_csv('data/aspatial/Shan-ICT.csv')
```

The imported InfoComm variables are extracted from **The 2014 Myanmar Population and Housing Census Myanmar**. The attribute data set is called *ict*. It is saved in R's \* tibble data.frame\* format.

The code chunk below reveal the summary statistics of *ict* data.frame.

```{r}
class(ict)
```

```{r}
summary(ict)
```

There are a total of eleven fields and 55 observation in the tibble data.frame. In Myanmar, State - district - township

### 5.4.3 Derive new variables using **dplyr** package

The unit of measurement of the values are number of household. Using these values directly will be bias by the underlying total number of households. In general, the townships with relatively higher total number of households will also have higher number of households owning radio, TV, etc.

In order to overcome this problem, we will derive the penetration rate of each ICT variable by using the code chunk below.

```{r}

ict_derived <- ict %>%
  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%
  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%
  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%
  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%
  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%
  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%
  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,
         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,
         `TT_HOUSEHOLDS`=`Total households`,
         `RADIO`=`Radio`, `TV`=`Television`, 
         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,
         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) 
```

Six new fields have been added into the data.frame. They are RADIO_PR, TV_PR, LLPHONE_PR, MPHONE_PR, COMPUTER_PR, and INTERNET_PR.

```{r}
summary(ict_derived)
```

## 5.5 Exploratory Data Analysis (EDA)

### 5.5.1 EDA using statistical graphics

We can plot the distribution of the variables (i.e. Number of households with radio) by using appropriate Exploratory Data Analysis (EDA) as shown in the code chunk below.

Histogram is useful to identify the overall distribution of the data values (i.e. left skew, right skew or normal distribution)

```{r}
ggplot(data=ict_derived,
       aes(x=`RADIO`)) +
  geom_histogram(bins=20,
                 color='black',
                 fill='light blue')
```

Boxplot is useful to detect if there are outliers.

```{r}
ggplot(data=ict_derived,
       aes(x=`RADIO`)) +
  geom_boxplot(color='black',
                 fill='light blue')
```

Next, we will also plotting the distribution of the newly derived variables (i.e. Radio penetration rate) by using the code chunk below.

```{r}
ggplot(data=ict_derived,
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20,
                 color='black',
                 fill='light blue')
```

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO_PR`)) +
  geom_boxplot(color="black", 
               fill="light blue")
```

RADIO_PR (RADIO/TOTAL \* 1000) is a better variable to use than RADIO alone as its is lesser in range, more normally distributed and less outlier.

To create multiple histograms of the other variables in a single plot:

```{r}
radio <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

tv <- ggplot(data=ict_derived, 
             aes(x= `TV_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

llphone <- ggplot(data=ict_derived, 
             aes(x= `LLPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

mphone <- ggplot(data=ict_derived, 
             aes(x= `MPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

computer <- ggplot(data=ict_derived, 
             aes(x= `COMPUTER_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

internet <- ggplot(data=ict_derived, 
             aes(x= `INTERNET_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```

Next, the [*ggarange()*](https://rpkgs.datanovia.com/ggpubr/reference/ggarrange.html) function of [**ggpubr**](https://rpkgs.datanovia.com/ggpubr/) package is used to group these histograms together.

```{r}
ggarrange(radio, tv ,llphone, mphone, computer, internet,
          ncol=3,
          nrow=2)
```

### 5.5.2 EDA using choropleth map

#### 5.5.2.1 Joining geospatial data with aspatial data

-   First, we need to combine the geospatial data (i.e. *shan_sf*) and the aspatial data (i.e. *ict_derived*) together using the [*left_join*](https://dplyr.tidyverse.org/reference/join.tbl_df.html) function of **dplyr** package.

-   The *shan_sf* simple feature data.frame will be used as the base data object and the *ict_derived* data.frame will be used as the join table.

```{r}
shan_sf <- left_join(shan_sf,
                     ict_derived,
                     by = c('TS_PCODE'='TS_PCODE'))
```

The message above shows that *TS_CODE* field is the common field used to perform the left-join.

It is important to note that there is no new output data been created. Instead, the data fields from *ict_derived* data frame are now updated into the data frame of *shan_sf*.

#### 5.5.2.2 Preparing a choropleth map

To have a quick look at the distribution of Radio penetration rate of Shan State at township level, a choropleth map will be prepared.

The code chunks below are used to prepare the choroplethby using the *qtm()* function of **tmap** package.

```{r}
qtm(shan_sf, 'RADIO_PR') +
  tm_layout(legend.width= 0.3,
            legend.height = 0.3)
```

In order to reveal the distribution shown in the choropleth map above are bias to the underlying total number of households at the townships, we will create two choropleth maps, one for the total number of households (i.e. TT_HOUSEHOLDS.map) and one for the total number of household with Radio (RADIO.map) by using the code chunk below.

```{r}
TT_HOUSEHOLDS.map <- tm_shape(shan_sf) +
  tm_fill(col='TT_HOUSEHOLDS',
          n= 5,
          style='jenks',
          title = 'Total households') +
  tm_borders(alpha = 0.5) +
  tm_layout(legend.width= 0.3,
            legend.height = 0.3)

RADIO.map <- tm_shape(shan_sf) + 
  tm_fill(col = "RADIO",
          n = 5,
          style = "jenks",
          title = "Number Radio ") + 
  tm_borders(alpha = 0.5) +
  tm_layout(legend.width= 0.3,
            legend.height = 0.3)

tmap_arrange(TT_HOUSEHOLDS.map, RADIO.map,
             asp=NA, ncol=2)
```

Notice that the choropleth maps above clearly show that townships with relatively larger number of households are also showing relatively higher number of radio ownership.

Now let us plot the choropleth maps showing the distribution of total number of households and Radio penetration rate by using the code chunk below.

```{r}
tm_shape(shan_sf) +
    tm_polygons(c("TT_HOUSEHOLDS", "RADIO_PR"),
                style="jenks") +
    tm_facets(sync = TRUE, ncol = 2) +
  tm_legend(legend.position = c("right", "bottom"))+
  tm_layout(outer.margins=0, asp=0)
```

There are some regions with lower number of households that actually have higher RADIO_PR.

## 5.6 Correlation Analysis

Remember for hierarchical clustering, there are three conditions to be met: (1) not to large a range (else standardisation) , (2) no missing values and (3) no multi-collinearity in the data variables.

Before we perform cluster analysis, it is important for us to ensure that the cluster variables are not highly correlated.

In this section, you will learn how to use [*corrplot.mixed()*](https://cran.r-project.org/web/packages/corrplot/corrplot.pdf) function of [**corrplot**](https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html) package to visualise and analyse the correlation of the input variables.

```{r}
attributes(ict_derived)
```

Get the correlationship between selected columns

```{r}
cluster_vars.cor = cor(ict_derived[12:17])
cluster_vars.cor
```

Plot the correlationship scatterlot

| **corrplot.mixed** Using mixed methods to visualize a correlation matrix. Description: Using mixed methods to visualize a correlation matrix.

corrplot.mixed( corr, lower = "number", upper = "circle", tl.pos = c("d", "lt", "n"), diag = c("n", "l", "u"), bg = "white", addgrid.col = "grey", lower.col = NULL, upper.col = NULL, plotCI = c("n", "square", "circle", "rect"), mar = c(0, 0, 0, 0), \... ) \| **Arguments** **corr** Matrix, the correlation matrix to visualize. **lower** Character, the visualization method for the lower triangular correlation matrix. **upper** Character, the visualization method for the upper triangular correlation matrix. **tl.pos** Character, 'lt', 'd' or 'n', giving position of text labels, 'lt' means left and top, 'd' means diagonal. If 'n', add no textlabel. **diag** Character, for specifying the glyph on the principal diagonal. It is one of 'n' (default, draw nothing), 'l' (draw the glyphs of lower triangular) or 'u' (draw the glyphs of upper triangular). **bg** The background color. **addgrid.col** See the addgrid.col parameter in the function corrplot **lower.col** Passed as col parameter to the lower matrix. **upper.col** Passed as col parameter to the upper matrix. **plotCI** See the plotCI parameter in the function corrplot

```{r}
corrplot.mixed(cluster_vars.cor,
               lower ='ellipse',
               upper= 'number',
               tl.pos = 'lt',
               diag = 'l',
               tl.col='black')
```

The correlation plot above shows that COMPUTER_PR and INTERNET_PR are highly correlated. This suggest that only one of them should be used in the cluster analysis instead of both

## 5.7 Hierarchy Cluster Analysis

In this section, you will learn how to perform hierarchical cluster analysis. The analysis consists of four major steps:

### 5.7.1 Extrating clustering variables

The code chunk below will be used to extract the clustering variables from the *shan_sf* simple feature object into data.frame. The INTERNET_PR is intentionally left out as it is highly correlated with COMPUTER_PR

```{r}
cluster_vars <- shan_sf %>% 
  st_set_geometry(NULL) %>% 
  select("TS.x", "RADIO_PR", "TV_PR", "LLPHONE_PR", "MPHONE_PR", "COMPUTER_PR")
head(cluster_vars, 10)
```

Next, we need to change the rows by township name instead of row number by using the code chunk below

```{r}
row.names(cluster_vars) <- cluster_vars$"TS.x"
head(cluster_vars, 10)
```

Notice that the row number has been replaced into the township name.

Now, we will delete the TS.x field by using the code chunk below.

Do not select column 1 as it is TS.x

```{r}
shan_ict <- select(cluster_vars, c(2:6))
head(shan_ict, 10)
```

### 5.7.2 Data Standardisation

In general, multiple variables will be used in cluster analysis. It is not unusual their values range are different. In order to avoid the cluster analysis result is baised to clustering variables with large values, it is useful to standardise the input variables before performing cluster analysis.

### 5.7.3 Min-Max standardisation

### 5.7.4 Z-score standardisation

### 5.7.5 Visualising the standardised clustering variables

### 5.7.6 Computing proximity matrix

### 5.7.7 Computing hierarchical clustering

### 5.7.8 Selecting the optimal clustering algorithm

### 5.7.9 Determining Optimal Clusters

#### 5.7.9.1 Gap Statistic Method

### 5.7.10 Interpreting the dendrograms

### 5.7.11 Visually-driven hierarchical clustering analysis

#### 5.7.11.2 Plotting interactive cluster heatmap using *heatmaply()*

### 5.7.12 Mapping the clusters formed

## 5.8 Spatially Constrained Clustering - SKATER approach

In this section, you will learn how to derive spatially constrained cluster by using [*skater()*](https://r-spatial.github.io/spdep/reference/skater.html) method of [**spdep**](https://r-spatial.github.io/spdep/) package.

### 5.8.1 Converting into SpatialPolygonsDataFrame

### 5.8.2 Computing Neighbour List

### 5.8.3 Computing minimum spanning tree

#### 5.8.3.1 Calculating edge costs

### 5.8.4 Computing minimum spanning tree

### 5.8.5 Computing spatially constrained clusters using SKATER method

### 5.8.6 Visualising the clusters in choropleth map
